<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>Spring | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.8dc26b26.js"><link rel="modulepreload" href="/study/assets/spring.html.483e27f3.js"><link rel="modulepreload" href="/study/assets/spring.html.afb64622.js"><link rel="prefetch" href="/study/assets/index.html.d1d2703b.js"><link rel="prefetch" href="/study/assets/index.html.ab4d3b10.js"><link rel="prefetch" href="/study/assets/index.html.a1d50b27.js"><link rel="prefetch" href="/study/assets/index.html.25b0938c.js"><link rel="prefetch" href="/study/assets/gin.html.6ae37a6c.js"><link rel="prefetch" href="/study/assets/golang.html.4c4fad36.js"><link rel="prefetch" href="/study/assets/gorm.html.7a905a91.js"><link rel="prefetch" href="/study/assets/Javaweb.html.a5e44981.js"><link rel="prefetch" href="/study/assets/ES.html.336dab3f.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.f7b6cb00.js"><link rel="prefetch" href="/study/assets/Java笔记.html.3eba7aa2.js"><link rel="prefetch" href="/study/assets/dubbo.html.49fc94f1.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.b0eead76.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.b301d9c5.js"><link rel="prefetch" href="/study/assets/zookeeper.html.712d96f5.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.5a89910c.js"><link rel="prefetch" href="/study/assets/并发编程.html.543b6bcc.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.b2f24320.js"><link rel="prefetch" href="/study/assets/redis.html.2283889d.js"><link rel="prefetch" href="/study/assets/Mybatis.html.ed42755b.js"><link rel="prefetch" href="/study/assets/springboot.html.487658dc.js"><link rel="prefetch" href="/study/assets/springboot.html.c2478316.js"><link rel="prefetch" href="/study/assets/springMVC.html.c9be3019.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.2bd0cdf1.js"><link rel="prefetch" href="/study/assets/操作系统.html.79001fb6.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.0f7a0e0f.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.b4f6582d.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.2b62d271.js"><link rel="prefetch" href="/study/assets/index.html.0d6fe0c9.js"><link rel="prefetch" href="/study/assets/index.html.bb9f607b.js"><link rel="prefetch" href="/study/assets/index.html.51225c5c.js"><link rel="prefetch" href="/study/assets/gin.html.86d034cb.js"><link rel="prefetch" href="/study/assets/golang.html.e5f0bf05.js"><link rel="prefetch" href="/study/assets/gorm.html.26d325f4.js"><link rel="prefetch" href="/study/assets/Javaweb.html.64ef5f8c.js"><link rel="prefetch" href="/study/assets/ES.html.f4f481eb.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.888cd7cc.js"><link rel="prefetch" href="/study/assets/Java笔记.html.7b6096d7.js"><link rel="prefetch" href="/study/assets/dubbo.html.6720b819.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.5d469fdf.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.9524d260.js"><link rel="prefetch" href="/study/assets/zookeeper.html.ebd80743.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.08d7bbca.js"><link rel="prefetch" href="/study/assets/并发编程.html.e624b0a2.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.eaadca6e.js"><link rel="prefetch" href="/study/assets/redis.html.5754ca1c.js"><link rel="prefetch" href="/study/assets/Mybatis.html.e030a0aa.js"><link rel="prefetch" href="/study/assets/springboot.html.782f47ca.js"><link rel="prefetch" href="/study/assets/springboot.html.b8f98aeb.js"><link rel="prefetch" href="/study/assets/springMVC.html.d1062f32.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.2238f403.js"><link rel="prefetch" href="/study/assets/操作系统.html.6b1464ac.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.fdcf4dcb.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.a4df7b0b.js"><link rel="prefetch" href="/study/assets/404.html.f4355e04.js"><link rel="prefetch" href="/study/assets/404.44f6e5c7.js"><link rel="prefetch" href="/study/assets/Layout.e98fdf55.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Spring <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#第一章-spring-概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="第一章：Spring 概念"><!--[--><!--]--> 第一章：Spring 概念 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#spring框架概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="Spring框架概述"><!--[--><!--]--> Spring框架概述 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#第二章-ioc控制反转" class="router-link-active router-link-exact-active sidebar-item" aria-label="第二章：IoC控制反转"><!--[--><!--]--> 第二章：IoC控制反转 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#spring通过ioc创建对象的实现步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="Spring通过IoC创建对象的实现步骤"><!--[--><!--]--> Spring通过IoC创建对象的实现步骤 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#总体步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="总体步骤"><!--[--><!--]--> 总体步骤 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#创建spring需要使用的配置文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="创建spring需要使用的配置文件"><!--[--><!--]--> 创建spring需要使用的配置文件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#通过ioc创建对象在java代码中的步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="通过IoC创建对象在Java代码中的步骤"><!--[--><!--]--> 通过IoC创建对象在Java代码中的步骤 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#基于xml的依赖注入-di" class="router-link-active router-link-exact-active sidebar-item" aria-label="基于XML的依赖注入（DI）"><!--[--><!--]--> 基于XML的依赖注入（DI） <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#概述-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#set注入" class="router-link-active router-link-exact-active sidebar-item" aria-label="set注入"><!--[--><!--]--> set注入 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#构造注入" class="router-link-active router-link-exact-active sidebar-item" aria-label="构造注入"><!--[--><!--]--> 构造注入 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#引用类型属性自动注入" class="router-link-active router-link-exact-active sidebar-item" aria-label="引用类型属性自动注入"><!--[--><!--]--> 引用类型属性自动注入 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#多个配置文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="多个配置文件"><!--[--><!--]--> 多个配置文件 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#基于注解的依赖注入-di" class="router-link-active router-link-exact-active sidebar-item" aria-label="基于注解的依赖注入（DI）"><!--[--><!--]--> 基于注解的依赖注入（DI） <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#概述-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#使用注解的步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="使用注解的步骤"><!--[--><!--]--> 使用注解的步骤 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#重要注解" class="router-link-active router-link-exact-active sidebar-item" aria-label="重要注解"><!--[--><!--]--> 重要注解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#指定多个包的三种方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="指定多个包的三种方式"><!--[--><!--]--> 指定多个包的三种方式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#ioc总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="IoC总结"><!--[--><!--]--> IoC总结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#第三章-aop面向切面编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="第三章：AOP面向切面编程"><!--[--><!--]--> 第三章：AOP面向切面编程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#动态代理" class="router-link-active router-link-exact-active sidebar-item" aria-label="动态代理"><!--[--><!--]--> 动态代理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#aop编程术语" class="router-link-active router-link-exact-active sidebar-item" aria-label="AOP编程术语"><!--[--><!--]--> AOP编程术语 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#aop的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="AOP的实现"><!--[--><!--]--> AOP的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#aspectj实现aop的步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="aspectj实现aop的步骤"><!--[--><!--]--> aspectj实现aop的步骤 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#aspectj基于注解的aop实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="AspectJ基于注解的AOP实现"><!--[--><!--]--> AspectJ基于注解的AOP实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#aspectj框架的几种注解和参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="aspectj框架的几种注解和参数"><!--[--><!--]--> aspectj框架的几种注解和参数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#第四章-spring集成mybatis" class="router-link-active router-link-exact-active sidebar-item" aria-label="第四章：Spring集成MyBatis"><!--[--><!--]--> 第四章：Spring集成MyBatis <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#概述-3" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#spring和mybatis集成步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="spring和mybatis集成步骤"><!--[--><!--]--> spring和mybatis集成步骤 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#spring的配置文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="spring的配置文件"><!--[--><!--]--> spring的配置文件 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#第五章-事务管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="第五章：事务管理"><!--[--><!--]--> 第五章：事务管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#概述-4" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#spring的事务处理实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="spring的事务处理实现"><!--[--><!--]--> spring的事务处理实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#spring框架中提供的事务处理方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="spring框架中提供的事务处理方案"><!--[--><!--]--> spring框架中提供的事务处理方案 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#_1-中小型项目-transactional-spring自己实现的aop" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 中小型项目 @Transactional---spring自己实现的aop"><!--[--><!--]--> 1. 中小型项目 @Transactional---spring自己实现的aop <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#_2-大型项目-aspectj实现aop-基于配置管理事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 大型项目---AspectJ实现AOP，基于配置管理事务"><!--[--><!--]--> 2. 大型项目---AspectJ实现AOP，基于配置管理事务 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/spring/spring.html#第六章-在web项目中使用容器对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="第六章：在web项目中使用容器对象"><!--[--><!--]--> 第六章：在web项目中使用容器对象 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> Spring</h1><h2 id="第一章-spring-概念" tabindex="-1"><a class="header-anchor" href="#第一章-spring-概念" aria-hidden="true">#</a> 第一章：Spring 概念</h2><h3 id="spring框架概述" tabindex="-1"><a class="header-anchor" href="#spring框架概述" aria-hidden="true">#</a> Spring框架概述</h3><ol><li><p>Spring是轻量级的开源的JavaEE框架</p><p>解决企业开发的难度，减轻对项目模块之间的管理，类和类之间的管理，交给Spring来处理，帮助开发人员创建对象，管理对象之间的关系</p></li><li><p>spring的目的就是<strong>解耦合</strong>，让关系变得松散。一个模块的变化对另一个模块影响最小！！</p></li><li><p>依赖：类A中使用类B的属性或方法，叫做A依赖于B。</p></li><li><p>框架就是半成品，需要结合框架，加上我们自己的代码，来完成开发。</p><p>框架提供了很多工具，现有的工具和功能，组件</p><p>我们在框架的基础之上进行开发，自己写的项目的功能，可利用框架中已有的功能</p><p>要用框架，那么需要进行jar包的导入，依赖的添加。而Spring框架需要我们添加的依赖很少，所以是轻量级的，同理，Mybatis也是轻量级的，因为添加的依赖很少，配置简单。</p><p>spring框架运行占用的资源少，运行效率高，不依赖其他jar，Spring核心功能的所需jar总共在3M左右</p></li><li><p>框架要完成一个功能，需要一定的步骤支持的。</p></li><li><p>Spring的目的是解决企业应用开发的复杂性。</p></li><li><p>Spring有很多组成部分，但是有两个核心组成部分</p><ul><li><p>IOC</p><p>控制反转，之前原始方式创建对象，需要new一个类，把对象创建，或者还有反射的new Instance，反射通过构造器创建。现在通过IOC，<strong>把创建对象的过程交给Spring进行管理</strong></p></li><li><p>AOP</p><p>面向切面（面向方面）,比如在程序中想加功能或者扩展功能，在不修改原代码的情况下，进行功能的增强。<strong>不改原代码</strong></p></li></ul></li><li><p>Spring框架的特点</p><ul><li><p>轻量级</p></li><li><p>方便解耦，简化开发，针对接口编程</p></li><li><p>AOP编程支持，不改变原代码的方式，进行功能的增强</p></li><li><p>方便程序的测试</p></li><li><p>方便集成各种优秀框架</p></li></ul></li><li><p>Spring的核心技术，ioc、aop实现模块之间、类之间的解耦合，所以aop才能支持在不改变原代码的方式进行功能增强。</p></li><li><p>SpringFramework内部模块</p><ul><li>数据访问模块</li><li>web应用模块</li><li>AOP模块</li><li>集成功能模块</li><li>IOC核心容易模块</li><li>测试模块</li></ul><p><img src="/study/assets/image-20210913172634214.099034b8.png" alt="image-20210913172634214"></p></li></ol><h2 id="第二章-ioc控制反转" tabindex="-1"><a class="header-anchor" href="#第二章-ioc控制反转" aria-hidden="true">#</a> 第二章：IoC控制反转</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><ol><li><p>IoC---Inversion of Control，控制反转，是一个概念，一个思想</p><p>指将传统上由程序代码直接操控的对象调用权交给代码之外的<strong>容器（这个容器在Java代码中需要被创建出来）</strong>，通过外部容器来实现对象的装配和管理。</p><p>控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。</p><p><strong>通过容器实现对象的创建，属性赋值，依赖的管理（对象之间的关系管理）</strong></p></li><li><p>IOC描述的：把对象的创建、属性赋值、管理工作都交给代码之外的容器实现。</p></li><li><p>spring容器中的对象默认都是单例的，在容器中叫这个名称的对象只有一个。</p></li><li><p>IoC是一种概念，一种思想，其实现方式多种多样，<strong>当前比较流行的实现方式是依赖注入</strong></p></li><li><p>依赖：</p><p>classA中含有classB的实例，在classA中调用classB的方法完成功能，即classA对classB有依赖。</p></li><li><p>控制反转</p><p>控制：创建对象，对象的属性赋值，对象之间的关系管理</p><p>反转：由代码实现控制，交给外部容器来实现控制</p><p>正转：由开发人员，在代码中，使用new构造方法创建对象，开发人员主动管理对象。</p><p>容器：<strong>是一个服务器软件，一个框架---spring</strong></p></li><li><p>IOC的<strong>实现</strong>：</p><p>依赖注入：DI，Dependency Injection，这些工作由容器自行完成</p><p>依赖注入是指程序运行过程中，若需要调用另一个对象协助时，无需在代码中创建被调用者，而是依赖于外部容器，<strong>由外部容器创建后传递给程序</strong>。</p><p>Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对象之间依赖关系的管理</p></li><li><p>为什么要使用ioc</p><p>目的是减少代码的改动，也能实现不同的功能，解耦合，让对象的管理更松散。</p></li><li><p>Java中创建对象有哪些方式</p><ul><li>new的常规方式</li><li>new的变形：XxxBuilder、XxxFactory的静态方法</li><li>反射，调用newInstance()</li><li>反射，调用无参的或带参的构造器</li><li>克隆，实现Cloneable接口，实现clone()方法</li><li>使用反序列化</li><li>动态代理</li><li><strong>IoC依赖注入，由容器创建对象，然后传递给程序</strong></li></ul><p><img src="/study/assets/image-20210820161439568.c766732a.png" alt="image-20210913175809348"></p><p>在此基础上，再加一种方式：</p><p><strong>IoC：外部容器创建对象！</strong></p><p>除了IoC，其他创建对象的方式都要在我们的程序中写代码来创建对象，但是IoC不需要，由外部容器创建对象，并且IoC是一个思想，有很大的功能，<strong>他不仅仅是创建对象，还可以管理对象之间的关系（管理依赖），属性赋值</strong></p></li><li><p>ioc的体现：</p><p>servlet：</p><ul><li><p>创建类继承HttpServlet</p></li><li><p>在web.xml注册servlet</p><p><img src="/study/assets/image-20210913180612194.86f6f78d.png" alt="image-20210913180612194"></p></li><li><p>但是没有创建过Servlet对象，没有<code>MyServlet myServlet = new MyServlet();</code></p></li><li><p>Servlet类的对象是Tomcat服务器创建的</p><p><strong>所以Tomcat也称为容器，里面存放的有Servlet对象，监听器对象，过滤器对象，这是Tomcat的三大组件，Servlet是核心组件</strong></p><p><strong>Tomcat作为容器，完成了对象的创建，我们只需要在web.xml文件中修改就可以了，不用在代码里创建对象，这就是IOC的体现。</strong></p></li></ul><p><strong>IOC是在程序的代码之外完成对象的创建的！！！</strong></p></li><li><p>IoC的技术实现</p><p>DI，即依赖注入，是IoC的技术实现</p><p>我们只需要在提供要使用的对象的名称就可以了，至于对象如何在容器中创建，给属性赋值，查找都由代码外部、容器内部实现。</p><p>Spring是使用了<strong>DI实现了IoC的功能</strong>，Spring底层创建对象，<strong>使用的是反射机制（根本）</strong></p></li><li><p>什么样的对象放入到容器中创建？</p><p>dao类，service类，controller类，工具类（可知这些都是功能性类，在框架中担任一定作用的类）</p><p><strong>spring容器中的对象默认都是单例的，在容器中叫这个名称的对象只有一个。</strong></p><p>一个&lt;bean&gt;标签对应于一个对象。</p></li><li><p>不放入到spring容器中的对象</p><ul><li><p>实体类的对象，因为<strong>实体类对象的属性数据是来自于数据库的</strong>，在数据库访问过程中或者说查询过程中便可以创建对象，比如由mybatis框架完成，对应于jdbc的这个操作</p><p><img src="/study/assets/image-20210912214209011.3bd39a1b.png" alt="image-20210914151017506"></p><p><strong>但是mybatis并不需要写以上这几行代码，只是对应于jdbc里是这样操作</strong>，所以我们不需要把实体类对象放到spring容器中，<strong>在查询过程中便会由mybatis来帮我们创建实体对象</strong></p></li><li><p>servlet、listener、filter等，这些对象交给tomcat来创建</p><p>所以面试的时候说到IOC，不只是出现在spring框架中，这是一种思想，可以说tomcat服务器也用到。而tomcat本身又是一个容器。</p></li></ul></li><li><p>对象怎么放入spring容器中创建，并且给对象的属性赋值，即完成依赖注入操作。</p><ul><li>xml配置文件方式 <ul><li>set注入 <ul><li>简单类型</li><li>引用类型</li></ul></li></ul></li><li>注解方式</li></ul></li><li><p>ioc能够实现业务对象之间的解耦合，例如service和dao对象之间的解耦合</p></li></ol><h3 id="spring通过ioc创建对象的实现步骤" tabindex="-1"><a class="header-anchor" href="#spring通过ioc创建对象的实现步骤" aria-hidden="true">#</a> Spring通过IoC创建对象的实现步骤</h3><h4 id="总体步骤" tabindex="-1"><a class="header-anchor" href="#总体步骤" aria-hidden="true">#</a> 总体步骤</h4><ol><li><p>创建maven项目</p></li><li><p>加入maven 依赖</p><p>spring的依赖，版本5.2.5</p><p>junit依赖，单元测试</p></li><li><p>创建类（可以有接口和实现类）（Spring中，实体类的对象的创建不交给容器（没有必要），而是mybatis创建，因为一个实体类是对应于数据库中一个表，一个实体类对象是对应于数据库中表的一行！！）</p><p>交给spring容器创建的对象是service类、dao类、controller类、工具类的对象！！</p><p>和没有使用框架一样，就是普通的类</p></li><li><p>创建spring需要使用的配置文件，把第三步创建的类的信息交给spring</p><p>声明类的信息，这些类的对象由spring创建和管理，使用&lt;bean&gt;</p></li><li><p>测试spring创建的对象。</p></li><li><p>注意：</p><ul><li><p>spring中，类不是不需要写，<strong>类是需要写的</strong>，只是类的创建交给spring容器（底层使用反射机制）</p><p>容器对象的创建是在读取配置文件的时候，读取完，那么容器对象创建好了，并且配置文件中声明的对象也创建好了</p></li><li><p>mybatis中，Dao接口的实现类不需要写，<strong>也就是不仅对象直接交给mybatis创建，连类也不需要写（底层是动态代理）。<strong>mybatis通过</strong>动态代理</strong>创建接口的实现类的对象。</p></li><li><p>在spring中，类得自己写（不要和之前mybatis的dao接口的实现类搞混淆，那个不需要写）！！并且要把类的信息交给容器（可以理解为配置文件。）把类的信息交给配置文件。在配置文件中声明类的信息。</p></li></ul></li></ol><h4 id="创建spring需要使用的配置文件" tabindex="-1"><a class="header-anchor" href="#创建spring需要使用的配置文件" aria-hidden="true">#</a> 创建spring需要使用的配置文件</h4><div class="language-xml ext-xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--
        告诉spring创建对象
        声明bean，就是告诉spring要创建某个类的对象
        id:对象的自定义名称，唯一值，spring通过这个名称来找到对象
        class：类的全限定名称（不能是接口，因为spring是反射机制创建对象，必须使用类）
        写了下面这行之后，spring就会在内部完成对象的创建，底层使用反射机制，实现对象的依赖注入
        相当于spring就完成SomeService someService = new SomeServiceImpl();
        对象创建完了，需要保存起来，spring把创建好的对象放入到map中，spring框架有一个map存放对象
        springMap.put(id的值，对象)
        即 springMap.put(&quot;someService&quot;, new SomeServiceImpl())
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>someService<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.impl.SomeServiceImpl<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!--
    spring的配置文件
    1. beans：是根标签，spring把Java对象称为bean
    2.spring-beans.xsd 是约束文件，和mybatis中的 .dtd是一样的，用来控制和限制在这个文件中可以出现的标签和属性
--&gt;</span>
</code></pre></div><p>一个bean标签声明一个对象</p><p>并且要注意依赖注入的底层原理使用的是反射</p><p><strong>创建的对象要保存起来，保存在Map对象里。</strong></p><h4 id="通过ioc创建对象在java代码中的步骤" tabindex="-1"><a class="header-anchor" href="#通过ioc创建对象在java代码中的步骤" aria-hidden="true">#</a> 通过IoC创建对象在Java代码中的步骤</h4><ol><li><div class="language-java ext-java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDoSome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//1. 指定spring配置文件的名称</span>
        <span class="token class-name">String</span> config <span class="token operator">=</span> <span class="token string">&quot;beans.xml&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">//2 创建表示spring容器的对象，ApplicationContext,</span>
        <span class="token comment">// ApplicationContext就表示spring容器对象，通过容器对象，就能获取对象了</span>
        <span class="token comment">// ClassPathXmlApplicationContext 表示从类路径中加载spring的配置文件</span>
        <span class="token comment">// 类路径是target/classes/之后的路径，而项目目录resources下的配置文件本来就在类路径的根路		     径下。</span>
        <span class="token comment">// 执行完下面这行代码，就把对象创建好了</span>
        <span class="token comment">// 读取完配置文件的同时，对象就已经创建好了</span>
        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3. 从容器中获取某个对象，要调用applicationContext对象的方法</span>
        <span class="token comment">// 这一行代码只是拿到对象</span>
        <span class="token class-name">SomeService</span> someService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SomeService</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;someService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//4. 使用IoC创建好的对象，</span>
        someService<span class="token punctuation">.</span><span class="token function">doSome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><img src="/study/assets/image-20211231213322621.361e0b9d.png" alt="image-20211231213322621"></p></li><li><p><strong>spring默认创建对象的时间是：在创建spring的容器ApplicationContext时，会创建配置文件中所有的对象，也就是说，对象在读取配置文件完成的时候就创建好了。（构造方法也会在此时调用，无参构造方法还是有参构造方法，看bean标签里是怎么配置的，是配置的&lt;property&gt;还是&lt;construtor-arg&gt;）</strong></p></li><li><p>spring能创建一个<strong>非自定义类</strong>的对象。</p><p><img src="/study/assets/image-20210913205505062.8b5e7731.png" alt="image-20210913205505062"></p></li><li><p>spring创建对象，默认调用的是无参的构造方法。</p></li></ol><h3 id="基于xml的依赖注入-di" tabindex="-1"><a class="header-anchor" href="#基于xml的依赖注入-di" aria-hidden="true">#</a> 基于XML的依赖注入（DI）</h3><h4 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h4><ol><li><p><strong>在spring的配置文件中，给Java对象的属性赋值</strong></p></li><li><p>依赖注入（DI）表示</p><ul><li><strong>创建对象</strong></li><li><strong>给对象的属性赋值</strong></li></ul></li><li><p>依赖注入（DI）的实现语法有两种</p><ul><li><p>第一种方式：在spring的配置文件中，使用标签和属性完成，叫做<strong>基于XML的依赖注入实现</strong></p><ul><li><p><strong>set注入（设值注入）</strong>：spring容器调用类的set方法，在set方法可以实现属性的赋值</p><p>使用很广泛，80%左右都是使用的set注入</p><ul><li>简单类型的set注入</li><li>引用类型的set注入</li></ul></li><li><p><strong>构造注入</strong>，spring调用类的<strong>有参数构造方法</strong>（spring容器默认调的是无参构造方法），创建对象，在构造方法中完成赋值</p></li></ul></li><li><p>第二种方式：使用spring的注解来完成对象的属性赋值，这叫基于注解的DI实现</p></li></ul></li></ol><h4 id="set注入" tabindex="-1"><a class="header-anchor" href="#set注入" aria-hidden="true">#</a> set注入</h4><h5 id="_1-简单类型的set注入" tabindex="-1"><a class="header-anchor" href="#_1-简单类型的set注入" aria-hidden="true">#</a> 1. 简单类型的set注入</h5><ol><li><div class="language-xml ext-xml"><pre class="language-xml"><code> <span class="token comment">&lt;!--
        声明student对象
        注入：就是赋值的意思
        简单类型；spring中规定Java的基本数据类型和String都是简单类型（和mybatis一样）
        di：给属性赋值
        1. set注入 ==》 spring调用类的set方法，你可以在set方法中完成属性赋值
            1） 简单类型的set注入
            &lt;bean id=&quot;xx&quot; class=&quot;yyy&quot;&gt;
                &lt;property name=&quot;属性名字&quot; value=&quot;此属性的值&quot;&gt;  ==》一个property只能给一个属性赋值
            &lt;/bean&gt;
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myStudent<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.spring01.Student<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>李四<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>age<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>20<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>像这种方式注入，都是spring容器通过调用类的set方法，实现属性的赋值的。</p><p>要注意，spring容器，我们之前创建出来，创建好容器之后，类的对象就已经创建好了，因为创建spring容器的时候，会读取配置文件，配置文件读取完成，就创建好了对象。</p><p><strong>ApplicationContext就表示spring容器，通过容器对象，就能获取对象了</strong></p></li><li><p><strong>在配置文件中通过set注入，要求类必须有属性的setter方法，没有的话，会报错。</strong></p><p><strong>spring通过set注入，调用类的set方法，是在构造方法之后执行的，spring容器创建对象，默认调用类的无参构造方法。</strong></p><p><strong>先调用无参构造器创建对象，再调用set方法。</strong></p></li><li><p>set注入是说spring调用类的set方法，只要在配置文件里写了对应的property，那么就去类里调用setXxx方法，只要有这个方法， 程序就会顺利执行，不会报错，即使这个类只是有这样一个set方法，根本没有属性。</p><p>set注入，spring只看set方法，别的都不用管。</p></li><li><p>创建Junit测试方法</p><ul><li>public方法</li><li>没有返回值</li><li>方法名称自定义，建议名称是test+要测试的方法名称</li><li>方法没有参数</li></ul></li></ol><h5 id="_2-引用类型的set注入" tabindex="-1"><a class="header-anchor" href="#_2-引用类型的set注入" aria-hidden="true">#</a> 2. 引用类型的set注入</h5><ol><li><p><img src="/study/assets/image-20210914141532997.787552e5.png" alt="image-20210914141532997"></p><p>需要用到bean的id，显然还要对这个引用类型，在xml文件中创建一个bean，并且也要给这个引用类型的属性通过property标签赋上值</p><p><img src="/study/assets/image-20210914141854791.a2ba4f0d.png" alt="image-20210914141854791"></p></li><li><p><strong>对于spring来说，Java的八种基本数据类型和String类型被认为是简单类型。</strong></p></li></ol><h5 id="_3-set注入的注意事项" tabindex="-1"><a class="header-anchor" href="#_3-set注入的注意事项" aria-hidden="true">#</a> 3.set注入的注意事项</h5><ul><li><p><strong>用set注入，那么spring就是通过调用类的set方法给对象赋值，那么类里面必须要写set方法，不然会报错</strong></p><p><strong>spring只是执行set方法，set方法体内的内容是由我们自己决定的，包括赋不赋值，都是我们自己决定，因为spring容器只是负责调用set方法。</strong></p><p><strong>set方法是在构造方法之后执行的。</strong></p></li><li><p><img src="/study/assets/image-20210914135813503.3286f3a6.png" alt="image-20210914135813503"></p><p><strong>spring容器找的是属性的值所对应的set方法，而不是找的类里面的属性，即使类里面根本没有写email这个属性，写了setEmail方法那么也是能够顺利执行的，spring容器只是根据property标签的内容找到类里面对应的set方法执行。</strong></p><p><strong>set方法写了就不会报错，没有就会报错，spring容器不会去看是否有对应的属性。</strong></p></li><li><p><strong>不管类里面属性是什么类型的变量，在xml文件中定义property的时候，name属性和value属性的值都必须加上引号，这个是xml文件的规则。</strong></p></li></ul><h4 id="构造注入" tabindex="-1"><a class="header-anchor" href="#构造注入" aria-hidden="true">#</a> 构造注入</h4><ol><li><p>构造注入是指在创建类的实例化对象的同时，完成对象的属性的赋值，通过调用类的<strong>有参数构造方法</strong>，完成对象的实例化。即使用构造器设置依赖关系。</p><p>构造注入：spring调用类的有参构造方法，在创建对象的同时，在构造方法中给属性赋值</p><p><strong>不过要注意spring默认创建对象，用的是无参构造器。</strong></p><p>IoC底层创建对象是通过反射机制来创建对象，默认使用类的无参构造器。</p></li><li><p>构造注入使用&lt;constructor-arg&gt;</p><p>&lt;constructor-arg&gt;标签：一个&lt;constructor-arg&gt;表示构造方法的一个参数</p><p>&lt;constructor-arg&gt;标签属性：</p><ul><li><p>name：表示构造方法的形参名</p></li><li><p>index：表示构造方法的参数的位置，参数从左往右是0，1，2的顺序</p><p>index也可以省略，如果省略，那么在xml文件里，就要按构造函数参数写。</p></li><li><p>value：<strong>构造方法的形参类型是简单类型的，使用value</strong></p></li><li><p>ref：<strong>构造方法的形参是引用类型的，使用ref</strong></p></li></ul><p>示例：</p><div class="language-xml ext-xml"><pre class="language-xml"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myStudent<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.spring01.Student<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>李四<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>age<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>20<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>在spring配置文件中写bean标签创建对象，不用关心顺序。</p></li><li><p>构造方法什么时候被spring调用呢？</p><p>创建spring容器的时候，因为<strong>创建spring容器ApplicationContext</strong>的时候，便会读取xml配置文件，读取完毕，便会默认调用类的无参构造方法创建对象，文件读取完毕，对象也就创建好了，所以对象的创建是在创建spring容器的同时进行的，而类的构造方法的调用，是在创建对象的时候调用的</p><p>所以创建spring容器，创建类的对象，类的构造方法的调用是同时进行的。</p></li><li><p>解耦合是什么意思呢？</p><p>比如说</p><p><code>UserDao userDao = new UserDaoImpl();</code></p><p>这样就是没有通过spring容器来创建对象，赋值符号的左边和右边是紧密联系在一起的，左边是变量名（对象引用），右边是实例化的对象</p><p>如果在某一刻，想将userDao这个对象引用指向另一个实例化对象，那么就需要在代码中来修改，这就是紧密联系的，很不方便。</p><p>如果采用spring容器的方式来创建实例化对象，代码会这么写：</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserDao</span><span class="token punctuation">(</span><span class="token class-name">UserDao</span> userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过set注入的方式来实现依赖注入，并且是引用类型注入，那么只需要在配置文件中修改ref属性的值。</p><p><img src="/study/assets/image-20210914155725037.c25e6599.png" alt="image-20210914155725037"></p></li></ol><h4 id="引用类型属性自动注入" tabindex="-1"><a class="header-anchor" href="#引用类型属性自动注入" aria-hidden="true">#</a> 引用类型属性自动注入</h4><ol><li><p><strong>spring框架根据某些规则可以自动给引用类型赋值（只能对引用类型有效。简单类型不可以）</strong></p></li><li><ul><li><p>byName---引用类型变量<strong>属性名</strong>和bean标签的<strong>id属性</strong>比</p><p>按名称注入，Java类中引用类型变量的属性名（变量名）和spring容器中（配置文件）&lt;bean&gt;的id名称一样，且数据类型是一致的，这样的容器中的bean，spring能够赋值给引用类型变量。</p></li></ul><p><img src="/study/assets/image-20210914161402217.9eb201ce.png" alt="image-20210914161402217"></p><ul><li><p>byType---引用类型<strong>变量的类型</strong>和bean标签的<strong>class属性</strong>比</p><p>按类型注入，Java类中引用类型变量的数据类型和spring容器中（配置文件）&lt;bean&gt;的class属性是同源关系的， <strong>这样的bean能够赋值给引用类型变量。</strong></p><p>同源就是一类的意思</p><ul><li>Java类中引用类型变量的数据类型和class的值是一样的。</li><li>Java类中引用类型变量的数据类型和class的值是父子类关系的。</li><li>Java类中引用类型变量的数据类型和class的值是接口和实现类关系的。</li></ul><p><img src="/study/assets/image-20210914161928143.130b737e.png" alt="image-20210914161928143"></p></li></ul></li><li><p>注意：</p><ul><li><p>采用引用数据类型变量自动注入，使用byType，在xml配置文件中声明bean只能有一个符合条件的，要保证匹配上的实例化对象只有1个。</p><p><img src="/study/assets/image-20220101163100726.6e91a800.png" alt="image-20220101163100726"></p><p>这就能匹配上两种，就有问题。</p></li><li><p>byName检查的是bean标签的id</p></li><li><p>byType检查的是bean标签的class</p></li></ul></li></ol><h4 id="多个配置文件" tabindex="-1"><a class="header-anchor" href="#多个配置文件" aria-hidden="true">#</a> 多个配置文件</h4><ol><li><p>多个配置文件优势</p><ul><li>每个文件的大小比一个文件要小很多，效率高</li><li>避免多人修改配置文件带来的冲突</li><li>如果项目中有多个模块（一个模块代表相关的功能在一起），那么一个模块一个配置文件</li></ul></li><li><p><img src="/study/assets/image-20210914164717403.62335ee7.png" alt="image-20210914164717403"></p><p>spring-total.xml是主配置文件，主配置文件，一般是不定义对象的，即不定义bean标签，主配置文件是包含其他配置文件的。</p><p>语法：<code>&lt;import resource=&quot;其他配置文件的路径&quot;&gt;</code></p><p>关键字：<code>classpath:&quot;&quot;</code>表示类路径（class文件所在的目录即target/classes），在spring文件中要指定其他文件的位置，那么就要只用classpath，告诉spring去哪里加载其他文件。</p><p><img src="/study/assets/image-20210914165054779.e8bfc54d.png" alt="image-20210914165054779"></p><p>这种叫包含关系的配置文件</p><p><img src="/study/assets/image-20210914165406757.fd681be7.png" alt="image-20210914165406757"></p><p>在使用通配符这种方式时，主配置文件名称不能包含在通配符的范围内。</p><p><strong>并且如果要使用通配符这种方案，那么配置文件必须放在一个目录下。</strong></p></li></ol><h3 id="基于注解的依赖注入-di" tabindex="-1"><a class="header-anchor" href="#基于注解的依赖注入-di" aria-hidden="true">#</a> 基于注解的依赖注入（DI）</h3><h4 id="概述-2" tabindex="-1"><a class="header-anchor" href="#概述-2" aria-hidden="true">#</a> 概述</h4><ol><li><p>通过注解来完成Java对象创建和属性赋值</p><p>创建的对象仍然是单例的，放在spring容器中。底层是放在spring框架的map中，ConcurrentHashMap</p></li><li><p>做项目以注解实现依赖注入的方式为主。</p></li><li><p>注解点进去，注解本身是一个类文件，@interface代表注解</p><p><img src="/study/assets/image-20220101164217927.cbcad780.png" alt="image-20220101164217927"></p></li><li><p>注意：对象的创建仍然发生在spring容器ApplicationContext创建的同时，配置文件读取完，对象也创建好。</p></li><li><div class="language-java ext-java"><pre class="language-java"><code><span class="token class-name">String</span> config <span class="token operator">=</span> <span class="token string">&quot;applicationContext.xml&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//这一步执行完之后，对象就创建好了，对象仍然是随着容器的创建而创建，因为容器的创建，会读取配置文件，</span>
<span class="token comment">// 配置文件里又指定了组件扫描器，指定应该去哪个包下面读取注解</span>
<span class="token comment">// 仍然是下面这行代码执行完成，容器就创建完成，对象就通过spring默认调用无参构造器的方式创建完成。</span>
<span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol><h4 id="使用注解的步骤" tabindex="-1"><a class="header-anchor" href="#使用注解的步骤" aria-hidden="true">#</a> 使用注解的步骤</h4><ol><li><p>加入maven依赖spring-context，</p><p><strong>在加入spring-context的同时，会间接加入spring-aop依赖</strong></p><p><strong>要想使用注解，必须有spring-aop依赖</strong></p><p><img src="/study/assets/image-20210914170534218.bf134c09.png" alt="image-20210914170534218"></p></li><li><p><strong>创建类</strong>，在类中加入spring的注解（多个不同功能的注解）</p><p>在实际开发中，实体类的对象可能不会交给spring来创建，而是mybatis在查询数据库的过程中创建，因为一个实体类对应于一个数据库，一个实体类的对象对应于数据表中的一行数据。</p><p>在实际开发中，交给spring容器创建的类是dao类、service类、controller类、工具类等。</p><p>这些类都要写，只是对象交给spring容器创建并给属性赋值，使用的DI，底层是反射机制。</p><p>而mybatis中<strong>dao接口的实现类不用写</strong>，而且实现类的对象的创建交给mybatis，底层使用的是动态代理。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;myStudent&quot;</span><span class="token punctuation">)</span>
</code></pre></div></li><li><p><strong>在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置。</strong></p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!--
        声明组件扫描器,组件就是Java对象
        base-package:指定注解在项目中的包名
        component-scan工作方式：spring会扫描遍历base-package指定的包，扫描包中和子包中的所有类，
        找到类中的注解，按照注解的功能创建对象，或给属性赋值。
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.domain<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div></li><li><p>注意：</p><ul><li><p>使用注解创建对象，创建spring容器ApplicationContext</p><p>仍然要写配置文件，只是不在配置文件里写bean标签，<strong>写的是组件扫描器，扫描注解！！</strong></p></li><li><p>使用注解创建对象，并使用注解给对象的属性赋值，即依赖注入，不会调用类的set方法！！！</p><p>类的set方法不写都可以。</p></li><li><p>使用注解的方式，通过spring容器创建对象，仍然是调用类的无参构造方法创建的。</p><p>之前通过xml配置文件的方式注入，其中set注入，是调用类的无参构造方法创建对象（因为给属性赋值是通过set方法），而构造注入，则是调用类的有参数构造方法创建对象（因为给属性赋值，直接通过有参构造方法就可以赋值了）。</p></li></ul></li></ol><h4 id="重要注解" tabindex="-1"><a class="header-anchor" href="#重要注解" aria-hidden="true">#</a> 重要注解</h4><ol><li><p>@Componet</p><ol><li><p>创建对象的，等同于&lt;bean&gt;标签的功能</p></li><li><p>属性：value ，value的值就是对象的名称，也就是&lt;bean&gt;标签的id属性的值</p><p>value的值是唯一的，创建的对象在整个spring容器中就一个。<strong>（通过spring容器创建对象，创建的对象都是单例的。）</strong></p><p>位置：在类的上面，这个对象创建完之后是放在容器中的。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;myStudent&quot;</span><span class="token punctuation">)</span>等同于<span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">&quot;myStudent&quot;</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;org.example.domain.Student&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token comment">// value 也可以省略</span>
<span class="token comment">// @Component(&quot;myStudent&quot;)</span>
</code></pre></div><p>也可以不指定对象名称，由spring提供默认名称，类名首字母改为小写，作为对象名。</p></li><li><p>spring容器ApplicationContext的getBean方法，进入方法内部，底层是从一个Map中取得对象，也就是说Spring造好容器后，会把对象也造好，<strong>并把对象放入一个Map中，这个Map的实例化对象是采用的concurrentHashMap（性能好，又线程安全）来实现</strong>。（分段锁segment是ReentrantLock的子类。）</p></li></ol></li><li><p>@Repository</p><p>用在持久层的，放在dao接口的<strong>实现类</strong>上面，<strong>表示创建dao对象</strong>，dao对象是访问数据库的</p></li><li><p>@Service</p><p>用在业务层的，放在service接口的<strong>实现类</strong>上面，<strong>创建service对象</strong>，service对象是做业务处理的，可以有事务等功能的。</p></li><li><p>@Controller</p><p>用在控制器上的，放在Controller<strong>类</strong>的上面，创建Controller对象，Controller对象能够接收用户提交的参数，调用service对象的方法进行业务逻辑的处理，返回请求的处理结果。----这就是servlet组件的功能</p><blockquote><p><strong>@Repository @Service @Controller和@Component的用法一样，都能创建对象，但是这三个注解还有额外的功能，能够给对应的类赋予对应的角色，这三个注解能够给项目的类和对象分层。</strong></p></blockquote></li></ol><blockquote><p><strong>@Repository对应于持久层 @Service对应于业务层 @Controller对应于控制层，对不同的类有额外的角色声明。</strong></p></blockquote><p>那什么时候用@Component呢？当这个类不是三层任何一层时，或者说不确定它是哪一层时，就用@Component</p><hr><ol start="5"><li><p>@Value</p><p><strong>这个注解是给简单类型的属性赋值的。</strong></p><div class="language-java ext-java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;myStudent&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * @Value 简单类型的属性赋值
     * 属性：value 是String类型的，表示简单类型的属性值
     * 位置：1.在属性定义的上面，无需set方法，推荐使用，用的是反射，不需要set方法就能赋值了。
     *        private的属性，也能通过反射赋值，设置setAccessible能够访问到private声明的属性.
     *        之前用set注入，底层也是通过反射，IOC通过DI实现，底层是反射，set注入，就是通过反射调用
     *        类的set方法，但并不是说反射就一定要调用set方法，这里通过注解写在属性上面给属性赋值，同      *        样底层是通过反射机制，但是就没有调用set。
     *      2. 在set方法的上面，就是通过反射调用set方法，给属性赋值
     */</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;富富&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;18&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
</code></pre></div><p>@Value注解也可以放在set方法上，此时就会调用类的set方法来给属性赋值，底层仍然是反射机制。并不是说@Value注解就不能放在set方法上了。但是直接写在属性的上面，是最常用的。</p></li><li><p>@Autowired----spring框架提供的注解。</p><p><strong>这个注解给引用类型的属性赋值。</strong></p><p><strong>前提是扫描器扫描的包下面能够找到同源关系的类</strong></p><div class="language-java ext-java"><pre class="language-java"><code>	<span class="token doc-comment comment">/**
     * @Autowired: spring框架提供的注解，给引用类型的对象引用（变量）赋值，
     * 使用的是自动注入原理。支持byName，byType。Autowired默认使用的是byType自动注入
     *  位置：1.写在属性定义的上面，无需set方法，推荐使用，用的是反射，不需要set方法就能赋值了。
     *       2.写在set方法的上面，就是通过反射调用set方法赋值
     */</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">School</span> school<span class="token punctuation">;</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code> <span class="token doc-comment comment">/**
     * @Autowired: spring框架提供的注解，给引用类型的对象引用（变量）赋值，
     * 使用的是自动注入原理。支持byName，byType。Autowired默认使用的是byType自动注入
     *  位置：1.写在属性定义的上面，无需set方法，推荐使用，用的是反射，不需要set方法就能赋值了。
     *       2. 写在set方法的上面，就是通过反射调用set方法赋值
     *
     *  如果要使用byName方式，需要做的是：
     *  1. 在属性上面加入@Autowired
     *  2. 在属性上面加入@Qualifier(value=&quot;bean的id&quot;) 表示使用指定名称的bean完成赋值
     */</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;mySchool&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">School</span> school<span class="token punctuation">;</span>
</code></pre></div><p>@Autowired注解有一个属性：</p><p>required：是一个boolean类型的，默认true，表示引用类型赋值失败，程序报错，并终止执行。</p><p>若为false，引用类型如果赋值失败，程序正常执行，引用类型变量的值是null</p></li><li><p>@Resource-----JDK提供的注解。</p><p>是jdk的注解，完成的功能和@Autowired一样，而@Autowired是spring的注解</p><p>也是支持byName和byType</p><p>只不过默认是byName，而@Autowired默认是byType</p><p><strong>@Resource先使用byName自动注入， 如果byName给引用类型变量赋值失败，再使用byType</strong></p><div class="language-java ext-java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 引用类型
     * @Resource：来自jdk中的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值
     * 使用的也是自动注入原理，支持byName，byType，默认使用byName
     * 位置：1.在属性定义的上面，无需set方法，推荐使用
     *      2.在set方法上面
     *      两种方法底层都是反射机制。
     */</span>
</code></pre></div></li><li><p>使用注解就是用更少的代码，做更多的工作，更方便，可读性好，使用注解是一种趋势。</p></li></ol><h4 id="指定多个包的三种方式" tabindex="-1"><a class="header-anchor" href="#指定多个包的三种方式" aria-hidden="true">#</a> 指定多个包的三种方式</h4><p><img src="/study/assets/image-20210914185104374.b1e72428.png" alt="image-20210914185104374"></p><h3 id="ioc总结" tabindex="-1"><a class="header-anchor" href="#ioc总结" aria-hidden="true">#</a> IoC总结</h3><ol><li><p>这是理论、思想、概念：指导开发人员在容器中，代码之外管理对象，给对象属性赋值，管理依赖</p></li><li><p>ioc技术实现使用的DI（依赖注入）：开发人员在项目中只需要提供对象的名称，对象的创建、查找、赋值都交给容器内部实现</p></li><li><p>spring使用di的技术，底层是使用的反射机制</p><p>为什么使用反射机制？</p><p>通过容器调用类的set方法，调用类的无参构造方法，构造注入调用类的有参构造方法，这就是反射</p></li><li><p>di给属性赋值</p><ul><li>set注入 <ul><li>简单类型 - name 、value</li><li>引用类型 - name、 ref</li></ul></li><li>构造注入 <ul><li>&lt;constructor-arg&gt;:name</li><li>&lt;constructor-arg&gt;:index</li></ul></li></ul></li></ol><h2 id="第三章-aop面向切面编程" tabindex="-1"><a class="header-anchor" href="#第三章-aop面向切面编程" aria-hidden="true">#</a> 第三章：AOP面向切面编程</h2><h3 id="动态代理" tabindex="-1"><a class="header-anchor" href="#动态代理" aria-hidden="true">#</a> 动态代理</h3><ol><li><p>动态代理能创建对象，目标对象的代理对象只是由代理生成工具（不是真实定义的类）在程序运行时由JVM根据反射等机制<strong>动态生成</strong>的。<strong>代理对象与目标对象的代理关系在程序运行时才确定。</strong></p></li><li><p><strong>jdk的动态代理要求目标对象必须实现接口，如果没有实现接口，用的CGLIB动态代理（是第三方开源工具库）</strong></p></li><li><p><strong>动态代理可以实现在不修改原有的代码的前提下，额外的增加功能</strong></p></li><li><p>动态代理：</p><p>可以在程序的执行过程中，创建代理对象，目标对象是被代理对象</p><p><strong>通过代理对象执行方法</strong>，给目标类的方法增加额外的功能（功能增强）</p></li><li><p>jdk动态代理实现步骤：</p><ol><li>创建目标类，SomeServiceImpl目标类（目标类的对象就是被代理对象），给它的doSome，doOther增加输出时间、事务</li><li>创建InvocationHandler接口的实现类MyInvocationHandler，<strong>在这个类实现给目标方法增加功能</strong></li><li>使用jdk中类Proxy，创建代理对象，通过代理对象执行方法，显然Proxy要用到InvocationHandler接口的实现类里面。 <ul><li>创建目标对象</li><li>创建InvocationHandler接口的实现类的对象</li><li>创建代理对象---通过<code>Proxy.newProxyInstance</code></li><li>通过代理对象，执行方法。那么这一步的执行方法，会调用MyInvocationHandler的invoke方法</li></ul></li></ol><p>代码实现：</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
    <span class="token comment">// 目标对象</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通过代理对象执行被代理对象的方法时，会调用执行这个invoke()</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;执行MyInvocationHandler的invoke()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> res <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">ServiceTools</span><span class="token punctuation">.</span><span class="token function">doLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//执行目标类（被代理对象）的方法，通过method.invoke来实现。</span>
        <span class="token comment">// SomeServiceImpl.doSome()/SomeServiceImpl.doOther()</span>
        <span class="token comment">// 这个method是什么方法，就看代理对象调用的被代理类的哪个方法！！！</span>
        res <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ServiceTools</span><span class="token punctuation">.</span><span class="token function">doTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 目标方法的执行结果</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java ext-java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用jdk的proxy创建代理对象</span>
        <span class="token comment">// 创建目标对象---被代理对象</span>
        <span class="token class-name">SomeService</span> someService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建InvocationHandler对象</span>
        <span class="token class-name">InvocationHandler</span> invocationHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span>someService<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用Proxy创建代理对象</span>
        <span class="token class-name">SomeService</span> proxyInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SomeService</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>someService<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                    someService<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                    invocationHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过proxyInstance这个代理对象执行被代理对象的方法，会调用MyInvocationHandler中的invoke()</span>
     	<span class="token comment">//代理对象调用的被代理类的doSome()方法，那么MyInvocationHandler中的invoke方法参数method就是doSome()</span>
        proxyInstance<span class="token punctuation">.</span><span class="token function">doSome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre></div><p>使用了动态代理，doSome()、doOther()这两个方法的方法体里就只需要专注业务逻辑</p></li><li><p>通过动态代理控制哪些方法去加额外的功能，哪些功能不加。</p></li><li><p>AOP底层，就是采用动态代理实现的，可以采用以下两种实现方式：</p><ul><li><p>jdk动态代理，使用jdk中的Proxy，调用newProxyInstance()方法创建代理对象，通过编写InvocationHandler的实现类来实现，重写invoke方法</p><p>jdk动态代理要求<strong>目标类即被代理类</strong>必须实现接口</p></li><li><p>cglib动态代理：第三方的工具库，创建代理对象，原理是继承，<strong>通过继承目标类，创建子类。</strong></p><p><strong>子类就是代理对象</strong>，要求目标类（目标类就是被代理类，或者说是被代理对象）不能是final的，方法也不能是final的</p><p>因为需要重写方法，需要通过继承目标类来创建子类，目标类不能是final的是为了继承，方法不能是final的是为了可以重写。（static或final或private修饰的方法都是不可以重写的。）</p></li></ul></li><li><p><strong>动态代理的作用：（AOP的作用）</strong></p><ul><li>在目标类原代码不改变的情况下，增加目标类的方法的非业务代码的功能</li><li>减少重复代码</li><li>专注业务逻辑的开发。</li><li>解耦合---使<strong>业务逻辑各部分之间</strong>的耦合度降低，让业务功能和日志、事物等非业务功能分离</li></ul></li><li><p>AOP：面向切面编程，基于动态代理的，可以使用jdk、cglib两种代理方式</p><p><strong>AOP就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了，让开发人员用一种统一的方式，使用动态代理。</strong></p><p>ioc的原理是依赖注入，底层是spring通过反射的方式实现。</p></li><li><p>IOC是使对象之间解耦合，AOP是使业务方法内部的各部分之间解耦合，将业务逻辑和非业务逻辑解耦合。</p></li></ol><h3 id="aop编程术语" tabindex="-1"><a class="header-anchor" href="#aop编程术语" aria-hidden="true">#</a> AOP编程术语</h3><ol><li><p>AOP概念：</p><p>面向切面编程，可通过运行期动态代理实现程序功能的统一维护的一种技术，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></li><li><p>切面---Aspect</p><p>切面泛指交叉业务逻辑，上例中的事务处理，日志处理就可以理解为切面，常用的切面就是通知，实际是对主业务逻辑的一种增强。</p><p>切面就是我们<strong>增加的功能或者事务代码</strong>，就叫做切面。</p><p>一般是非业务的功能，常见的有<strong>日志、事务、统计信息、参数检查、权限验证</strong></p><p>切面的特点：一般都是非业务方法， 可以独立使用。所以单独拿出去，通过动态代理实现，实现业务代码与非业务代码的解耦合！！</p><p>aop的底层实现就是动态代理</p><p>ioc的底层实现是反射</p></li><li><p>连接点--JoinPoint:</p><p>连接点指可以被切面织入的具体方法，**通常业务接口中的方法均为连接点。**就是某个类中的业务方法。比如上例中的doSome()和doOther()，连接点就是业务方法</p><p>连接点一般指一个方法</p></li><li><p>切入点----PointCut：</p><p>切入点指声明的一个或多个连接点的集合，通过切入点指定一组<strong>业务方法</strong></p><p>被标记为final的方法是不能作为连接点和切入点的，因为最终的是不能被修改的，不能被增强的。</p></li><li><p>目标对象：我们要给哪个类的方法增加功能，这个类就是目标对象。</p></li><li><p>通知--Advice</p><p>表示切面功能执行的时间，在业务方法前还是后</p></li><li><p>动态代理很灵活，aop就是把动态代理规范化，让动态代理更好写。</p><p>AOP底层就是采用动态代理实现的，采用了两种动态代理：</p><ul><li>jdk的动态代理</li><li>CGLIB的动态代理</li></ul><p>AOP是面向切面编程，可通过<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术。</p><p>AOP是spring框架的一个重要内容，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p></li><li><p>IOC也可以减低耦合度，降低的是类与类之间或者说对象与对象之间的耦合度，通过依赖注入的方式来实现，依赖注入就是生成对象并且给对象的属性赋值，把对象的创建和给对象的属性赋值这一些操作交给容器来管理，来实现对象与对象，类与对象之间的解耦合，比如类A里用到了类B，需要我们声明类B的实例化对象并且赋值，调用方法， 这就是依赖。依赖注入有set注入、构造注入、还有引用类型自动注入，set注入有简单类型注入、引用类型注入，还可以通过注解实现依赖注入，基于XML配置文件实现依赖注入的话，80%都是set注入，<strong>而通过注解实现依赖注入，底层是通过反射的机制来给对象的属性赋值，即使是private声明的属性，也能够通过反射访问到，没有用到set方法，把类里面的set方法注释掉也可以。</strong>（set注入和构造注入也是用到反射机制，也就是说IOC底层就是反射机制，set注入、构造注入、基于注解的注入都是反射机制）</p></li><li><p>总结：AOP--使业务逻辑各部分之间的耦合度降低</p><p>ioc----能够实现业务对象之间的解耦合，例如service和dao对象之间的解耦合</p></li><li><p>怎么理解面向切面编程？</p><ul><li>需要在分析项目功能时，找出切面</li><li><strong>合理地安排切面的执行时间，在目标方法前还是目标方法后</strong></li><li>合理地安排切面执行的位置，在哪个类，哪个方法里去增加功能（切面）</li></ul></li><li><p>说一个切面有三个关键的要素</p><ul><li>切面的功能代码，一般是非业务功能代码</li><li>切面的执行位置--pointCut---一组业务方法的集合，指明在哪些业务方法里要加切面，要做功能的增强。</li><li><strong>切面的执行时间---advice，在业务方法前还是业务方法后</strong></li></ul></li></ol><h3 id="aop的实现" tabindex="-1"><a class="header-anchor" href="#aop的实现" aria-hidden="true">#</a> AOP的实现</h3><ol><li><p>AOP的实现</p><p>AOP是一个规范，是动态代理的一个规范化，一个标准，就像IOC是一种思想，是一种控制反转的思想，目的就是为了将我们需要手动创建对象并且赋值的这些操作交给外部容器去处理，spring就基于这种思想有了实现，可以通过依赖注入的方式实现。IOC这种思想的实现就是依赖注入，底层是反射机制。</p><p>AOP这个规范化和标准也需要落地实现</p><p>aop的技术实现框架：</p><ul><li><p>spring：spring在内部实现了aop规范，能做aop的工作</p><p>spring主要在<strong>事务处理时</strong>使用aop</p><p>我们项目开发种很少使用spring的aop实现，因为spring的aop比较笨重</p></li><li><p><strong>aspectJ：一个开源的专门做aop的框架，用得最广泛的，我们主要使用这个框架实现aop</strong></p><p><strong>spring框架中集成了aspectJ框架，通过spring就能使用aspectj的功能</strong></p></li></ul></li><li><p>总结</p><p>ioc的实现</p><ul><li>xml依赖注入 <ul><li>set注入 <ul><li>简单类型注入</li><li>引用类型注入</li></ul></li><li>构造注入</li><li>引用类型自动注入</li></ul></li><li>注解依赖注入</li></ul><p>aop的实现</p><ul><li>spring框架内部实现的aop</li><li>aspectJ，spring中集成了aspectJ框架，可以直接用</li></ul></li><li><p><strong>aspectJ实现aop的两种方式</strong></p><ul><li><strong>使用xml的配置文件---spring事务管理的时候，使用这种方式</strong></li><li><strong>使用注解，我们在项目中要做aop功能，一般都使用注解，和ioc一样，aspectJ有5个注解</strong></li></ul></li><li><p>学习aspectJ框架的使用：</p><ul><li><p><strong>切面的执行时间，这个执行时间在规范中叫做Advice(通知)</strong></p><p>在aspectj框架中使用注解表示的</p><ul><li>@Before</li><li>@AfterReturning</li><li>@Around</li><li>@AfterThrowing</li><li>@After</li></ul></li><li><p><strong>表示切面执行的位置</strong>，切入表达式</p><p><img src="/study/assets/image-20210915144734649.4f36e089.png" alt="image-20210915144734649"></p><p>切入点表达式要匹配的对象就是目标方法（被代理对象的方法，可以说是业务方法，被代理对象也可以说是目标对象），所以execution表达式中明显就是方法的签名，注意，表达式中黑色文字表示可省略部分，各部分间用空格隔开。</p><p><img src="/study/assets/image-20210915145208219.5869e448.png" alt="image-20210915145208219"></p><p><img src="/study/assets/image-20210915145224129.5abe73b2.png" alt="image-20210915145224129"></p></li></ul></li><li><p>什么时候需要用AOP</p><ul><li>当要给系统中存在的类修改功能，但是原有类的功能不完善，原代码改不了的情况下，就是用aop增加功能</li><li>当要给项目中的多个类，增加一个相同的功能，使用aop</li><li>给业务方法增加事务，日志输出</li></ul></li></ol><h3 id="aspectj实现aop的步骤" tabindex="-1"><a class="header-anchor" href="#aspectj实现aop的步骤" aria-hidden="true">#</a> aspectj实现aop的步骤</h3><h4 id="aspectj基于注解的aop实现" tabindex="-1"><a class="header-anchor" href="#aspectj基于注解的aop实现" aria-hidden="true">#</a> AspectJ基于注解的AOP实现</h4><ol><li><p>新建maven项目</p></li><li><p>加入依赖</p><ul><li>spring依赖</li><li>aspectJ依赖</li></ul></li><li><p><strong>创建目标类：接口和它的实现类（实现类就是目标类）</strong></p><p>接口中定义抽象方法，目标类定义方法的具体实现，目标类中的方法就作为目标方法也就是业务方法，就是连接点，多个连接点的集合就是切入点。</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;someService&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SomeService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSome</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;=======目标方法doSome()======&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;name:&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;\tage:&quot;</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p><strong>创建切面类：普通类。</strong></p><ul><li><p><strong>在类的上面加入@Aspect</strong></p></li><li><p>在类中定义方法，方法就是切面要执行的功能代码（业务功能之外的功能增强代码）</p><p><strong>在方法的上面加入aspectj中的通知注解，例如@Before</strong></p><p>有需要指定切入点表达式execution()</p></li></ul><div class="language-java ext-java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 表示当前类是切面类，用来给我们的业务方法增加功能的类，
 * 在这个类中有切面的功能代码，这些功能代码，是非业务的增强功能代码
 * 位置：在类定义的上面
 */</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;myAspect&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAspect</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 定义方法，方法是实现切面功能的
     * 方法的定义要求：
     * 1.公共方法public
     * 2.方法没有返回值
     * 3.方法名称自定义
     * 4.方法可以有参数，也可以没有参数
     *    如果有参数，参数不是自定义的，有几个参数类型可以使用
     * 5. 需要在方法上面加注解表示切面执行时间
     */</span>
    <span class="token doc-comment comment">/**
     * @Before
     * 属性：value：是切入点表达式，表示切面功能的执行的位置
     * 位置：在方法的上面
     * 特点：1.在目标方法之前先执行的
     *      2. 不会改变目标方法的执行结果
     *      3. 不会影响目标方法的执行。
     */</span>
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;execution(public void org.example.impl.SomeServiceImpl.doSome(String,int))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//就是切面要执行的非业务的增强功能代码</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;前置通知，切面功能：在目标方法之前输出时间：&quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>创建spring的配置文件：声明对象，把对象交给容器统一管理</p><p>声明对象可以使用注解或者xml配置文件&lt;bean&gt;</p><ul><li><p><strong>声明目标对象</strong></p><ul><li>可通过注解依赖注入</li><li>可通过xml配置方式依赖注入</li></ul></li><li><p><strong>声明切面类对象</strong></p><ul><li>可通过注解依赖注入</li><li>可通过xml配置方式依赖注入</li></ul></li><li><p><strong>声明aspectj框架中的自动代理生成器标签</strong></p><p><strong>自动代理生成器：用来完成代理对象的自动创建功能的。这样就不用写一堆代码来创建代理对象了</strong></p></li></ul><div class="language-xml ext-xml"><pre class="language-xml"><code>  	<span class="token comment">&lt;!-- 把对象交给spring容器，由spring容器ApplicationContext统一创建，管理对象--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!--
        声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象（被代理对象）的代理对象
        创建代理对象是在内存中实现的，修改目标对象中的内存中的结构，创建为代理对象
        所以代理对象就是被修改后的目标对象。
        &lt;aop:aspectj-autoproxy /&gt; 会把spring容器中的所有目标对象（根据切面类的切面方法上的注解的参数的execution指定的切入点表达式，会知道哪些类是目标类，那么将这些目标类在内存中进行结构的修改，得到代理类。所以目标类就是代理类），一次性都生成代理对象
 		怎么知道目标对象呢？根据切面类的切入点表达式。如果切入点表达式写错了，那么找不到目标类，便不会将目标类修改结构为代理类
		怎么知道切面类呢？根据@Aspect注解
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>aspectj-autoproxy</span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div></li><li><p><strong>注意：创建代理对象是在内存中实现的，修改目标对象中的内存中的结构，创建为代理对象，并加上新增功能</strong></p><p><strong>所以目标对象就是被修改后的代理对象。看起来是目标对象，其实是代理对象</strong></p><p>代码如下：</p><div class="language-java ext-java"><pre class="language-java"><code>    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> config <span class="token operator">=</span> <span class="token string">&quot;applicationContext.xml&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 从容器中获取目标对象</span>
        <span class="token comment">// 获取的这个目标对象（被代理对象）其实是被修改后的代理对象（看起来是目标对象，其实是代理对象）</span>
        <span class="token comment">// 因为&lt;aop:aspectj-autoproxy /&gt; 会把spring容器中的所有目标对象，一次性都生成代理对象</span>
        <span class="token comment">// 而不使用aspectj框架的时候，是通过创建代理对象，代理对象，调用被代理对象的目标方法来做</span>
        <span class="token comment">//// 使用Proxy创建代理对象</span>
        <span class="token comment">//        SomeService proxyInstance = (SomeService) Proxy.newProxyInstance(someService.getClass().getClassLoader(),</span>
        <span class="token comment">//                                    someService.getClass().getInterfaces(),</span>
        <span class="token comment">//                                    invocationHandler);</span>
        <span class="token comment">//        // 通过proxyInstance这个代理对象执行方法， 会调用handler中的invoke()</span>
        <span class="token comment">//        proxyInstance.doSome();</span>
        <span class="token comment">// 下面这个someService就是代理对象！！！！！！！！！！！是修改目标对象结构而来</span>
        <span class="token class-name">SomeService</span> someService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SomeService</span><span class="token punctuation">)</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;someService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过动态代理的对象执行方法，实现目标方法执行时，增强了功能</span>
        someService<span class="token punctuation">.</span><span class="token function">doSome</span><span class="token punctuation">(</span><span class="token string">&quot;lisi&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div></li><li><p>aspectj底层目前用的是jdk的动态代理。</p></li></ol><h4 id="aspectj框架的几种注解和参数" tabindex="-1"><a class="header-anchor" href="#aspectj框架的几种注解和参数" aria-hidden="true">#</a> aspectj框架的几种注解和参数</h4><ol><li><p>参数JoinPoint</p><p><img src="/study/assets/image-20210915171254252.cddac429.png" alt="image-20210915171254252"></p><p><img src="/study/assets/image-20210915171535746.2c16fd99.png" alt="image-20210915171535746"></p></li><li><p>注解：</p><ul><li>@Before</li><li>@AfterReturning</li><li>@Around</li><li>@AfterThrowing</li><li>@After</li></ul><p><strong>以上这几个注解都可以用JoinPoint这个参数</strong></p></li><li><ul><li><p>@Before</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 表示当前类是切面类，用来给我们的业务方法增加功能的类，
 * 在这个类中有切面的功能代码，这些功能代码，是非业务的增强功能代码
 * 位置：在类定义的上面
 */</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;myAspect&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAspect</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 定义通知方法，方法是实现切面功能的
     * 方法的定义要求：
     * 1.公共方法public
     * 2.方法没有返回值
     * 3.方法名称自定义
     * 4.方法可以有参数，也可以没有参数
     *    如果有参数，参数不是自定义的，有几个参数类型可以使用
     * 5. 需要在方法上面加注解表示切面执行时间
     */</span>
    <span class="token doc-comment comment">/**
     * @Before
     * 属性：value：是切入点表达式，表示切面功能的执行的位置
     * 位置：在方法的上面
     * 特点：1.在目标方法之前先执行的
     * 2. 不会改变目标方法的执行结果
     * 3. 不会影响目标方法的执行。
     */</span>
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;execution(public void org.example.impl.SomeServiceImpl.doSome(String,int))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//就是切面要执行的非业务的增强功能代码</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;前置通知，切面功能：在目标方法之前输出时间：&quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>@AfterReturning</p><p><img src="/study/assets/image-20210915173011593.8c826cd2.png" alt="image-20210915173011593"></p><p><img src="/study/assets/image-20210915173119067.017e4db1.png" alt="image-20210915173119067"></p><p><img src="/study/assets/image-20210915173256547.6e422433.png" alt="image-20210915173256547"></p><ul><li><strong>如果返回值类型是基本数据类型和String（Spring中把Java中的基本数据类型和String认为是简单类型，字符串是不可变的），在后置通知方法中，即使把拿到的目标方法即业务方法的返回值改了，对最后通过业务方法拿到的返回值也是没有影响的。</strong></li><li><strong>如果返回值类型是引用数据类型，那么即使值已经被返回了，但是如果后面修改了返回值这个对象引用中（堆空间中实例化对象）的内容，结果就会发生改变</strong></li></ul></li><li><p>@Around</p><div class="language-java ext-java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 环绕通知方法的定义格式
     * 1.public
     * 2.必须有一个返回值，推荐使用Object
     * 3.方法名称自定义
     * 4. 方法有参数，固定的参数ProceedingJoinPoint,是一个接口，继承于JoinPoint（接口之间可以实现多继承）
     */</span>
    <span class="token doc-comment comment">/**
     * @Around 环绕通知
     * 属性：value 切入表达式execution
     * 位置：在方法定义的上面
     * 特点：
     * 1.是功能最强的通知
     * 2.在目标方法的前和后都能增强功能，所以叫环绕通知
     * 3.控制目标方法是否能被调用执行
     * 4.修改原来的目标方法执行结果，影响最后的调用结果
     * 环绕通知等同于jdk动态代理的InvocationHandler接口
     *
     * 参数：proceedingJoinPoint等同于InvocationHandler接口的实现类的方法invoke的参数method
     * 作用：执行目标方法
     *
     * 返回值：就是目标方法的执行结果，这个执行结果可以被修改
     * 如果是@AfterReturning，对于基本数据类型和String来说，结果不能修改，但是对于引用类型来说，最终结果会被修改
     */</span>
    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;execution(* *..SomeServiceImpl.doFirst(..))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">myAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> proceedingJoinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实现环绕通知</span>
        <span class="token class-name">Object</span> result<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;环绕通知；在目标方法之前，输出时间：&quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1. 目标方法调用</span>
        result <span class="token operator">=</span> proceedingJoinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;环绕通知；在目标方法之后，提交事务&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>环绕通知经常做的是事务</strong></p><ul><li>在目标方法之前开启事务</li><li>执行目标方法</li><li>在目标方法之后提交事务</li></ul></li><li><p>AfterThrowing：异常通知----代码中出现了异常，便会执行这个增强功能的代码</p><p><img src="/study/assets/image-20210915202014308.7324d149.png" alt="image-20210915202014308"></p><p><img src="/study/assets/image-20210915202317516.d3ddf7eb.png" alt="image-20210915202317516"></p></li><li><p>@After</p><p><img src="/study/assets/image-20210915202930102.92610496.png" alt="image-20210915202930102"></p><p><img src="/study/assets/image-20210915203044632.61a76a2a.png" alt="image-20210915203044632"></p><p><strong>一般做资源清除工作的。代码总是会被执行，相当于try-catch-finally，finally代码块里面的。</strong></p><p>如果目标方法执行有异常，最终通知方法仍然会被执行，即使目标方法有异常，相当于finally</p></li><li><p>@Pointcut定义切入点</p><p>这不是通知注解，是辅助注解</p><p><img src="/study/assets/image-20210915205025934.eab06104.png" alt="image-20210915205025934"></p><p><img src="/study/assets/image-20210915205640183.bda81bdf.png" alt="image-20210915205640183"></p><p><img src="/study/assets/image-20220103151659626.bddc4150.png" alt="image-20220103151659626"></p><p>此时mypt()就是切入点表达式的别名</p><p><strong>注意：@PointCut是定义在自定义方法上，而不是通知增强方法上，要明确@PointCut不是通知注解，而是一个辅助注解！！</strong></p></li></ul></li><li><p><strong>目标类没有接口，使用cglib动态代理，spring框架会自动应用cglib</strong></p><p><strong>有接口既可以使用cglib代理，也可以使用jdk的动态代理</strong></p><p><strong>但是没有接口只能使用cglib动态代理（spring会自动应用，代码写法都一样）</strong></p><p><img src="/study/assets/image-20210915210756808.1a37ba95.png" alt="image-20210915210756808"></p></li></ol><h2 id="第四章-spring集成mybatis" tabindex="-1"><a class="header-anchor" href="#第四章-spring集成mybatis" aria-hidden="true">#</a> 第四章：Spring集成MyBatis</h2><h3 id="概述-3" tabindex="-1"><a class="header-anchor" href="#概述-3" aria-hidden="true">#</a> 概述</h3><ol><li><p>把mybatis框架和spring框架集成在一起，像一个框架一样使用，用的技术是IoC</p></li><li><p>为什么ioc能把mybatis和spring集成起来呢？</p><p><strong>因为ioc能创建对象，可以把mybatis框架中的对象交给spring容器统一创建、管理。</strong></p><p>开发人员从spring中获取对象，开发人员就不用同时面对两个或多个框架了，就面对一个spring</p></li><li><p>mybatis使用步骤</p><ul><li><p>定义dao接口，StudentDao**（不定义实现类）**</p></li><li><p>定义mapper文件，StudentDao.xml</p></li><li><p>定义mybatis的主配置文件 mybatis.xml</p></li><li><p>创建dao的代理对象，因为<strong>实现类通过mybatis动态代理来创建，并且调用SqlSession访问数据库的方法</strong></p><p><code>StudentDao dao = SqlSession.getMapper(StudentDao.class)</code></p></li></ul><p>所以我们需要SqlSession，那么就需要<strong>SqlSessionFactory对象</strong>的openSession()方法。</p><p><strong>我们会使用独立的连接池类替换mybatis默认的，把连接池交给spring创建，用阿里的druid</strong></p></li><li><p>通过以上说明，我们需要让spring创建以下对象：</p><ol><li><strong>独立的连接池类的对象，使用阿里的druid连接池</strong></li><li><strong>SqlSessionFactory对象</strong></li><li><strong>创建dao接口的实现类的对象。</strong></li></ol><p>我们需要学习以上这三个对象的创建语法，一般不需要让spring容器创建对象的是实体类。</p><p><strong>目前使用xml的bean标签，因为以上三个类没有原代码，用不了注解，以后可以用注解</strong></p><p><strong>dao接口的实现类都没有原代码。为什么？因为mybatis框架是通过动态代理来自动帮我们创建dao接口的实现类的对象，我们在使用mybatis的时候，并没有写dao接口的实现类，对象是自动创建。现在我们是通过spring来集成mybatis</strong></p><p>创建规则是固定的。</p></li></ol><h3 id="spring和mybatis集成步骤" tabindex="-1"><a class="header-anchor" href="#spring和mybatis集成步骤" aria-hidden="true">#</a> spring和mybatis集成步骤</h3><ol><li><p>新建maven项目</p></li><li><p>添加maven依赖</p><ul><li>spring依赖</li><li>mybatis依赖</li><li>mysql驱动connector</li><li>spring的事务的依赖</li><li>mybatis和spring集成的依赖：mybatis官方提供的，用来在spring项目中创建mybatis的SqlSessionFactory、dao接口的实现类的对象的</li></ul><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- spring核心 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 做SPRING事务用到的。 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-tx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- mybatis依赖 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.5.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- mybatis和spring集成的依赖，mybatis提供的 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--阿里公司提供的德鲁伊连接池依赖--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.1.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--mysql驱动--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>8.0.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>创建实体类bean</p></li><li><p>创建dao接口（不用创建的dao接口的实现类）和SQL mapper文件</p></li><li><p>创建mybatis主配置文件</p><div class="language-xml ext-xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">configuration</span>
        <span class="token name">PUBLIC</span> <span class="token string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>
        <span class="token string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>logImpl<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>STDOUT_LOGGING<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 设置别名 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- name：实体类所在的包名 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.domain<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- name：包名，这个包中的所有文件一次都能加载。 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.dao<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>发现<code>&lt;environments&gt;</code>标签没有了，就是把连接池对象交给spring容器来创建，连接信息写在spring容器配置文件中。</p></li><li><p>创建一个Service接口和实现类，属性是dao（通过service调dao是开发中的主要流程）</p></li><li><p>创建spring的配置文件：声明mybatis的对象交给spring创建。</p><ul><li>数据源-Druid连接池，数据源就是Connection</li><li>SqlSessionFactory</li><li>dao接口的实现类的对象（mybatis之前就是通过动态代理自动创建，不需要我们手动创建）</li><li>声明自定义的service</li></ul></li><li><p>创建测试类，获取Service对象，调用dao，完成对数据库的访问（access）</p></li></ol><p>注意：ioc可以是基于xml的依赖注入，也可以是基于注解的，那么基于xml的依赖注入，在给<strong>创建的对象</strong>（创建的是对象，类还是需要自己写的）的属性赋值这一步，需要调用类的set方法（set注入），所以set方法一定要写，<strong>如果通过注解给创建的对象的属性赋值，就不需要用set方法，set方法也可以不写。</strong></p><p>不管是基于注解还是基于XML配置文件，IOC底层都是反射机制。</p><p>本来类是需要我们自己写的，只是把类的对象的创建交给spring容器来创建，并且给属性赋值，但是mybatis框架中，是靠动态代理来进行dao接口的实现类的创建，实现类根本就不需要我们自己写，所以我们拿不到dao接口的实现类的源码，因为根本就不写，mybatis是靠动态代理来创建，它会自动创建dao接口的实现类的对象（通过SqlSession的getMapper()方法），并且调用SqlSession的访问数据库的方法。</p><p>我们没有dao接口的实现类的原代码，所以用不了注解，所以用基于xml的依赖注入，而基于xml的依赖注入，80%都是用的set注入，20%用的是构造注入。我们在这里用set注入没有问题</p><h3 id="spring的配置文件" tabindex="-1"><a class="header-anchor" href="#spring的配置文件" aria-hidden="true">#</a> spring的配置文件</h3><ol><li><p>创建连接池对象</p><p><img src="/study/assets/image-20210917211042496.1393e26f.png" alt="image-20210917211042496"></p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!-- 声明数据源，作用：连接数据库，用druid来代替之前mybatis的environment部分 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myDataSource<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">&quot;</span></span>
          <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>init<span class="token punctuation">&quot;</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>close<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- set注入给DruidDataSource提供连接数据库的信息，依赖注入分为创建对象和给对象赋值两部分，这里的set注入指给对象赋值 --&gt;</span>
        <span class="token comment">&lt;!-- 如果是通过注解的方式实现依赖注入即创建对象和给对象赋值，那么不需要在类里面写set方法，底层是通过反射的机制给属性赋值（即使是set注入，底层也是通过反射的机制）--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>jdbc:mysql://localhost:3306/mybatistest?serverTimezone=Asia/Shanghai<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>username<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>password<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fufu<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>maxActive<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>20<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>像上面的name属性的值都不是随便写的，都是有类里面写了对应的set方法(这是set注入，必须类里面有set方法，才不会报错！！)，因为这是通过set来实现注入。</p><p>依赖注入又分为基于xml的和基于注解的，其中基于xml的分为set注入和构造注入。这里用的是set注入。</p><p>没有用基于注解的原因：没有原代码，没有类的代码，没有创建dao接口的实现类，因为mybatis不需要我们这么做！没有原代码，那么就不能写注解即不能在类的上方加注解的方式来创建对象，就通过配置bean的方式来实现set注入</p><p><strong>set注入一定在类里面有对应的set方法，不然spring会报错</strong></p></li><li><p>创建SqlSessionFactory对象，为了得到SqlSession对象，通过SqlSession的getMapper()方法便可以得到dao接口的实现类的对象</p><div class="language-xml ext-xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 声明的是mybatis中提供的SqlSessionFactoryBean类，这个类的内部是创建SqlSessionFactory的 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sqlSessionFactory<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- set注入，把数据库连接池对象，赋值给dataSource属性，这里是set注入的引用类型变量注入 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSource<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myDataSource<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token comment">&lt;!--mybatis主配置文件的位置，根据主配置文件才能创建出SqlSession，而mybatis主配置文件指定了sql映射文件即mapper文件的位置，根据mapper文件，才能创建出对应的dao接口的实现类的对象 --&gt;</span>
        <span class="token comment">&lt;!--configLocation是spring提供的，用来读取配置文件的，赋值的前面一定要加上classpath:来表示文件的位置，classpath表示类路径下 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>configLocation<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>classpath:mybatis.xml<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 以上两个property加一块，可以代表原来的主配置文件信息，只用mybatis的时候，通过主配置文件创建SqlSessionFactory --&gt;</span>
</code></pre></div></li><li><p>创建dao接口的实现类的对象</p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!-- 创建dao接口的实现类的对象，使用SqlSession的getMapper()--&gt;</span>
    <span class="token comment">&lt;!--MapperScannerConfigurer:在内部调用getMapper()，生成每个dao接口的代理对象--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 指定SqlSessionFactory对象的id--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sqlSessionFactoryBeanName<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sqlSessionFactory<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token comment">&lt;!-- 指定包名，dao接口所在的包名
        MapperScannerConfigurer会扫描这个包中的所有接口，对于每个接口都会执行一次SqlSession.getMapper()方法，得到每个dao接口的实现类的对象
        创建好的dao实现类对象是放在spring容器中的，实际底层是放在concurrentHashMap中的
        --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>basePackage<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.example.dao<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p><strong>注意：</strong></p><p><strong>spring和mybatis整合在一起使用，事务是自动提交的，无需执行SqlSession的commit()</strong></p></li><li><p>可以用配置文件的属性，将连接信息配置在配置文件中</p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>classpath:jdbc.properties<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!-- 使用属性配置文件中的数据 格式：${} --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSource<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">&quot;</span></span>
          <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>init<span class="token punctuation">&quot;</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>close<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>${jdbc.url}<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>username<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>${jdbc.username}<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>password<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>${jdbc.password}<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>maxActive<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>${jdbc.maxActive}<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ol><h2 id="第五章-事务管理" tabindex="-1"><a class="header-anchor" href="#第五章-事务管理" aria-hidden="true">#</a> 第五章：事务管理</h2><h3 id="概述-4" tabindex="-1"><a class="header-anchor" href="#概述-4" aria-hidden="true">#</a> 概述</h3><ol><li><p>事务是指一组sql语句的集合，集合中有多条sql语句，可能是insert、update、select、delete，我们希望这些多个sql语句都能成功，或者都失败，这些sql语句的执行是一致的，作为一个整体执行（原子性、一致性）</p><p>一致性是指数据库经过一个事务提交之后，从一个一致性状态到另一个一致性状态，保持这种一致性。</p></li><li><p>什么时候想到用到事务？</p><p>当我们的操作涉及到<strong>多个表，或者多个sql语句</strong>的insert、update、delete，这些语句需要批量执行。<strong>需要保证这些语句都是成功才能完成我们的功能，或者都失败，保证数据库状态的一致性。</strong></p></li><li><p>在Java代码中，写程序来控制事务，事务应该放在哪里呢？</p><p>我们是在<strong>业务方法中，就是业务层</strong>，即Service接口的实现类里写了方法去调用dao层的访问数据库的方法，那么每调用一个dao层的方法，就是执行一条sql语句，那么我们可能在service层调用多个dao层的方法，即执行多条sql语句，这个时候就需要事务了，所以事务是写在service层，即service接口的实现类里</p><p><strong>在开发中，事务放在service层（service）的业务方法里，因为业务方法可能会涉及到多个dao的调用，或者说调用多个dao层的方法，即执行多个sql语句</strong></p></li><li><p>怎么处理事务</p><ul><li>jdbc访问数据库，处理事务，Connection conn; conn.commit(); conn.rollback();</li></ul></li></ol><ul><li>mybatis访问数据库，sqlSession.commit();sqlSession.rollback(); <ul><li><strong>spring和mybatis整合在一起使用，事务是自动提交的，无需执行SqlSession的commit()，事务的回滚也交给spring处理</strong></li></ul></li></ul><ol start="5"><li><p>第四点说的处理事务的方式，有什么不足？</p><ul><li>不同的数据库访问技术，处理事务的对象方法不同。jdbc用的是Connection对象，mybatis用的是SqlSession，需要了解不同数据库访问技术使用事务的原理</li><li>掌握多种数据库中事务的处理逻辑，什么时候提交，什么时候回滚</li><li>处理事务的多种方法</li></ul><p>总结：多种数据库的访问技术或者说数据库访问框架有不同的事务处理机制、对象、方法</p><p>怎么解决？</p><ul><li><p><strong>统一机制，通过spring解决</strong></p><p><strong>spring提供了一种处理事务的统一模型，做成了一个统一的步骤或者说方式，来完成多种不同数据库访问技术的事务处理</strong></p><p><strong>使用spring的事务处理机制，可以完成hibernate、mybatis访问数据库的事务处理</strong></p><p><strong>spring，将不同数据库处理事务的方式统一了起来，开发人员只需要面对spring处理事务的方式。通过接口和实现类的方式来做，开发人员相当于只需要面对接口，这是面对接口编程，不同类处理事务的方式封装在这个统一接口的不同实现类里面。</strong></p></li></ul></li><li><p>spring的事务处理模型：</p><p>抽象了<strong>不同数据库访问技术的事务处理</strong>各个方面，定义了事务的处理步骤，这种框架的思想就类似于JDBC，JDBC类似于一个访问数据库的接口规范，我们面向jdbc编程，将访问不同数据库的步骤统一了起来，各种不同数据库的具体访问方法相当于基于jdbc这个规范的实现，而我们不需要考虑，只需要面向JDBC！！</p><p><img src="/study/assets/image-20220103172512509.4c4d1262.png" alt="image-20220103172512509"></p><p>不同的数据库访问技术的事务处理都交给spring来管理，开发人员只需要访问spring就可以了</p><p>这种叫声明式事务：把事务的相关的资源和内容都提供给spring，spring就能处理事务的提交和回滚了，几乎不用代码</p></li></ol><h3 id="spring的事务处理实现" tabindex="-1"><a class="header-anchor" href="#spring的事务处理实现" aria-hidden="true">#</a> spring的事务处理实现</h3><ol><li><p>spring的事务处理实现</p><p>spring处理事务的模型，使用的步骤都是固定的，把事务使用的信息提供给spring</p><ul><li><p>spring内部提交、回滚事务，<strong>使用的事务管理器对象</strong>，代替我们完成commit(),rollback()</p><p>事务管理器<strong>是一个接口和这个接口的众多实现类</strong>，事务管理器是<strong>PlatformTransactionManager接口对象</strong></p><p><strong>这个接口定义了事务重要方法：commit() rollback()，接口对应于不同数据库访问技术有不同的实现类，这些实现类有这两个重要方法的重写</strong></p><p>实现类：<strong>spring把每一种数据库访问技术对应的事务处理类都创建好了</strong></p><p>总结：接口是统一的，针对于不同的数据库访问技术有不同的实现类，spring都创建好了</p><ul><li>mybatis访问数据库---spring创建好的是DataSourceTransactionManager</li><li>hibernate访问数据库---spring创建好的是HibernateTransactionManager</li></ul></li><li><p>需要告诉spring我们用的哪种数据库访问技术，怎么告诉spring？</p><ul><li><p>声明数据库访问技术对应的事务管理器接口的实现类，在spring配置文件中使用&lt;bean&gt;</p><p>例如，我们要用mybatis访问数据库，那么在xml配置文件中</p><p><img src="/study/assets/image-20210918000618311.68e97631.png" alt="image-20210918000618311"></p></li></ul></li><li><p>我们的业务方法需要什么样的事务类型，<strong>说明需要的事务类型</strong></p><p>说明方法需要的事务：</p><ul><li>事务的隔离级别：有4个值</li></ul><p><img src="/study/assets/image-20210918000851651.00e7c62f.png" alt="image-20210918000851651"></p><p><img src="/study/assets/image-20210918001051062.a6a89749.png" alt="image-20210918001051062"></p><ul><li><p>事务的超时时间：</p><p>表示一个方法的最长执行时间， 如果方法执行时超过了时间，事务就回滚</p><p>单位是秒，整数值，默认是-1，一般做项目不设置这个值</p></li><li><p><strong>事务的传播行为</strong></p><p>控制业务方法是不是有事务的，是什么样的事务的</p><p>有7个传播行为，表示我们的业务方法调用时，事务在方法之间是如何使用的。</p></li></ul></li></ul></li><li><p>事务传播行为：</p><p>所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况，如A事务中的方法doSome()调用B事务中的方法doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。</p></li><li><p>事务的7个传播行为：</p><ul><li><p>PROPAGATION_REQUIRED</p><p>指定的方法必须在事务内执行，若当前存在事务，就加入到当前事务中，若当前没有事务，则创建一个新事务，这种事务传播行为是最常见的选择，也是Spring默认的事务传播行为</p><p>说明加了PROPAGATION_REQUIRED，一定有事务，因为没有的话，会新建事务</p><p><img src="/study/assets/image-20210918002432273.06fa7933.png" alt="image-20210918002432273"></p></li><li><p>PROPAGATION_REQUIRES_NEW</p><p><strong>如果PROPAGATION_REQUIRES_NEW加在一个方法上，那么这个方法总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。不用别人提供的事务，就用自己新建的</strong>。</p><p>有没有事务都新建。</p></li><li><p>PROPAGATION_SUPPORTS</p><p>如果PROPAGATION_SUPPORTS加在一个方法上，说明该方法支持事务，但是如果当前没有事务，也没有影响，也可以以非事务方式执行，查询操作（读操作）就是有事务没有事务都可以</p></li><li><p>PROPAGATION_MANDATORY</p></li><li><p>PROPAGATION_NESTED</p></li><li><p>PROPAGATION_NEVER</p></li><li><p>PROPAGATION_NOT_SUPPORTED</p></li></ul></li><li><p>spring提交事务、回滚事务</p><ul><li><p>当业务方法执行成功，没有异常抛出，当方法执行完毕，spring在方法执行后，提交事务，自动提交，自动调用事务管理器的commit(),不需要写代码</p></li><li><p>当业务方法抛出运行时异常或ERROR，spring执行回滚，自动调用事务管理器的rollback()方法</p><p>运行时异常的定义:RuntimeException和他的子类都是运行时异常，例如NullPointException，NumberFormatException</p></li><li><p>当业务方法抛出非运行时异常，主要是受查异常时，默认提交事务。</p><p>非运行时异常：就是指的我们写代码时，必须处理的异常，例如IOException、SQLException</p><p>而运行时异常一般是不处理的</p></li></ul></li><li><p>总结spring的事务</p><ol><li><p>管理事务的是spring的事务管理器接口和他的实现类(实现类是针对不同数据库的事务处理机制，那么有不同的实现类)</p></li><li><p><strong>spring的事务是一个统一模型</strong></p><ul><li><strong>指定要使用的事务管理器实现类，使用&lt;bean&gt;</strong></li><li><strong>指定哪些类，哪些方法需要加入事务的功能</strong></li><li><strong>指定方法需要的隔离级别、传播行为、超时时间</strong></li></ul></li></ol></li><li><p>注意：</p><p>在service层，接口和实现类都是要创建的</p><p>在dao层，只需要创建接口，不需要创建实现类，dao层的接口的实现类的对象通过mybatis动态代理创建（SqlSession.getMapper()），并调用SqlSession访问数据库的方法</p><p>但是不管是service层还是dao层，类的对象，都是不用手动实例化的，都交给spring容器来做，依赖注入，这是IOC思想</p><p><strong>service层会创建实现类而dao层不需要创建实现类，但是他们的共同点是都没有创建对象！对象的创建交给spring来做</strong></p></li></ol><h3 id="spring框架中提供的事务处理方案" tabindex="-1"><a class="header-anchor" href="#spring框架中提供的事务处理方案" aria-hidden="true">#</a> spring框架中提供的事务处理方案</h3><h4 id="_1-中小型项目-transactional-spring自己实现的aop" tabindex="-1"><a class="header-anchor" href="#_1-中小型项目-transactional-spring自己实现的aop" aria-hidden="true">#</a> 1. 中小型项目 @Transactional---spring自己实现的aop</h4><ol><li><p><strong>spring框架自己用aop实现给业务方法增加事务的功能，使用@Transactional注解增加事务</strong></p><p>@Transactional注解是spring框架自己的注解，放在public方法的上面，表示当前这个方法具有事务，可以给注解的属性赋值，表示具体的隔离级别，传播行为，异常信息等。</p><p><strong>@Transactional的所有可选属性，写在注解后的括号里面（）</strong></p><p><img src="/study/assets/image-20210918020320640.8d2fc58c.png" alt="image-20210918020320640"></p><p><img src="/study/assets/image-20210918020555438.de7f4326.png" alt="image-20210918020555438"></p></li><li><p>使用@Transactional的步骤</p><ul><li><p>需要声明事务管理器接口的对象（对象的创建仍然是交给spring来处理，用spring这个框架，对象的创建都交给他，除了一些实体类）</p><p><img src="/study/assets/image-20210918020706229.5370b248.png" alt="image-20210918020706229"></p></li><li><p><strong>开启事务注解驱动</strong>，告诉spring，<strong>要使用注解的方式管理事务</strong>，spring就会使用aop机制，创建@Transactional所在的类的代理对象，给方法加入事务的功能（aop的底层是采用<strong>动态代理</strong>实现）</p><p>spring给业务方法加入事务：</p><p><strong>在业务方法执行之前，先开启事务，在业务方法之后，提交或回滚事务</strong>，使用的是aop的<strong>环绕通知</strong>！</p><p><img src="/study/assets/image-20210918021222839.20498914.png" alt="image-20210918021222839"></p><div class="language-xml ext-xml"><pre class="language-xml"><code><span class="token comment">&lt;!--1. 使用spring的事务处理，声明事务管理器接口的实现类对象 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSourceTransactionManager<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSource<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myDataSource<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 2. 开启事务注解驱动，告诉spring使用注解来管理事务 --&gt;</span>
<span class="token comment">&lt;!-- dataSourceTransactionManager: 事务管理器接口的实现类的对象的id --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSourceTransactionManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div></li><li><p><strong>在公共方法或类上面加入@Transactional注解，</strong></p><p>一般写在需要事务的方法上，方法是公共方法，这个方法是业务方法，因为加事务一般是加在业务方法上，有时也说目标方法，业务方法才采用aop新增功能，原来的业务方法里面就专心处理业务逻辑。业务方法是service接口的实现类内部的方法。service接口的实现类的对象，是通过aop采用动态代理的方式创建，在原有的目标对象上面，结构做了修改，最后创建出来的是代理对象，看上去是目标对象，但实际上是内部结构修改了的代理对象。这是aop动态代理。所以aop的实现机制是动态代理，而ioc是依赖注解，底层是反射。动态代理创建的是代理对象。如果不采用aop的方式，自己实现，那么代理对象和被代理对象是分开的，采用aop就不是。（aop是动态代理的规范）</p><div class="language-java ext-java"><pre class="language-java"><code>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>
            propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>
            isolation <span class="token operator">=</span> <span class="token class-name">Isolation</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">,</span>
            readOnly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
            rollbackFor <span class="token operator">=</span> <span class="token punctuation">{</span>
                    <span class="token class-name">NullPointerException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>
                    <span class="token class-name">NotEnoughException</span><span class="token punctuation">.</span><span class="token keyword">class</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buy</span><span class="token punctuation">(</span><span class="token keyword">int</span> gid<span class="token punctuation">,</span> <span class="token keyword">int</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;buy方法开始&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1. 记录销售的信息,向sale表添加记录</span>
        <span class="token class-name">Sale</span> sale <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sale<span class="token punctuation">.</span><span class="token function">setGid</span><span class="token punctuation">(</span>gid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sale<span class="token punctuation">.</span><span class="token function">setNums</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        saleDao<span class="token punctuation">.</span><span class="token function">insertSale</span><span class="token punctuation">(</span>sale<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2. 更新库存</span>
        <span class="token comment">// 现有商品</span>
        <span class="token class-name">Good</span> good <span class="token operator">=</span> goodsDao<span class="token punctuation">.</span><span class="token function">selectGood</span><span class="token punctuation">(</span>gid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>good <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span>gid <span class="token operator">+</span> <span class="token string">&quot; 商品不存在&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>good<span class="token punctuation">.</span><span class="token function">getAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotEnoughException</span><span class="token punctuation">(</span>gid <span class="token operator">+</span> <span class="token string">&quot; 商品库存不足&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 要买的商品</span>
        <span class="token class-name">Good</span> buyGood <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Good</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        buyGood<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>gid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        buyGood<span class="token punctuation">.</span><span class="token function">setAmount</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        goodsDao<span class="token punctuation">.</span><span class="token function">updateGoods</span><span class="token punctuation">(</span>buyGood<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;buy方法完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>rollbackFor：表示发生指定的异常一定回滚</strong></p><p><strong>处理逻辑是：</strong></p><ol><li><p><strong>spring框架会首先去检查方法抛出的异常是不是在rollbackFor属性值中，如果异常在rollbackFor列表中，不管是什么类型的异常，一定回滚，不管是非运行时异常还是运行时异常，都回滚，因为这是rollbackFor指定的！</strong></p></li><li><p><strong>如果抛出的异常不在rollbackFor列表中，spring会判断异常是不是运行时异常，如果是运行时异常，那么一定回滚，如果是非运行时异常，那么默认提交</strong></p></li></ol></li></ul><p>前两步都是在配置文件中实现的</p></li><li><p>注意：</p><p><strong>这是spring框架自己用aop实现的给业务方法增加事务功能的方式，aop是基于动态代理的，ioc是基于依赖注入，底层是基于反射的。spring采用了aop给业务方法增加事务功能，那么就会用到动态代理</strong></p><p><strong>而动态代理，使用&lt;aop:aspectj-autoproxy /&gt; 会把spring容器中的所有目标对象（怎么知道哪些对象是目标对象呢，根据切入点表达式找到目标方法，目标方法所在类的对象便是目标对象），一次性都生成代理对象</strong></p><p>使用aop，动态代理：创建代理对象是在内存中实现的，修改目标对象中的内存中的结构，创建为代理对象，并加上新增功能，<strong>所以目标对象就是被修改后的代理对象。看起来是目标对象，其实是代理对象。（和手动创建InvocationHandler，创建proxy那种方式不同，那种方式代理对象和被代理对象就是分开的。）</strong></p><p>面向切面编程有一个很重要的点就是，为什么知道给哪个方法加切面也就是新增功能呢？因为通知方法那里会写execution来指定切入表达式，指明的就是哪个方法需要做功能的新增。</p></li></ol><h4 id="_2-大型项目-aspectj实现aop-基于配置管理事务" tabindex="-1"><a class="header-anchor" href="#_2-大型项目-aspectj实现aop-基于配置管理事务" aria-hidden="true">#</a> 2. 大型项目---AspectJ实现AOP，基于配置管理事务</h4><ol><li><p>采用aspectJ实现aop，只不过改为配置文件的方式，<strong>把原先注解的代码移到配置文件中</strong></p></li><li><p>需要大量的配置事务，使用aspectj框架功能，在spring配置文件中，声明类，方法需要的事务。</p><p>这种方式业务方法和事务配置完全分离</p></li><li><p>spring管理事务有两种方式</p><ul><li>@Transactional---spring自己实现aop</li><li>aspectj实现aop---我们自己实现aop，之前就说过，aop是面向切面编程，那么可以在不改动原有代码的情况下增加新的事务功能，所以实现事务当然要使用aop机制</li></ul><p>不管是哪种方式，都要实现aop，aop的底层是动态代理</p><p>不管是哪种方式，都要声明事务管理器接口的实现类对象，这是spring处理事务的根本---将不同数据库访问技术的事务处理都统一起来---通过事务管理器接口这种规范，针对于不同的数据库访问技术有不同的实现类</p></li><li><p>实现步骤--都是在xml配置文件中实现：</p><ul><li><p>要使用的是aspectj框架，需要加入依赖</p></li><li><p>声明事务管理器对象---不管采用哪种方式实现事务的管理，只要通过spring来做，必须使用事务管理器，这是spring实现事务管理的机制，不管是通过@Transaction（spring自己实现aop）还是通过aspectj实现aop（我们自己实现aop）</p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!-- 声明式事务，和业务代码完全分离--&gt;</span>
    <span class="token comment">&lt;!-- 1.声明事务管理器对象 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSourceTransactionManager<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSource<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myDataSource<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>声明方法需要的事务类型（配置方法的事务的属性---包含事务隔离级别，传播行为，超时时间）</p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!-- 2.声明业务方法需要的事务属性-配置传播行为、超时、隔离级别 --&gt;</span>
    <span class="token comment">&lt;!--
        id: 自定义名称，表示&lt;tx:advice&gt;&lt;/tx:advice&gt;之间的配置内容
        transaction-manager：事务管理器对象的id
     --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myAdvice<span class="token punctuation">&quot;</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dataSourceTransactionManager<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- tx.attributes:配置事务属性--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!--tx:method：给具体的方法配置事务属性，method可以有多个，分别给不同的方法设置事务属性--&gt;</span>
            <span class="token comment">&lt;!--
                name: 两种方式 1.完整的方法名称，不带有包和类；
                              2.方法名可以使用通配符，*表示任意字符
                propagation：传播行为
                isolation:隔离级别
                rollback-for：指定的异常类名，全限定类名，发生异常一定回滚
            --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>buy<span class="token punctuation">&quot;</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>REQUIRED<span class="token punctuation">&quot;</span></span> <span class="token attr-name">isolation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>DEFAULT<span class="token punctuation">&quot;</span></span> <span class="token attr-name">rollback-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>java.lang.NullPointerException,org.example.exception.NotEnoughException<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><img src="/study/assets/image-20210918154449165.3e91cd5a.png" alt="image-20210918154449165"></p></li><li><p>经过上一步，配置好了哪些方法，使用事务，并且配置好了事务属性。但是并不知道这些方法是在哪些类里面，所以还需要配置类。</p><p><strong>配置aop，指定哪些类要创建代理</strong>---使用&lt;aop:aspectj-autoproxy /&gt; 会把spring容器中的所有目标对象，一次性都生成代理对象</p><p><strong>为什么要使用代理对象？</strong></p><p><strong>因为我们就是为了不改变原代码，而可以添加新的功能比如事务和日志。</strong></p><p><strong>如果不使用代理对象去调用原service实现类的方法，那么就是用原对象就是被代理对象自身去掉，虽然没有新增代码，但是也不可能新增功能，因为我们的目的就是不在业务方法里添加新的代码，而实现新增功能</strong></p><p><strong>所以必须使用代理对象去调目标对象的方法，就新增了功能，又没有改目标类的代码（目标类是service实现类），自己写的话，那么会调用InvocationHandler里的invoke方法，aspectj实现aop来做的话，获得的目标对象就是代理对象，目标对象内部结构修改之后，就是代理对象！！</strong></p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!--3. 配置aop--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--
            配置切入点表达式：指定哪些包中哪些类，要使用事务
            id：切入点表达式的名称，唯一值
            expression：切入点表达式，指定哪些类要使用事务，aspectj会创建代理对象，代理对象是改造目标对象而来，通过这种方式，获得的目标对象，其实就是代理对象。
            是目标对象改造而来
            service是处理业务逻辑的，所有的service的包里面的类的定义的方法应该具有事务
        --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>servicePt<span class="token punctuation">&quot;</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>execution(* *.service..*.*(..))<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token comment">&lt;!--
            配置增强器：关联advice和pointcut
            advice-ref:通知，上面tx:advice那里的配置
            pointcut-ref：切入点表达式的id
        --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>advisor</span> <span class="token attr-name">advice-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myAdvice<span class="token punctuation">&quot;</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>servicePt<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul></li></ol><h2 id="第六章-在web项目中使用容器对象" tabindex="-1"><a class="header-anchor" href="#第六章-在web项目中使用容器对象" aria-hidden="true">#</a> 第六章：在web项目中使用容器对象</h2><ol><li><p><img src="/study/assets/image-20210918171200551.40cb41d3.png" alt="image-20210918171200551"></p></li><li><p>web项目是在tomcat服务器运行的，tomcat一启动，项目就是一直运行的。</p><p><img src="/study/assets/image-20210918174507560.1c837099.png" alt="image-20210918174507560"></p></li><li><p>每一次调用controller层的servlet类的doPost方法或者doGet方法，都会创建spring的容器对象applicationContext，如果客户端在一秒钟之内发了很多次请求，比如100次，那么一秒钟之内就要调用100次servlet类的doPost方法，就要新创建100次spring的容器对象，这显然是不合理的。</p><p><strong>spring容器对象只需要创建一次，是单例的！！！</strong></p></li><li><p>需求：在web项目中，容器对象只需要创建一次，把spring容器对象放入到全局作用域ServletContext中，这样这个容器就可以在多个Servlet类中使用这个容器对象</p><p><strong>方法：使用监听器，当全局作用域ServletContext对象被创建时，创建容器，存入ServletContext</strong></p></li><li><p>监听器作用：</p><ul><li><p>创建spring容器对象applicationContext，执行<img src="/study/assets/image-20210918182446699.da3c4737.png" alt="image-20210918182446699"></p></li><li><p>把容器对象放入到ServletContext全局作用域，<code>ServletContext.setAttribute(key, ctx);</code></p></li></ul><p>监听器可以自己创建，也可以使用框架中提供好的ContextLoaderListener</p></li><li><p>一个web工程，只有一个ServletContext对象实例，不管调用几次getServletContext都是返回同一个ServletContext对象实例，说明是单例模式</p><p>ServletContext对象是一个域对象</p><p>域对象，是可以像Map一样存取数据的对象，叫域对象</p><p><strong>ServletContext对象是在web工程启动的时候创建，工程停止的时候销毁</strong></p><p><strong>总结：使用监听器+ServletContext，实现spring容器的单例创建</strong></p></li><li><p>为了使用监听器对象，需要加入如下依赖：</p><p><img src="/study/assets/image-20220103214831001.f88a2a76.png" alt="image-20220103214831001"></p></li><li><p><img src="/study/assets/image-20210918183205489.3ae66716.png" alt="image-20210918183205489"></p><p><img src="/study/assets/image-20210918183317069.a1ce059d.png" alt="image-20210918183317069"></p><p><img src="/study/assets/image-20210918183544691.a2d8717e.png" alt="image-20210918183544691"></p></li><li><p><img src="/study/assets/image-20210918183810733.6cc847c9.png" alt="image-20210918183810733"></p></li><li><p>总结步骤：</p><ul><li>配置监听器，配置了就创建好了容器对象，创建好的容器对象放在ServletContext里</li><li>通过调用工具类的方法，取得容器对象</li></ul></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.8dc26b26.js" defer></script>
  </body>
</html>
