<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>SpringMVC | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.aa278c57.js"><link rel="modulepreload" href="/study/assets/springMVC.html.00550998.js"><link rel="modulepreload" href="/study/assets/springMVC.html.a0e1ee9d.js"><link rel="prefetch" href="/study/assets/index.html.46bcf1e0.js"><link rel="prefetch" href="/study/assets/index.html.aaa388ac.js"><link rel="prefetch" href="/study/assets/index.html.fa57144f.js"><link rel="prefetch" href="/study/assets/index.html.5ab86b57.js"><link rel="prefetch" href="/study/assets/gin.html.94c74c32.js"><link rel="prefetch" href="/study/assets/golang.html.901e1973.js"><link rel="prefetch" href="/study/assets/gorm.html.b158de97.js"><link rel="prefetch" href="/study/assets/Javaweb.html.aa87ad2e.js"><link rel="prefetch" href="/study/assets/ES.html.261c595e.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.f4160af7.js"><link rel="prefetch" href="/study/assets/Java笔记.html.e4c47e53.js"><link rel="prefetch" href="/study/assets/dubbo.html.ea06d64d.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.0f5f7dff.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.275a07bc.js"><link rel="prefetch" href="/study/assets/zookeeper.html.be19fae0.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.8106e0fb.js"><link rel="prefetch" href="/study/assets/并发编程.html.8d51055f.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.6dd3d350.js"><link rel="prefetch" href="/study/assets/redis.html.c68d3d9c.js"><link rel="prefetch" href="/study/assets/Mybatis.html.ad485da6.js"><link rel="prefetch" href="/study/assets/spring.html.6e8eafe4.js"><link rel="prefetch" href="/study/assets/springboot.html.7a830e07.js"><link rel="prefetch" href="/study/assets/springboot.html.f7bc6593.js"><link rel="prefetch" href="/study/assets/kafka.html.961de27d.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.7f81c96c.js"><link rel="prefetch" href="/study/assets/操作系统.html.87cdc8bd.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.5c5a16ce.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.299cad5e.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.8d860e9a.js"><link rel="prefetch" href="/study/assets/index.html.fbbacc2f.js"><link rel="prefetch" href="/study/assets/index.html.7455c438.js"><link rel="prefetch" href="/study/assets/index.html.c28b531f.js"><link rel="prefetch" href="/study/assets/gin.html.b3d966fb.js"><link rel="prefetch" href="/study/assets/golang.html.829cebef.js"><link rel="prefetch" href="/study/assets/gorm.html.26beaf8a.js"><link rel="prefetch" href="/study/assets/Javaweb.html.3697bff2.js"><link rel="prefetch" href="/study/assets/ES.html.b94f4c72.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.ebc4a6c3.js"><link rel="prefetch" href="/study/assets/Java笔记.html.1cfeb77b.js"><link rel="prefetch" href="/study/assets/dubbo.html.6e212cd8.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.b61922d6.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.5a1ea6e9.js"><link rel="prefetch" href="/study/assets/zookeeper.html.88c8a62d.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.8d5e3702.js"><link rel="prefetch" href="/study/assets/并发编程.html.77080c7e.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.033a1ab3.js"><link rel="prefetch" href="/study/assets/redis.html.79c2d1af.js"><link rel="prefetch" href="/study/assets/Mybatis.html.ebc36a0a.js"><link rel="prefetch" href="/study/assets/spring.html.941a119a.js"><link rel="prefetch" href="/study/assets/springboot.html.d9046ea6.js"><link rel="prefetch" href="/study/assets/springboot.html.704f686c.js"><link rel="prefetch" href="/study/assets/kafka.html.048ce851.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.b6c211c2.js"><link rel="prefetch" href="/study/assets/操作系统.html.0c1c56a6.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.6e058c60.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.6ee30181.js"><link rel="prefetch" href="/study/assets/404.html.743ddd72.js"><link rel="prefetch" href="/study/assets/404.f5289506.js"><link rel="prefetch" href="/study/assets/Layout.27578e8d.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">SpringMVC <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#第1章-springmvc概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="第1章 SpringMVC概述"><!--[--><!--]--> 第1章 SpringMVC概述 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#搭建springmvc项目步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="搭建springmvc项目步骤"><!--[--><!--]--> 搭建springmvc项目步骤 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#springmvc请求的处理流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="springmvc请求的处理流程"><!--[--><!--]--> springmvc请求的处理流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#dispatcherservlet的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="DispatcherServlet的作用"><!--[--><!--]--> DispatcherServlet的作用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#第2章-springmvc注解式开发" class="router-link-active router-link-exact-active sidebar-item" aria-label="第2章 SpringMVC注解式开发"><!--[--><!--]--> 第2章 SpringMVC注解式开发 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#requestmapping" class="router-link-active router-link-exact-active sidebar-item" aria-label="@RequestMapping"><!--[--><!--]--> @RequestMapping <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#接收用户提交的参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="接收用户提交的参数"><!--[--><!--]--> 接收用户提交的参数 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#概述-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#逐个接收请求参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="逐个接收请求参数"><!--[--><!--]--> 逐个接收请求参数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#用一个对象来接收请求参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="用一个对象来接收请求参数"><!--[--><!--]--> 用一个对象来接收请求参数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#控制器方法的返回值" class="router-link-active router-link-exact-active sidebar-item" aria-label="控制器方法的返回值"><!--[--><!--]--> 控制器方法的返回值 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#返回modelandview" class="router-link-active router-link-exact-active sidebar-item" aria-label="返回ModelAndView"><!--[--><!--]--> 返回ModelAndView <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#返回string" class="router-link-active router-link-exact-active sidebar-item" aria-label="返回String"><!--[--><!--]--> 返回String <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#返回void" class="router-link-active router-link-exact-active sidebar-item" aria-label="返回void"><!--[--><!--]--> 返回void <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#返回对象object-需加-responsebody" class="router-link-active router-link-exact-active sidebar-item" aria-label="返回对象Object----需加@ResponseBody"><!--[--><!--]--> 返回对象Object----需加@ResponseBody <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#解读-url-pattern" class="router-link-active router-link-exact-active sidebar-item" aria-label="解读&lt;url-pattern/&gt;"><!--[--><!--]--> 解读&lt;url-pattern/&gt; <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#访问地址" class="router-link-active router-link-exact-active sidebar-item" aria-label="访问地址"><!--[--><!--]--> 访问地址 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#第3章-ssm整合开发" class="router-link-active router-link-exact-active sidebar-item" aria-label="第3章 SSM整合开发"><!--[--><!--]--> 第3章 SSM整合开发 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#概述-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#整合开发步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="整合开发步骤"><!--[--><!--]--> 整合开发步骤 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#第4章-springmvc核心技术" class="router-link-active router-link-exact-active sidebar-item" aria-label="第4章 SpringMVC核心技术"><!--[--><!--]--> 第4章 SpringMVC核心技术 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#请求重定向和转发" class="router-link-active router-link-exact-active sidebar-item" aria-label="请求重定向和转发"><!--[--><!--]--> 请求重定向和转发 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#异常处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="异常处理"><!--[--><!--]--> 异常处理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#概述-3" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#异常处理步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="异常处理步骤"><!--[--><!--]--> 异常处理步骤 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#拦截器" class="router-link-active router-link-exact-active sidebar-item" aria-label="拦截器"><!--[--><!--]--> 拦截器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#概述-4" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#拦截器的使用步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="拦截器的使用步骤"><!--[--><!--]--> 拦截器的使用步骤 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#handlerinterceptor接口的三个方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="HandlerInterceptor接口的三个方法"><!--[--><!--]--> HandlerInterceptor接口的三个方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#多个拦截器的三个方法执行顺序" class="router-link-active router-link-exact-active sidebar-item" aria-label="多个拦截器的三个方法执行顺序"><!--[--><!--]--> 多个拦截器的三个方法执行顺序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#拦截器和过滤器的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="拦截器和过滤器的区别"><!--[--><!--]--> 拦截器和过滤器的区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springmvc/springMVC.html#springmvc内部请求的处理流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="springmvc内部请求的处理流程"><!--[--><!--]--> springmvc内部请求的处理流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="springmvc" tabindex="-1"><a class="header-anchor" href="#springmvc" aria-hidden="true">#</a> SpringMVC</h1><h2 id="第1章-springmvc概述" tabindex="-1"><a class="header-anchor" href="#第1章-springmvc概述" aria-hidden="true">#</a> 第1章 SpringMVC概述</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><ol><li><p><strong>springMVC:基于spring的框架，实际上就是spring的一个模块</strong></p><p>这个模块专门做web开发</p><p>基于web开发的框架的底层都是基于servlet</p><p>springMVC可以理解成是servlet的一个升级，就像把mybatis理解成JDBC的升级</p><p>直接用servlet不方便，所以我们用框架来让web开发更加流畅简单</p><p>servlet是在controller层，是tomcat服务器的核心组件之一，用于接受请求，调用业务层处理请求，返回请求</p></li><li><p>springMVC框架是在servlet基础上加入一些功能，让我们做web开发更加方便。</p></li><li><p>springMVC实际上就是一个spring，spring是一个容器，通过ioc管理对象，使用&lt;bean&gt;标签或者注解的形式管理对象</p><p>springMVC能够创建对象，放入到容器中（springMVC的容器），springMVC容器中放的是控制器对象，用的是@Controller注解</p></li><li><p>在web开发中，spring容器applicationContext是通过<strong>监听器</strong>结合ServletContext来存储这个容器，使spring容器成为一个单例创建，并且可以通过servletContext全局作用域来获取到这个容器</p></li><li><p>我们要做的就是使用@Controller创建控制器对象，把对象放入到spring MVC容器中，把创建的对象作为控制器使用，这个控制器对象能够接收用户的请求，显示处理的结果，就当作一个servlet使用。</p><p>使用@Controller这个注解创建的就是一个普通类的对象---作为控制器对象，不是Servlet，但是springmvc赋予了控制器对象一些额外的功能，让它可以像servlet一样工作。<strong>加了这个@Controller注解，就能让这个类完成servlet的功能。</strong></p><p>不是servlet的原因是servlet类都要继承于HttpServlet类。</p></li><li><p>web开发的底层都是servlet</p><p>springmvc中有一个对象是servlet：<strong>DispatcherServlet---中央调度器</strong></p><p>DispatcherServlet：<strong>负责接收用户的所有请求</strong>，<strong>用户把请求给了DispatcherServlet，之后DispatcherServlet把请求转发给我们的Controller对象，最后是Controller对象处理请求。</strong></p><p>Controller对象是由springMVC容器帮我们创建的，用的就是IOC技术</p></li><li><p><strong>xxx.jsp-----DispatcherServlet(Servlet)----转发、分配给Controller对象（@Controller注解创建的对象（ioc中的注解注入））-----Controller类处理请求。</strong></p><p><strong>比之前的过程多了一个转发， DispatcherServlet不处理请求， 而是转发请求给Controller对象</strong></p></li><li><p><img src="/study/assets/image-20210919142829981.0d2ed9a3.png" alt="image-20210919142829981"></p></li></ol><h3 id="搭建springmvc项目步骤" tabindex="-1"><a class="header-anchor" href="#搭建springmvc项目步骤" aria-hidden="true">#</a> 搭建springmvc项目步骤</h3><ol><li><p>新建maven-web工程</p></li><li><p>加入依赖</p><ul><li><p>spring-webmvc依赖----代表springmvc框架，会间接地把spring的依赖都加入到项目中，因为springmvc是基于spring的</p></li><li><p>servlet依赖，底层还是基于servlet</p></li></ul><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>javax.servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>重点：要在web.xml中注册springmvc的核心对象DispatcherServlet</p><ul><li><p>DispatcherServlet是<strong>中央调度器</strong>，是一个servlet，它的父类是集成HttpServlet</p></li><li><p>DispatcherServlet也叫做前端控制器（front controller）</p></li><li><p>DispatcherServlet负责接收用户提交的请求，<strong>调用其他的控制器对象</strong>，并把请求的处理结果显示给用户</p><p>接收用户请求的仍然是DispatcherServlet而不是Controller</p><p>只要是springmvc项目，必须要有DispatcherServlet对象！！</p></li></ul><div class="language-xml ext-xml"><pre class="language-xml"><code><span class="token prolog">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">&quot;</span></span>
         <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>4.0<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--
        声明：注册springmvc的核心对象DispatcherServlet
        DispatcherServlet有一个作用是创建springmvc容器对象的，容器对象创建好了，那么容器里的声明的对象也都会随着容器对象的创建而创建好
        所以DispatcherServlet要随着tomcat服务器的启动而创建
        DispatcherServlet的实例化对象，需要在tomcat服务器启动后创建
        为什么要创建DispatcherServlet实例化对象呢？
        因为DispatcherServlet在创建过程中，会同时创建springmvc容器对象，会读取springmvc的配置文件，把这个配置文件中的对象都创建好，当用户发起请求时，就可以直接使用对象了。
		

		servlet初始化，会执行init方法。DispathcerServlet在init()中，会执行如下创建容器对象:
 		WebApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;);
		springmvc容器对象创建好之后，会和之前一样，放在ServletContext全局作用域中。
        springmvc创建容器对象时，读取的配置文件默认是/WEB-INF/&lt;servlet-name&gt;-servlet.xml
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>myweb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 自定义springmvc读取的配置文件的位置--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>classpath:springmvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--
        希望在tomcat启动后，创建DispatcherServlet对象
        load-on-startup 表示tomcat启动后创建对象的顺序，它的值是整数，数值越小，tomcat创建对象的时间越早，大于等于0的整数
    --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>myweb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--
            使用框架的适合，url-pattern可以使用两种值
            1. 使用扩展名的方式，语法*.xxxx,xxxx时自定义的扩展名，常用的方式：*.do,*.action,*.mvc等等
            http://localhost:8080/myweb/some.do
            
            2. 使用 “/”
        --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>*.do<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>
    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>对象创建流程如下：</p><blockquote><p>tomcat服务器启动</p><p>DispathcherServlet对象创建(这类似于监听器)</p><p>同时，DispathcherServlet对象创建过程的初始化过程中，springmvc容器对象创建并放在ServletContext中</p><p>同时，写在springmvc配置文件中的对象会创建。</p><p>总结：</p><p>tomcat服务器启动--DispathcherServlet对象创建---springmvc容器对象创建--springmvc容器中的对象会创建</p></blockquote></li><li><p>创建一个发起请求的页面index.jsp</p></li><li><p>创建控制器类：</p><ul><li>在类的上面加入@Controller注解，创建对象，并放入到springmvc容器中</li><li>在类中的方法上面加入@RequestMapping注解</li></ul><div class="language-java ext-java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 创建控制器对象的，这个对象是放在springmvc容器中。
 * 位置：在类的上面
 * 和之前spring讲的@Service @Repository是一样的，是创建的对象的，即通过注解方式实现依赖注入，@Autowired @Resource 是给引用类型变量赋值
 */</span>
<span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyController</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * 处理用户提交的请求，springmvc中是使用方法来处理的
     * 方法是自定义的，可以有多种返回值，多种参数
     */</span>

    <span class="token doc-comment comment">/**
     * 准备使用doSome来处理some.do请求
     * 我们需要@RequsetMapping，请求映射，作用是把一个请求地址和一个方法绑定在一起。位置是在方法的上面
     * 属性：1.value：是一个string，是表示请求的url地址，value值是唯一的。在使用时，推荐地址以&quot;/&quot;开头(&quot;/&quot;表示是跟地址，&quot;/&quot;映射到工程路径)
     *  说明：
     *  使用@RequestMapping修饰的方法叫做处理器方法或者控制器方法，一个请求地址和一个方法绑定在一起
     *  使用@RequestMapping修饰的方法是可以处理请求的，类似于Servlet中的doGet、doPost方法
     *  （但是仍然要记住，DispatcherServlet才是接受请求，是中央调度器，Controller类是处理请求。）
     *
     * <span class="token keyword">@return</span> ModelAndView
     *  Model:数据，请求处理完成后要显示给用户的数据
     *  View：视图，比如jsp等等
     *  ModelAndView：表示本次处理请求的结果，包含数据和视图两部分
     */</span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;/some.do&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ModelAndView</span> <span class="token function">doSome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//处理请求--相当于service层即业务层调用处理完成</span>
        <span class="token class-name">ModelAndView</span> modelAndView <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 框架在请求的最后把数据（请求处理的结果）放入到request作用域，这个不需要我们做，我们只需要把请求处理的结果添加到modelAndView</span>
        modelAndView<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">&quot;msg&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;欢迎使用springmvc做web开发&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        modelAndView<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">&quot;fun&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;执行的是doSome()方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 指定视图，指定视图的完整路径</span>
        <span class="token comment">// 框架对视图执行的forward操作，request.getRequestDispatcher(&quot;/show.jsp&quot;).forward(request, response) ，框架做的，不需要我们写</span>
        modelAndView<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">&quot;/show.jsp&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>创建一个作为结果的jsp，显示请求的处理结果</p></li><li><p>创建springmvc的配置文件（和spring配置文件一样，要用注解方式进行依赖注入，必须要有一个组件扫描器）</p><ul><li><p><strong>声明组件扫描器，指定@Controller注解所在的包名</strong></p></li><li><p>声明视图解析器，帮助处理视图的。</p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token comment">&lt;!-- 声明视图解析器,帮助开发人员设置视图文件的路径--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefix<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/WEB-INF/view/<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>suffix<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>.jsp<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul></li></ol><p>注意：</p><ol><li><div class="language-text ext-text"><pre class="language-text"><code>声明：注册springmvc的核心对象DispatcherServlet
DispatcherServlet有一个作用是创建springmvc容器对象的，容器对象创建好了，那么容器里的声明的对象也都会随着容器对象的创建而创建好
所以DispatcherServlet要随着tomcat服务器的启动而创建
DispatcherServlet的实例化对象，需要在tomcat服务器启动后创建
为什么要创建DispatcherServlet实例化对象呢？
因为DispatcherServlet在创建过程中，会同时创建springmvc容器对象，会读取springmvc的配置文件，把这个配置文件中的对象都创建好，
当用户发起请求时，就可以直接使用对象了。

就像在spring中使用监听器来进行spring容器applicationContext的创建，因为要使spring容器只创建一次，并且在创建容器对象的过程中，会读取spring配置文件，配置文件读取完毕，这个配置文件里声明的所有对象也都创建好了，applicationContex存放在ServletContext中，能够拿到applicationContext，那么就能通过applicationContext拿到所有在spring配置文件里声明的对象。整个过程spring容器只创建一次，目的就是为了让spring容器对象是一个单例创建的模式。

而在整个地方，没有用到监听器，DispatcherServlet的作用就和监听器的作用差不多，因为，DispatcherServlet就是随着Tomcat服务器的启动而创建好，DispatcherServlet在创建过程中，会同时创建springmvc容器对象，会读取springmvc的配置文件，把这个配置文件中的对象都创建好。

整个思想和之前的监听器都是有联系的，差不多的。
</code></pre></div></li><li><p><img src="/study/assets/image-20210919150621163.bbafeab1.png" alt="image-20210919150621163"></p></li><li><p>控制器类能处理请求，但是控制器类只是相当于Servlet，但是控制器类不等于Servlet</p></li><li><p>DispatcherServlet也叫做前端控制器，自己写的控制器类也叫做后端控制器</p></li></ol><h3 id="springmvc请求的处理流程" tabindex="-1"><a class="header-anchor" href="#springmvc请求的处理流程" aria-hidden="true">#</a> springmvc请求的处理流程</h3><ol><li><p>用户发起请求。这个请求会发送给tomcat服务器</p></li><li><p>web.xml----url-pattern知道 *.do 的请求给DispatcherServlet</p><p>DispatcherServlet对象是随着Tomcat启动而创建好的</p><p>DispatcherServlet<strong>有一个作用就是创建springmvc容器对象</strong>，创建springmvc容器对象（容器对象创建好，那么配置文件就说明读取完毕，配置文件读取完毕，配置文件里声明的所有对象就创建好了。），就要读取springmvc配置文件，就能通过里面声明的组件扫描器，去对应的包下进行扫描。</p></li><li><p>根据springmvc.xml配置知道some.do---doSome()</p></li><li><p>DispatcherServlet把some.do请求转发给MyController的doSome()方法</p></li><li><p>框架执行doSome()，把得到ModelAndView进行处理，转发到show.jsp</p></li></ol><p><img src="/study/assets/image-20210919164639662.38b2d152.png" alt="image-20210919164639662"></p><h3 id="dispatcherservlet的作用" tabindex="-1"><a class="header-anchor" href="#dispatcherservlet的作用" aria-hidden="true">#</a> DispatcherServlet的作用</h3><ol><li><p>负责创建springmvc容器对象，读取springmvc的xml配置文件，创建文件中的controller对象。</p><p>创建容器对象，会读取配置文件，配置文件读取完毕，配置文件中声明的所有对象就创建好了。（如果是采用基于xml文件进行依赖注入的方式的话），通过注解也是一样，因为springmvc配置文件里会声明组件扫描器</p></li><li><p>负责<strong>接收</strong>用户的请求，<strong>分派</strong>给自定义的controller对象</p></li></ol><p>分析：</p><ol><li><p><img src="/study/assets/image-20210919170054085.2a66fc39.png" alt="image-20210919170054085"></p></li><li><p><img src="/study/assets/image-20210919171204648.c186de28.png" alt="image-20210919171204648"></p><p><img src="/study/assets/image-20220104183916856.93992c7e.png" alt="image-20220104183916856"></p><p><strong>doDispatch方法的里面，最终会调用我们的MyController的方法</strong></p></li><li><p><strong>创建springmvc容器对象，仍然是只创建一次，是单例的，放在ServletContext（全局作用域）中，通过ServletContext拿到容器对象，那么就可以拿到配置文件中声明的类的对象。</strong></p><p>ServletContext是随着Tomcat的启动而创建，随着Tomcat的结束而销毁</p></li><li><p>spring容器和springmvc容器都是放在ServletContext中</p></li></ol><h2 id="第2章-springmvc注解式开发" tabindex="-1"><a class="header-anchor" href="#第2章-springmvc注解式开发" aria-hidden="true">#</a> 第2章 SpringMVC注解式开发</h2><h3 id="requestmapping" tabindex="-1"><a class="header-anchor" href="#requestmapping" aria-hidden="true">#</a> @RequestMapping</h3><ol><li><p>把所有地址中，<strong>公用的部分</strong>放到类上面的@RequestMapping注解定义</p><p><img src="/study/assets/image-20210919182247070.3567124b.png" alt="image-20210919182247070"></p></li><li><p>@RequestMapping注解的属性</p><p><img src="/study/assets/image-20210919182437190.4279cf61.png" alt="image-20210919182437190"></p><p>若不指定请求方式，那么就没有限制。</p></li></ol><h3 id="接收用户提交的参数" tabindex="-1"><a class="header-anchor" href="#接收用户提交的参数" aria-hidden="true">#</a> 接收用户提交的参数</h3><h4 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h4><ol><li><p><img src="/study/assets/image-20210919190234487.a92cbab4.png" alt="image-20210919190234487"></p><p>上面的三种代表请求、应答和会话，spring框架会自动给他们赋值。</p><p><img src="/study/assets/image-20210919190342317.5d4fc335.png" alt="image-20210919190342317"></p></li><li><p>接收请求参数，使用的是控制器方法的形参</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>用户提交的数据 <ul><li>逐个参数接收</li><li>对象接收</li></ul></li></ul></li></ol><h4 id="逐个接收请求参数" tabindex="-1"><a class="header-anchor" href="#逐个接收请求参数" aria-hidden="true">#</a> 逐个接收请求参数</h4><p><strong>要求：控制器方法的形参名和请求中参数名必须一致，同名的请求参数赋值给同名的形参</strong></p><p>框架接收请求参数：</p><ol><li><p><strong>仍然是使用request对象接收请求参数，只不过是框架来做了，不用我们自己写了</strong></p><p><img src="/study/assets/image-20210919191148781.d9121321.png" alt="image-20210919191148781"></p></li><li><p>springmvc框架通过中央调度器DispatcherServlet调用MyController的doSome()方法，调用方法时，按参数名称对应，把接收的参数赋值给形参</p><p>框架会提供类型转换的功能，能把String转为int、long、float、double等类型</p></li><li><p>post请求中文需要解决乱码问题，get请求方式中文没有乱码（提交表单也可以用get方法，只是不安全，请求参数会显示在地址栏上。）</p><p><strong>需要使用过滤器解决post请求中文的乱码问题</strong></p><p>过滤器可以自定义，也可以使用框架提供的过滤器，过滤器：<strong>CharacterEncodingFilter</strong></p><div class="language-xml ext-xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>characterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--设置项目中使用的字符编码--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 强制请求对象HttpServletRequest使用encoding编码的值 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>forceRequestEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 强制响应对象HttpServletResponse使用encoding编码的值 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>forceResponseEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>characterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--/*表示强制所有的请求先通过过滤器处理--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>若请求中参数名和控制器方法的形参名不一样</p><p><img src="/study/assets/image-20210919200724445.2e150d89.png" alt="image-20210919200724445"></p><p><img src="/study/assets/image-20210920140127871.fba79dc3.png" alt="image-20210920140127871"></p><p>​</p></li></ol><h4 id="用一个对象来接收请求参数" tabindex="-1"><a class="header-anchor" href="#用一个对象来接收请求参数" aria-hidden="true">#</a> 用一个对象来接收请求参数</h4><ol><li><p>用对象来接收请求参数，属性来保存参数值</p><p><strong>要求属性名和请求中参数名一样！</strong></p></li><li><p><strong>控制器方法形参是Java对象，那么这个对象的属性名和请求中参数名是一样的，</strong></p><p><strong>框架会创建形参的Java对象，给属性赋值（ioc的set注入）</strong>，请求中的参数是name，那么对象的属性名也是name，框架会调用setName</p><p><strong>在ioc中，如果是采用注解的方式给属性赋值，就不需要属性的set方法，但不管是注解方式还是XML方式实现依赖注入，底层都是通过反射的机制，注解方式是不会用到set方法的，其中只有XML方式的set注入用到了属性的set方法</strong></p></li><li><p><strong>用对象来接收请求参数，就不需要用@RequestParam</strong></p></li><li><p>这种方式，controller方法的参数就相当于是<code>RequestBody</code></p></li></ol><h3 id="控制器方法的返回值" tabindex="-1"><a class="header-anchor" href="#控制器方法的返回值" aria-hidden="true">#</a> 控制器方法的返回值</h3><h4 id="返回modelandview" tabindex="-1"><a class="header-anchor" href="#返回modelandview" aria-hidden="true">#</a> 返回ModelAndView</h4><p><img src="/study/assets/image-20210919202649206.e6e9b2a9.png" alt="image-20210919202649206"></p><h4 id="返回string" tabindex="-1"><a class="header-anchor" href="#返回string" aria-hidden="true">#</a> 返回String</h4><ul><li><p><strong>返回的String代表逻辑视图名称，需要配置视图解析器</strong></p><p>控制器方法返回的字符串可以指定逻辑视图名，通过视图解析器解析可以将其转换为物理视图地址</p><p><strong>如果只是需要跳转页面，不需要返回数据，那么返回值类型用String是最方便的</strong></p><p>返回的字符串可以代表视图，可以是逻辑名称，也可以是完整的名称。</p><p><img src="/study/assets/image-20210919203342232.52e7bce3.png" alt="image-20210919203342232"></p><p><img src="/study/assets/image-20210919203954551.2c437c4f.png" alt="image-20210919203954551"></p></li><li><p><strong>返回的String代表完整视图名称，不能配置视图解析器</strong></p></li></ul><h4 id="返回void" tabindex="-1"><a class="header-anchor" href="#返回void" aria-hidden="true">#</a> 返回void</h4><ol><li><p>void返回值既不能表示数据，也不能表示视图-----这种返回值用于服务器处理ajax请求。</p><p>虽然void返回值既不能表示数据，也不能表示视图，但是可以通过HttpServletResponse的输出来完成响应。</p><p>若控制器对请求处理后，无需跳转到其他任何资源（资源就是指的工程路径后面的就叫资源路径，代表的就是资源），此时可以让控制器方法返回void</p><p>例如，对于AJAX的异步请求的响应</p><p>注意：不管是ajax请求还是表单请求，逐个接收请求参数和用一个对象来接收请求参数是完全一样的语法。</p><p><strong>返回值类型是void的时候，完全可以通过HttpServletResponse的输出来完成AJAX请求的异步响应</strong></p><p><strong>AJAX请求，服务器端返回的就是数据，和视图无关</strong></p><p><strong>ajax请求常用jQuery来发起请求</strong></p><p><img src="/study/assets/image-20220105155912701.7a086829.png" alt="image-20220105155912701"></p><p>此PrintWriter对象输出的内容json，就会被传递到前端jsp页面的ajax请求的success</p><p><img src="/study/assets/image-20220105160320190.962b5c7e.png" alt="image-20220105160320190"></p></li><li><p>完成ajax请求响应的步骤</p><ul><li>controller调用service处理请求</li><li>将请求的返回结果转为json格式的字符串</li><li>将json格式的字符串通过response得到的PrintWriter输出</li><li>输出的json格式字符串被jQuery转换为json对象</li></ul><p><img src="/study/assets/image-20220105161557655.ad8eb607.png" alt="image-20220105161557655"></p></li></ol><h4 id="返回对象object-需加-responsebody" tabindex="-1"><a class="header-anchor" href="#返回对象object-需加-responsebody" aria-hidden="true">#</a> 返回对象Object----需加@ResponseBody</h4><ol><li><p>概述</p><p><strong>返回对象代表的是数据，不是视图，而ajax请求正好要的就是数据，也跟视图无关，所以返回对象主要用来响应ajax请求</strong>，返回对象代表的是json数据，代表的是ajax请求的处理结果</p><p>返回的对象不是作为逻辑视图出现的，<strong>而是作为直接在页面显示的数据出现的。</strong></p><p>返回对象，需要使用@ResponseBody注解，<strong>将转换后的JSON数据放入到响应体中。</strong></p><p>@Controller + @ResponseBody = @RestController</p><p>返回的是对象，对象有属性，属性就是数据，所以返回Object表示数据（<strong>这里说的数据都是请求参数经过处理后的结果数据！！！结果数据才有返回的意义，返回的就是请求的处理结果。</strong>），和视图无关</p><p>可以使用对象表示的数据，<strong>响应ajax请求</strong></p></li><li><p>实现步骤：</p><ul><li><p>加入处理json的工具库的依赖，springmvc默认使用的jackson</p></li><li><p>在springmvc配置文件中加入<code>&lt;mvc:annotation-driven&gt;</code>注解驱动</p><p>代替我们自己完成 <code>json = om.writeValueAsString(student)</code></p><p>作用：把控制器方法返回的对象转为json格式的字符串</p></li><li><p><strong>在控制器方法的上面加入@ResponseBody</strong></p><p>作用：<strong>将json格式的字符串，通过HttpServletResponse输出给浏览器</strong></p><p>位置：方法的上面，和其他的注解没有顺序的先后关系</p><p>@ResponseBody注解相当于以下几行代码的作用</p><p><img src="/study/assets/image-20220105164452466.8784a7e2.png" alt="image-20220105164452466"></p></li></ul></li><li><p>在springmvc配置文件中加入<code>&lt;mvc:annotation-driven&gt;</code>注解驱动的原理</p><p>springmvc控制器方法返回<strong>Object，可以转为json</strong>输出到浏览器，响应ajax的内部原理</p><ul><li><p><code>&lt;mvc:annotation-driven&gt;</code>注解驱动</p><p>实现的功能是<strong>完成Java对象到json或xml或text等数据格式的转换</strong></p><p>HttpMessageConvert接口：消息转换器</p><p><strong><code>&lt;mvc:annotation-driven&gt;</code>注解驱动加入到springmvc配置文件后，会自动创建HttpMessageConvert接口的7个实现类对象</strong></p><p>功能：定义了Java对象转为json、xml等数据格式的方法，这个接口有很多的实现类</p><p>这些<strong>实现类完成Java对象到json或Java对象到xml等数据格式的转换</strong></p><ul><li><p>canWrite 判断能否转换成指定格式，默认转换成json</p><p><img src="/study/assets/image-20210920163153323.fbe5ba8d.png" alt="image-20210920163153323"></p><p><img src="/study/assets/image-20210920163451874.9f5b470c.png" alt="image-20210920163451874"></p></li><li><p>write 将Java对象转换成指定格式</p><p><img src="/study/assets/image-20210920163503962.c91a1d5b.png" alt="image-20210920163503962"></p></li></ul></li></ul></li><li><p>HttpMessageConvert接口的7个实现类</p><p><img src="/study/assets/image-20210920164452868.152d771f.png" alt="image-20210920164452868"></p><ul><li><p>MappingJackson2HttpMessageConverter</p><p>使用jackson工具库中的ObjectMapper<strong>实现Java对象转换为json格式字符串</strong>，转换后的JSON格式的数据放到响应体中</p></li><li><p>StringHttpMessageConverter</p><p>负责读取字符串格式的数据和写出字符串格式的数据</p></li></ul></li><li><p>控制器方法返回的是对象这种方式，框架的处理流程</p><ul><li><p>框架会把返回Student类型，调用框架中的<code>ArrayList&lt;HttpMessageConverter&gt;</code>集合中的<strong>每个类</strong>的<strong>canWrite</strong>方法，<strong>来检查哪个HttpMessageConverter接口的实现类能处理Student类型的数据</strong></p></li><li><p>框架会调用<strong>第一步找出来的实现类的write()</strong>，MappingJackson2HttpMessageConverter的<strong>write</strong>()方法</p><p>把student对象转为json，调用Jackson的ObjectMapper实现转为json格式的字符串</p></li><li><p><strong>框架会调用@ResponseBody把第二步的结果数据输出到浏览器，ajax请求处理完成</strong></p></li></ul></li><li><p>DispatcherServlet怎么分配请求给Controller的</p><ul><li>service方法</li><li>doService方法</li><li>doDispatch方法----会找到Controller类里的具体的方法，把请求交给那个方法执行，<strong>@RequestMapping让一个方法对应于一个地址</strong></li></ul></li><li><p>在项目中可能返回的不是一个Object，而是多个对象的集合<code>List&lt;Object&gt;</code></p><p>那么通过加入jackson依赖、添加注解驱动、添加@ResponseBody注解，也能得到<strong>json格式的字符串的数组</strong>！</p></li><li><p>返回<strong>字符串对象</strong></p><p>此时代表的就不是视图，代表的是数据</p><p>怎么区分String返回的字符串代表的视图还是数据，看有没有注解@ResponseBody</p><p><strong>如果有@ResponseBody注解，那么代表的是数据---字符串文本数据</strong></p><p><strong>如果没有@ResponseBody注解，代表的是视图</strong></p><p>注意：dataType要进行修改。</p><p><img src="/study/assets/image-20220105180230245.704c8aff.png" alt="image-20220105180230245"></p><p><img src="/study/assets/image-20210920175243206.002abab9.png" alt="image-20210920175243206"></p></li><li><p>控制器方法返回的是<strong>字符串对象</strong>这种方式，框架的处理流程</p><ul><li><p><strong>框架会把返回String类型，调用框架中的ArrayList&lt;HttpMessageConverter&gt;集合中的每个类的canWrite方法，来检查哪个HttpMessageConverter接口的实现类能处理String类型的数据</strong></p></li><li><p><strong>框架会调用第一步找出来的实现类的write()，StringHttpMessageConverter的write()方法</strong></p><p><strong>把String对象按照指定的编码来处理，即text/plain;charset=ISO-8859-1</strong></p></li><li><p><strong>框架会调用@ResponseBody把第二步的结果数据输出到浏览器，ajax请求处理完成</strong></p></li></ul></li></ol><h3 id="解读-url-pattern" tabindex="-1"><a class="header-anchor" href="#解读-url-pattern" aria-hidden="true">#</a> 解读<code>&lt;url-pattern/&gt;</code></h3><ol><li><p><img src="/study/assets/image-20210920181532578.686b43b4.png" alt="image-20210920181532578"></p><p>tomcat本身能处理静态资源的访问，像html、图片、js文件都是静态资源</p><p>tomcat的web.xml文件中有一个servlet，名称是default，在服务器启动时创建的！！</p><p><img src="/study/assets/image-20210920181757832.41bdba81.png" alt="image-20210920181757832"></p><p><img src="/study/assets/image-20210920183131910.feeceeb6.png" alt="image-20210920183131910"></p><p>这个地方的<code>/</code>表示静态资源和未映射的请求都给这个defaultServlet处理。</p></li><li><p>tomcat的default servlet的作用</p><p><img src="/study/assets/image-20210920181853129.9ba774cf.png" alt="image-20210920181853129"></p><ul><li><p><strong>处理静态资源</strong></p></li><li><p><strong>处理未映射到其他servlet的请求</strong></p><p>如果没有用springmvc来做web开发的话，在web.xml文件中会写很多servlet的类的声明和mapping（要么是通过web.xml来写，要么是通过注解，**这些servlet就和资源里比如jsp里的href对应上，或者表单的action对应上。不管是没使用springmvc时候的servlet类的地址还是使用springmvc的@RequestMapping的地址，都一定要和资源文件里的请求地址对应上！！！**意思就是点了超链接，或者提交了表单，就交给对应的servlet执行。servlet的作用就是接受请求、处理请求、返回请求），用了springmvc，只需要在web.xml里写中央调度器的声明和mapping，底层仍然是servlet。<strong>中央调度器DispatcherServlet会通过service、doService、doDispatch方法最终把对应的链接交给Controller的某个方法去执行！！</strong></p><p>没有使用springmvc时，web.xml里的url-pattern（就是servlet类的地址，也可以不写在web.xml里，通过注解也可以）要和资源文件的请求地址对应上</p><p>使用springmvc时，@RequestMapping的地址要和资源文件的请求地址对应上</p></li></ul></li><li><p>当我们的项目中的web.xml文件中的url-pattern用了<code>/</code>，那么它会替代tomcat的default servlet，对静态资源和未映射到servlet的请求进行处理</p><p>导致所有的静态资源都给DispatcherServlet处理，默认情况下，DispatcherServlet没有处理静态资源的能力，没有控制器对象能处理静态资源的访问，所以静态资源都是404</p></li><li><p>那么既要在&lt;url-pattern&gt;用<code>/</code>，又想处理静态资源，有两种方式。</p><ul><li><p>使用<code>&lt;mvc:default-servlet-handler/&gt;</code></p><p><strong>声明了<code>&lt;mvc:default-servlet-handler/&gt;</code>之后，springmvc框架会在容器中创建DefaultServletHttpRequestHandler处理器对象，它会像一个检察员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，一般的服务器都有默认的Servlet</strong></p><p><strong>Tomcat中，专门用于处理静态资源访问的Servlet名叫DefaultServlet</strong></p><p><img src="/study/assets/image-20210920222737796.c1095b11.png" alt="image-20210920222737796"></p><p><code>&lt;mvc:default-servlet-handler/&gt;</code>这个配置和之前的@RequestMapping有冲突，需要加入注解驱动来解决冲突:<code>&lt;mvc:annotation-driven&gt;</code></p></li><li><p>使用<code>&lt;mvc:resources/&gt;</code></p><p>**spring定义了专门用于处理静态资源访问请求的处理器ResourceHttpRequestHandler，**并且添加了&lt;<code>mvc:resources/</code>&gt;标签，专门用于解决静态资源无法访问的问题，需要在springmvc配置文件中添加如下形式的配置</p><p><img src="/study/assets/image-20210920225628379.a811029b.png" alt="image-20210920225628379"></p><p><strong>和第一种方式区别是，不依赖于tomcat服务器的默认的DefaultServlet来完成静态资源的处理</strong>，也就是不需要DefaultServletHttpRequestHandler来筛查url即把静态资源仍然分配给tomcat的DefaultServlet来进行处理，<strong>这种方式就由我们自己的处理器来进行处理</strong></p><p><img src="/study/assets/image-20210920230143754.3d2367af.png" alt="image-20210920230143754"></p><p><img src="/study/assets/image-20220105200647952.997d7e2d.png" alt="image-20220105200647952"></p><p><code>&lt;mvc:resources/&gt;</code>这个配置和之前的@RequestMapping有冲突，需要加入注解驱动来解决冲突:<code>&lt;mvc:annotation-driven&gt;</code></p></li></ul></li><li><p><code>&lt;mvc:annotation-driven&gt;</code>作用</p><div class="language-text ext-text"><pre class="language-text"><code>1. 将返回对象转换为json、xml、txt等格式，用于响应ajax请求。
2.解决静态资源访问，静态资源访问会添加另外的配置，而另外的配置会和@RequestMapping冲突，所以必须加上这个注解。（冲突是动态请求也会交给处理静态资源的servlet处理，加上之后，保证静态资源给对应的处理器处理，比如DefaultServlet或者spring定义的ResourceHttpRequestHandler，保证动态资源扔给之前的DispatcherServlet处理）
</code></pre></div></li><li><p>使用一个配置语句，指定多种静态资源的访问：即静态资源统一放在一个目录下即static。</p><p><img src="/study/assets/image-20220105201211270.1f2aef8f.png" alt="image-20220105201211270"></p></li></ol><h3 id="访问地址" tabindex="-1"><a class="header-anchor" href="#访问地址" aria-hidden="true">#</a> 访问地址</h3><ol><li><p>html文件或jsp文件中的访问地址或请求地址</p><ul><li>前面不加斜杠，在浏览器地址栏中映射到<code>ip地址:端口号/项目名/</code></li><li>前面加斜杠，在浏览器地址栏中映射到<code>ip地址:端口号/</code></li></ul></li><li><p>所以最好保证工程路径永远是一致的，即使用以下两种方式</p><ul><li><p>开头不加斜杠，配合base标签</p><p><img src="/study/assets/image-20210921001040805.943686c2.png" alt="image-20210921001040805"></p></li><li><p>开头加斜杠，但是在前面加EL表达式</p><p><img src="/study/assets/image-20210920235208614.255f4d78.png" alt="image-20210920235208614"></p></li></ul><p>两种方式在开头都没有单纯地加斜杠，但是却保证了访问的参考地址！！</p><p><img src="/study/assets/image-20210921000533055.7dab9109.png" alt="image-20210921000533055"></p></li></ol><h2 id="第3章-ssm整合开发" tabindex="-1"><a class="header-anchor" href="#第3章-ssm整合开发" aria-hidden="true">#</a> 第3章 SSM整合开发</h2><h3 id="概述-2" tabindex="-1"><a class="header-anchor" href="#概述-2" aria-hidden="true">#</a> 概述</h3><ol><li><p>SpringMVC: 视图层、界面层，负责接受请求，显示处理结果的。</p><p>spring：业务层，管理service、dao、工具类对象的</p><p>mybatis：持久层，访问数据库的</p></li><li><p>用户发起请求--springmvc接收请求----请求给spring的service实现类对象进行处理-----service对象调用dao，通过mybatis访问数据库，处理数据</p></li><li><p>整合中有容器</p><ul><li>第一个容器SpringMVC容器，管理Controller控制器对象</li><li>第二个容器是spring容器，管理service、dao、工具类对象的</li></ul><p>我们要做的是把使用的对象交给合适的容器创建、管理，把Controller还有web开发的相关对象交给springmvc容器，<strong>这些web用的对象写在springmvc配置文件中</strong></p><p><strong>把service、dao对象定义在spring的配置文件中</strong>，让spring管理这些对象</p><p>这两个容器对象的职责不同，两个容器是独立的</p><p>那么两个容器中的对象怎么互相访问到呢？</p><p>比如Controller对象怎么访问service对象呢？一个容器中的对象怎么访问到另一个容器中的对象呢？</p><p>如果两个容器没有任何的关联肯定不行，所以这两个容器存在关系</p></li><li><p>springmvc容器和spring容器是有关系的，他们的关系已经确定好了，不需要人为去做</p><p>springmvc容器是spring容器的子容器，类似Java中的继承</p><p>子可以访问父的内容。</p><p>在子容器中的Controller可以访问父容器中的Service对象，就可以实现controller使用service对象。</p><p>这个整合开发，已经把这个关系确定好了，我们只需要确定对应的对象创建要放在对应的容器中。</p></li></ol><h3 id="整合开发步骤" tabindex="-1"><a class="header-anchor" href="#整合开发步骤" aria-hidden="true">#</a> 整合开发步骤</h3><ol><li><p>新建maven项目</p></li><li><p>加入依赖</p><p>springmvc、spring、mybatis三个框架的依赖，jackson依赖，mysql驱动，druid连接池、jsp、servlet依赖</p></li><li><p>写web.xml</p><ul><li><p>注册DispatcherServlet中央调度器，目的是</p><ul><li>创建springmvc容器对象，于是就创建好了springmvc容器中的所有对象</li><li>用于接收用户请求，把请求分配给Controller去执行</li></ul></li><li><p>注册spring的监听器：ContextLoaderListener，目的：</p><ul><li><p>创建spring的容器对象，通过监听器结合ServletContext这个作用域，能够实现spring容器对象的单例创建</p><p>监听器的作用：因为ServletContext是随着tomcat的启动而创建，随着tomcat的结束而销毁，监听器可以监听到全局作用域ServletContext的创建，监听到之后，那么就创建spring容器对象，并把spring容器对象放进ServletContext全局作用域</p></li></ul></li><li><p>注册字符集过滤器：解决post请求乱码的问题</p></li></ul></li><li><p>创建包，Controller包，service、dao、实体类包名创建好</p></li><li><p>写springmvc、spring、mybatis的配置文件</p><ul><li>springmvc配置文件</li><li>spring配置文件</li><li>mybatis主配置文件</li><li>数据库的属性配置文件</li></ul></li><li><p>写代码，dao接口（不用写dao实现类），service接口和service实现类（类是要写的，对象是交给容器创建的。）controller，实体类</p></li><li><p>写jsp页面</p></li></ol><h2 id="第4章-springmvc核心技术" tabindex="-1"><a class="header-anchor" href="#第4章-springmvc核心技术" aria-hidden="true">#</a> 第4章 SpringMVC核心技术</h2><h3 id="请求重定向和转发" tabindex="-1"><a class="header-anchor" href="#请求重定向和转发" aria-hidden="true">#</a> 请求重定向和转发</h3><ol><li><p>在javaweb中请求转发和请求重定向的区别</p><ul><li>请求转发只有一次请求，请求重定向是两次请求</li><li>请求重定向的地址栏的url会发生变化，而请求转发不会</li><li>请求重定向不会共享Request域的数据，而请求转发是共享request域的数据，因为tomcat，会把每一次请求都封装到request域中，请求转发能够共享，正是因为只有一次请求，而请求重定向不可以共享，是因为是两次请求</li><li><strong>请求重定向不能访问WEB-INF目录下的资源</strong>，而请求转发可以！</li><li>请求重定向可以访问外部资源，而请求转发不可以</li></ul><p><img src="/study/assets/image-20210921154408642.f9e369bc.png" alt="image-20210921154408642"></p></li><li><p>springmvc框架把原来servlet中的请求转发和重定向操作进行了封装，现在可以使用简单的方式实现转发和重定向</p><p><strong>forward：表示转发，实现request.getRequestDispatcher(&quot;xx.jsp&quot;).forward(request，response);</strong></p><p><strong>redirect:表示重定向，实现response.sendRedirect(&quot;xxx.jsp&quot;)</strong></p><p>他们有一个共同的特点：就是不和视图解析器一起工作，就当项目中没有视图解析器一样</p></li><li><p>forward：</p><p><img src="/study/assets/image-20220105213801557.e5311a3b.png" alt="image-20220105213801557"></p><p><img src="/study/assets/image-20210921155010180.16a85e10.png" alt="image-20210921155010180"></p><p>setViewName()方法的形参这样写，这种方式叫显式转发</p></li><li><p>redirect</p><p><img src="/study/assets/image-20210921155520211.0719a985.png" alt="image-20210921155520211"></p><ul><li><p>框架会把Model中的简单类型的数据，转为String使用，作为hello.jsp的get请求参数使用</p><p>目的是在doRedirect.do和hello.jsp两次请求之间传递数据</p><p><img src="/study/assets/image-20210921160111005.590da383.png" alt="image-20210921160111005"></p></li><li><p>在目标hello.jsp页面可以使用参数集合对象${param}获取请求参数值</p><p>请求重定向这种方式，直接通过EL表达式${参数名}这种方式取不到，因为是两次请求，是不同的request域。但是在重定向后的URL地址上有请求的参数，那么可以通过以下方式取</p><p><img src="/study/assets/image-20210921160602922.e1c4fed8.png" alt="image-20210921160602922"></p></li></ul></li></ol><h3 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h3><h4 id="概述-3" tabindex="-1"><a class="header-anchor" href="#概述-3" aria-hidden="true">#</a> 概述</h4><ol><li><p>springmvc框架处理异常的常用方式---统一全局异常处理---aop思想</p><p><strong>这样的话可以不写try-catch代码，让try-catch代码和我们的业务分离，解耦合，让方法里面只保留业务逻辑代码，让异常放到一个统一的地方处理，用的思想就是AOP，业务功能和非业务功能的解耦合！！</strong></p><p>叫做统一全局异常处理方案</p><p>把controller的所有异常处理都集中到一个地方</p></li><li><p>使用两个注解</p><ul><li>@ExceptionHandler</li><li>@ControllerAdvice</li></ul></li></ol><h4 id="异常处理步骤" tabindex="-1"><a class="header-anchor" href="#异常处理步骤" aria-hidden="true">#</a> 异常处理步骤</h4><ol><li><p>新建maven web项目</p></li><li><p>加入依赖</p></li><li><p>新建一个自定义异常类，MyUserException，再定义它的子类NameException，AgeException</p></li><li><p>在controller抛出NameException，AgeException，抛出之后，就可以处理异常了</p></li><li><p><strong>创建一个普通类，作为全局异常处理类</strong></p><ul><li><strong>在类的上面加入@ControllerAdvice</strong></li><li><strong>在类中定义方法，方法上面加入@ExceptionHandler</strong></li></ul></li><li><p>创建处理异常的视图页面</p></li><li><p>创建springmvc的配置文件</p><ul><li>组件扫描器，扫描@Controller注解</li><li><strong>组件扫描器，扫描@ControllerAdvice注解所在的包</strong></li><li>声明注解驱动！！---两个作用 <ul><li>返回对象Object的时候，将对象进行格式的转换，添加了这个注解驱动就会创建一个接口，接口有7个实现类，<strong><code>&lt;mvc:annotation-driven&gt;</code>注解驱动加入到springmvc配置文件后，会自动创建HttpMessageConverter接口的7个实现类对象，并且会将Java对象转换为json、xml、txt等格式的字符串</strong></li><li>解决静态资源访问问题的两种方式会和@RequestMapping产生冲突，需要这个注解驱动来解决</li></ul></li></ul></li><li><p>如图：</p><p><img src="/study/assets/image-20210921165533405.1ea01b00.png" alt="image-20210921165533405"></p><p><img src="/study/assets/image-20210921165714849.a735a846.png" alt="image-20210921165714849"></p><p>方法体里，对异常的处理逻辑：</p><ol><li><p>需要把异常记录下来，记录到数据库、日志文件</p><p>记录异常发生的事件，哪个方法发生的，异常错误内容。</p></li><li><p>发送通知，把异常的信息通过邮件、短信或微信发送给相关人员</p></li><li><p>给用户友好的提示</p></li></ol></li></ol><h3 id="拦截器" tabindex="-1"><a class="header-anchor" href="#拦截器" aria-hidden="true">#</a> 拦截器</h3><h4 id="概述-4" tabindex="-1"><a class="header-anchor" href="#概述-4" aria-hidden="true">#</a> 概述</h4><ol><li><p>拦截器必须实现接口HandlerInterceptor</p></li><li><p>过滤器是过滤请求参数的，拦截器是拦截请求的，对请求做预先的判断处理工作</p></li><li><p>拦截器是springmvc中的一种对象，需要实现HandlerInterceptor接口</p><p>拦截器和过滤器类似，功能方向侧重点不同，</p><ul><li>过滤器是用来过滤请求参数，设置编码字符集等工作</li><li>拦截器是拦截用户的请求，做请求的判断处理的</li></ul></li><li><p>拦截器的特点：</p><p>是全局的，可以对多个Controller做拦截</p><p>一个项目中可以有0个或多个拦截器，他们在一起拦截用户的请求</p><p>拦截器常用在用户的登陆处理，权限的检查，记录日志方面</p></li><li><p>我们需要定义类实现HandlerInterceptor接口</p><p>需要在springmvc配置文件中声明拦截器，让springmvc框架知道拦截器的存在</p></li><li><p>拦截器的执行时间:</p><ul><li>在请求处理之前，也就是Controller类中的方法执行之前先被拦截（首次执行时间）</li><li>在控制器方法执行之后，也会执行拦截器</li><li>在<strong>请求处理完成后</strong>也会执行拦截器</li></ul></li></ol><h4 id="拦截器的使用步骤" tabindex="-1"><a class="header-anchor" href="#拦截器的使用步骤" aria-hidden="true">#</a> 拦截器的使用步骤</h4><ol><li><p>新建maven web项目</p></li><li><p>加入依赖</p></li><li><p>创建Controller类</p></li><li><p><strong>创建一个普通类，作为拦截器使用</strong></p><ul><li><strong>实现HandlerInterceptor接口</strong></li><li><strong>实现接口中的三个方法</strong></li></ul></li><li><p>创建show.jsp结果页面</p></li><li><p>创建springmvc配置文件</p><ul><li><p>组件扫描器，扫描@Controller注解</p></li><li><p><strong>声明拦截器，并指定拦截的请求uri地址</strong></p><p><img src="/study/assets/image-20210921174059063.559abe02.png" alt="image-20210921174059063"></p></li></ul></li></ol><h4 id="handlerinterceptor接口的三个方法" tabindex="-1"><a class="header-anchor" href="#handlerinterceptor接口的三个方法" aria-hidden="true">#</a> HandlerInterceptor接口的三个方法</h4><ol><li><p><code>preHandle(HttpServletRequest request,HttpServletResponse response,Object handler)</code></p><p>预处理方法</p><p>这个方法很重要，是整个项目的入口、门户</p><p>参数：<code>HttpServletRequest request,HttpServletResponse response,Object handler</code></p><ul><li><strong>Object handler: 被拦截的控制器对象，也就是Controller类的对象</strong></li></ul><p>返回值：boolean</p><ul><li>true：表示请求通过了拦截器的验证，可以执行控制器类的方法</li><li>false：请求没有通过拦截器的验证，请求到达拦截器就截止了，请求没有被处理</li></ul><p>特点：</p><ul><li><p>方法在控制器类的方法执行之前先执行的</p><p>用户的请求首先到达此方法</p></li><li><p>在这个方法中可以获取请求的信息，验证请求是否符合要求</p><p>可以验证用户是否登录，验证用户是否有权限去访问某个链接地址（url）</p><p>如果验证失败，我们可以截断请求，这个请求不能被处理也就是不能到达控制器类的方法</p><p>如果验证成功，可以放行请求，此时控制器方法才能执行</p></li></ul><p>示例：</p><p><img src="/study/assets/image-20220106173346685.20a3dcca.png" alt="image-20220106173346685"></p></li><li><p><code>postHandle(HttpServletRequest request,HttpServletResponse response,Object handler, ModelAndView modelAndView)</code></p><p>后处理方法</p><p>参数：</p><ul><li><strong>Object handler: 被拦截的控制器对象，也就是Controller类的对象</strong></li><li><strong>ModelAndView modelAndView：是控制器类的方法的返回值</strong></li></ul><p>特点：</p><ul><li><strong>在处理器类的方法之后执行的。</strong></li><li><strong>能够获取到处理器方法的返回值ModelAndView，可以修改modelAndView中的数据和视图，可以影响到最后的执行结果</strong></li><li>主要对原来的执行结果做二次修正。</li></ul></li><li><p><code>afterComletion(HttpServletRequest request,HttpServletResponse response,Object handler, Exception ex)</code></p><p><strong>最后执行的方法，视图处理完成后，即请求处理完成后，给出的响应</strong></p><p>参数：</p><ul><li><strong>Object handler: 被拦截的控制器对象，也就是Controller类的对象</strong></li><li><strong>Exception ex：程序中发生的异常</strong></li></ul><p>特点：</p><ul><li><strong>在请求处理完成后执行的</strong>，框架中<strong>规定是当视图处理完成后</strong>，对视图执行了forward，就认为请求处理完成</li><li>一般做资源回收工作的。比如程序请求过程中，创建了一些对象，在这里可以删除，把占用的内存回收</li></ul></li><li><p>拦截器看作是多个Controller中共用的功能（比如用户是否登录），集中到拦截器统一处理，仍然是aop的思想！！</p></li><li><p>一个拦截器的三个方法的执行顺序</p><p><img src="/study/assets/image-20210921183533644.43bd27af.png" alt="image-20210921183533644"></p></li></ol><h4 id="多个拦截器的三个方法执行顺序" tabindex="-1"><a class="header-anchor" href="#多个拦截器的三个方法执行顺序" aria-hidden="true">#</a> 多个拦截器的三个方法执行顺序</h4><ol><li><p>在框架中保存多个拦截器是ArrayList</p><p>按照<strong>声明的先后顺序</strong>放入到ArrayList，先声明的先执行，后声明的后执行。</p><p>两个拦截器，</p><ul><li><p><strong>第一个拦截器的preHandle方法返回true，第二个拦截器的preHandle也返回true</strong>，执行顺序如下</p><p><img src="/study/assets/image-20210921184133610.2edc8895.png" alt="image-20210921184133610"></p><p><img src="/study/assets/image-20210921184311653.2efc74bf.png" alt="image-20210921184311653"></p></li><li><p>第一个拦截器preHandle=true，第二个拦截器preHandle=false</p><p><img src="/study/assets/image-20210921185032302.16d72f7b.png" alt="image-20210921185032302"></p></li><li><p>第一个拦截器preHandle=false，第二个拦截器preHandle=true或false对结果没有任何影响</p><p><img src="/study/assets/image-20210921185147330.dbd304f0.png" alt="image-20210921185147330"></p></li></ul></li><li><p><img src="/study/assets/image-20210921184643169.39d779cf.png" alt="image-20210921184643169"></p></li><li><p><strong>不管有几个拦截器，只要其中一个拦截器的preHandle方法返回了false，控制器方法一定不会执行！</strong></p></li><li><p>我们可以有多个拦截器，每个拦截器负责不同的功能，比如第一个拦截器验证登录，第二个验证功能的用户，第三个拦截器记录用户的访问日志。</p></li></ol><h4 id="拦截器和过滤器的区别" tabindex="-1"><a class="header-anchor" href="#拦截器和过滤器的区别" aria-hidden="true">#</a> 拦截器和过滤器的区别</h4><ol><li><p>过滤器是servlet中的对象（是servlet的三大组件之一），拦截器是框架（springmvc）中的对象</p></li><li><p>过滤器是实现Filter接口的，拦截器是实现HandlerInterceptor接口</p></li><li><p>过滤器是用来设置request，response的参数，属性的，侧重对数据过滤的（<strong>过滤器可以解决post请求中文乱码的问题</strong>）</p><p>拦截器是用来验证请求的，能截断请求</p></li><li><p><strong>过滤器是在拦截器之前先执行的</strong></p></li><li><p>过滤器是tomcat服务器创建的对象</p><p>拦截器是springmvc容器中创建的对象</p></li><li><p>过滤器是一个执行时间点</p><p>拦截器有三个执行时间点</p></li><li><p>过滤器可以处理jsp、js、html等等</p><p><strong>拦截器是侧重拦截对Controller的对象，如果请求不能被DispatcherServlet接收，这个请求不会执行拦截器内容</strong></p></li></ol><h3 id="springmvc内部请求的处理流程" tabindex="-1"><a class="header-anchor" href="#springmvc内部请求的处理流程" aria-hidden="true">#</a> springmvc内部请求的处理流程</h3><ol><li><p>springmvc内部请求的处理流程也就是springmvc接收请求，到处理完成的过程</p></li><li><p>步骤</p><ul><li><p>用户发起请求some.do</p></li><li><p>DispatcherServlet接收请求some.do，<strong>把请求转发给处理器映射器</strong></p><p>处理器映射器：springmvc框架中的一种对象，框架把实现了HandlerMapping接口的类叫做处理器映射器（多个），处理器映射器就是实现了HandlerMapping接口的类，每一个类都有它对应的能够处理的请求</p><p><strong>处理器映射器作用：根据请求，从springmvc容器对象中获取处理器对象</strong></p><p>类似于spring框架中，这个功能：</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplication</span><span class="token punctuation">(</span><span class="token string">&quot;bean.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StudentService</span> studentService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">StudentService</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;service&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>框架把找到的处理器对象放到一个叫做处理器执行链的类保存</p><p>处理器执行链：HandlerExecutionChain</p><p>HandlerExecutionChain：类中保存着</p><ul><li>处理器对象</li><li>项目中所有的拦截器（用的是List集合）</li></ul></li><li><p>DispatcherServlet把HandlerExecutionChain中的处理器对象，交给处理器适配器对象（多个）</p><p>处理器适配器：springmvc框架中的对象，需要实现HandlerAdapter接口</p><p><strong>处理器适配器作用：执行处理器方法即控制器类中的方法，得到返回值</strong></p></li><li><p>DispatcherServlet把上一步获取的<strong>ModelAndView（返回值）交给了视图解析器对象</strong></p><p>视图解析器：springmvc中的对象，需要实现ViewResolver接口（可以有多个）</p><p>视图解析器作用：组成视图完整路径，使用前缀、后缀，并<strong>创建View对象</strong></p><p><img src="/study/assets/image-20220106192731365.4eec5c14.png" alt="image-20220106192731365"></p><p>比如上图这个&quot;show&quot;在框架中就会被转成View对象。</p><p>View是一个接口，表示视图的，在框架中jsp、html不是string表示，<strong>而是使用View和它的实现类表示视图</strong></p><p>InternalResourceView：视图类，表示jsp文件，视图解析器会创建InternalResourceView对象</p><p>这个对象里面，有一个属性url=xxx</p></li><li><p><strong>DispatcherServlet把上一步创建的View接口的实现类对象获取到</strong>，调用View类自己的方法，把Model数据放入到Request作用域，执行对象视图的forward，请求结束</p></li></ul></li><li><p>总结：</p><ul><li>处理器映射器--得到Controller对象</li><li>处理器执行链--得到Controller对象放入其中</li><li>处理器适配器--执行Controller对象的方法--service()、doService()、doDispatch()、处理器方法</li><li>视图解析器--DispatcherServlet将返回的ModelAndView对象交给视图解析器，创建view对象</li><li>view对象--DispatcherServlet调用View类自己的方法，把Model数据放入到Request作用域，执行对象视图的forward，请求结束</li></ul></li><li><p>处理器映射器：获取处理器对象</p><p>处理器适配器：执行控制器类的方法</p></li><li><p><img src="/study/assets/image-20210921202019817.4ba844df.png" alt="image-20210921202019817"></p></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.aa278c57.js" defer></script>
  </body>
</html>
