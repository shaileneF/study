<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>一些原理 | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.f43a1e4d.js"><link rel="modulepreload" href="/study/assets/springboot.html.63b4c4a9.js"><link rel="modulepreload" href="/study/assets/springboot.html.1ffeb183.js"><link rel="prefetch" href="/study/assets/index.html.9c083efe.js"><link rel="prefetch" href="/study/assets/index.html.e75ce288.js"><link rel="prefetch" href="/study/assets/index.html.52a49423.js"><link rel="prefetch" href="/study/assets/index.html.fa8911f9.js"><link rel="prefetch" href="/study/assets/index.html.afe798d4.js"><link rel="prefetch" href="/study/assets/index.html.01c0ba84.js"><link rel="prefetch" href="/study/assets/设计模式1.html.b402e4ef.js"><link rel="prefetch" href="/study/assets/设计模式2.html.1d90a7e9.js"><link rel="prefetch" href="/study/assets/gin.html.c5cf5acf.js"><link rel="prefetch" href="/study/assets/golang.html.65f256a2.js"><link rel="prefetch" href="/study/assets/gorm.html.fef376ce.js"><link rel="prefetch" href="/study/assets/Javaweb.html.64c9d7f7.js"><link rel="prefetch" href="/study/assets/ES.html.9a88ded3.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.40600d8d.js"><link rel="prefetch" href="/study/assets/Java笔记.html.08dc1c9e.js"><link rel="prefetch" href="/study/assets/dubbo.html.643ff7df.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.a654ce2e.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.83a96eaa.js"><link rel="prefetch" href="/study/assets/zookeeper.html.24b3442a.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.8f02eb19.js"><link rel="prefetch" href="/study/assets/并发编程.html.56d5a1a7.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.c9129948.js"><link rel="prefetch" href="/study/assets/redis.html.6e98fd4c.js"><link rel="prefetch" href="/study/assets/Mybatis.html.58fd9986.js"><link rel="prefetch" href="/study/assets/spring.html.2c3e4435.js"><link rel="prefetch" href="/study/assets/springboot.html.a26758ad.js"><link rel="prefetch" href="/study/assets/springMVC.html.1b9d8760.js"><link rel="prefetch" href="/study/assets/kafka.html.8e3fefb4.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.23d2b8fd.js"><link rel="prefetch" href="/study/assets/操作系统.html.2a878574.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.ce927195.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.d44048ee.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.823b33ea.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.3d93746f.js"><link rel="prefetch" href="/study/assets/index.html.6e91e8d3.js"><link rel="prefetch" href="/study/assets/index.html.d121f689.js"><link rel="prefetch" href="/study/assets/index.html.762c48bc.js"><link rel="prefetch" href="/study/assets/index.html.12e6779b.js"><link rel="prefetch" href="/study/assets/index.html.9594f0d8.js"><link rel="prefetch" href="/study/assets/设计模式1.html.b182cfd6.js"><link rel="prefetch" href="/study/assets/设计模式2.html.50862454.js"><link rel="prefetch" href="/study/assets/gin.html.df126617.js"><link rel="prefetch" href="/study/assets/golang.html.e48c73c0.js"><link rel="prefetch" href="/study/assets/gorm.html.0416ada2.js"><link rel="prefetch" href="/study/assets/Javaweb.html.aea5b1d4.js"><link rel="prefetch" href="/study/assets/ES.html.239cc44d.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.0b9855a2.js"><link rel="prefetch" href="/study/assets/Java笔记.html.68072a4d.js"><link rel="prefetch" href="/study/assets/dubbo.html.0cb943f5.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.b7327e57.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.a7c43ca4.js"><link rel="prefetch" href="/study/assets/zookeeper.html.995eea49.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.0e221844.js"><link rel="prefetch" href="/study/assets/并发编程.html.54e02776.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.0fc8ea0d.js"><link rel="prefetch" href="/study/assets/redis.html.67410002.js"><link rel="prefetch" href="/study/assets/Mybatis.html.9ec7529f.js"><link rel="prefetch" href="/study/assets/spring.html.e8f3ebdb.js"><link rel="prefetch" href="/study/assets/springboot.html.aeecc737.js"><link rel="prefetch" href="/study/assets/springMVC.html.755f8456.js"><link rel="prefetch" href="/study/assets/kafka.html.55bce78d.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.7e4fc9bf.js"><link rel="prefetch" href="/study/assets/操作系统.html.8cbfe7c7.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.2685a963.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.ca9f6a21.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.95d7acb4.js"><link rel="prefetch" href="/study/assets/404.html.629e2199.js"><link rel="prefetch" href="/study/assets/404.20d28144.js"><link rel="prefetch" href="/study/assets/Layout.9b3340db.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">一些原理 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#基础入门" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础入门"><!--[--><!--]--> 基础入门 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#spring与springboot" class="router-link-active router-link-exact-active sidebar-item" aria-label="spring与springboot"><!--[--><!--]--> spring与springboot <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#微服务" class="router-link-active router-link-exact-active sidebar-item" aria-label="微服务"><!--[--><!--]--> 微服务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#了解自动配置原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="了解自动配置原理"><!--[--><!--]--> 了解自动配置原理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#依赖管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="依赖管理"><!--[--><!--]--> 依赖管理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#自动配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="自动配置"><!--[--><!--]--> 自动配置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#容器功能和注解" class="router-link-active router-link-exact-active sidebar-item" aria-label="容器功能和注解"><!--[--><!--]--> 容器功能和注解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#配置绑定javabean" class="router-link-active router-link-exact-active sidebar-item" aria-label="配置绑定JavaBean"><!--[--><!--]--> 配置绑定JavaBean <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#自动配置原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="自动配置原理"><!--[--><!--]--> 自动配置原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#开发小技巧" class="router-link-active router-link-exact-active sidebar-item" aria-label="开发小技巧"><!--[--><!--]--> 开发小技巧 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#核心功能-web开发" class="router-link-active router-link-exact-active sidebar-item" aria-label="核心功能-web开发"><!--[--><!--]--> 核心功能-web开发 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#静态资源请求" class="router-link-active router-link-exact-active sidebar-item" aria-label="静态资源请求"><!--[--><!--]--> 静态资源请求 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#静态资源配置原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="静态资源配置原理"><!--[--><!--]--> 静态资源配置原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%A1%86%E6%9E%B6/springboot%E5%8E%9F%E7%90%86/springboot.html#欢迎页支持" class="router-link-active router-link-exact-active sidebar-item" aria-label="欢迎页支持"><!--[--><!--]--> 欢迎页支持 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="一些原理" tabindex="-1"><a class="header-anchor" href="#一些原理" aria-hidden="true">#</a> 一些原理</h1><h2 id="基础入门" tabindex="-1"><a class="header-anchor" href="#基础入门" aria-hidden="true">#</a> 基础入门</h2><h3 id="spring与springboot" tabindex="-1"><a class="header-anchor" href="#spring与springboot" aria-hidden="true">#</a> spring与springboot</h3><ol><li><p>一个项目或者说大型应用，功能模块众多，我们应该把一个大的项目拆分成一个一个微小的功能模块，每一个微小的功能模块我们称之为一个微服务，spring就可以快速地帮我们创建和开发一个微服务</p></li><li><p>为什么用springboot</p><p>springboot能快速创建出生产级别的spring应用，让开发变得简单</p></li><li><p>springboot的优点</p><ul><li><p>创建独立spring应用</p></li><li><p>内嵌web服务器（嵌入式的内部容器tomcat、jetty等）</p><p>以前要开发web应用，这个web应用最终会被打包成一个war包，这个war包最终会被部署到tomcat上，所以我们的环境还得装tomcat，还要部署tomcat，自己下载，或者通过IDEA下载配置。</p><p>而通过springboot进行web开发，目标环境即使没有tomcat也没有关系，我们创建的应用里面已经带了tomcat服务器，<strong>已经集成了。</strong></p></li><li><p>自动starter依赖，<strong>简化构建配置</strong></p><p>以前依赖的jar包的版本必须控制好，都是自己去控制、添加依赖，现在springboot给我们<strong>提供了starter启动器</strong>，假如我们想要开发web应用，我们只需要添加一个web的启动器依赖，不需要管理其他web开发需要的jar包，springboot自动管理jar包，并且保证jar包的版本</p></li><li><p>自动配置spring以及第三方功能</p><p><strong>不用像以前整合mybatis、spring、springmvc要写一大堆配置</strong></p><p>这些配置现在springboot自动配置</p><p>专注我们的业务逻辑</p></li><li><p>提供生产级别的监控、健康检查及外部化配置</p></li><li><p>无代码生成，<strong>无需编写xml</strong>（自动化配置，我们不需要写一大堆配置。并且不需要写配置不是说springboot给我们自动生成那些配置文件，没有任何代码生成，就是基于spring底层的装配和依赖注入功能）</p></li></ul><p>总结：<strong>自动配置、简化开发、内嵌web服务器，整合整个spring生态圈、技术栈的一站式框架，spring boot是简化spring技术栈的快速开发脚手架</strong></p></li><li><p>springboot的缺点</p><ul><li>版本迭代块，需要时刻关注变化，也不能算作是缺点</li><li>封装太深，内部原理复杂，不容易精通</li></ul></li></ol><h3 id="微服务" tabindex="-1"><a class="header-anchor" href="#微服务" aria-hidden="true">#</a> 微服务</h3><ol><li><p>什么是分布式：</p><p>分布式是个<strong>工作方式</strong>，由多台服务器共同完成一件比较复杂的事，这多台服务器共同提供服务，呈现出一台单机服务器提供服务的效果。强调多台服务器共同提供服务</p><p><strong>把原来一个大块系统，根据功能，分成多个子系统或者说子模块，这些子系统或者说子模块分别部署在不同的服务器（集群上），共同提供服务，子服务部署在不同的服务器或集群上，共同完成一件事情，可以理解为分布式。</strong></p><p>将一个大的业务或者说系统拆分成多个子业务或者说子系统、子模块，这些子业务、子系统、子服务分别部署在不同的服务器（或者集群）上，共同对外呈现单机的服务效果。<strong>是一种工作方式</strong></p><p>好处：</p><ul><li>降低模块之间的耦合性</li><li>提高各个子模块、子系统的复用性</li></ul></li><li><p>什么是集群：</p><p>分布式强调工作方式，也可以认为是一种思想，就像AOP、IOC都可以认为是思想，是一种方式。</p><p>而集群，是<strong>物理层面</strong>的多台服务器，多台服务器合起来作为整体完成业务</p><p>分布式强调拆，大的业务拆成小的。</p><p>集群强调合，多个服务器合起来完成业务，说的是物理层面，而分布式可以看作是工作方式或者思想。</p><p>他们不能分开来看，不是并行的概念，集群和分布式是共同存在的。</p></li><li><p>什么是微服务</p><p>是一种架构风格。</p><p>把一个应用拆分为一组小型服务，这每个小服务或者说小模块可以独立部署，也就是部署在不同的服务器上！！其实就是说的分布式的概念</p><p>各个小服务之间使用轻量级HTTP交互</p><p>服务<strong>围绕业务功能拆分</strong></p><p>各个小服务可以由全自动部署机制独立部署</p><p>去中心化，服务<strong>自治</strong>，服务可以使用不同的语言，不同的存储技术</p><p><strong>强调独立、分布式、大模块分为小模块，小模块部署到独立的服务器！！！</strong></p></li><li><p>分布式的困难---涉及到服务器之间的通信，配置的同步等问题，根本原因就是因为各个微服务部署在不同的服务器！！</p><ul><li><p>远程调用</p></li><li><p>负载均衡</p></li><li><p>服务容错</p></li><li><p>服务发现</p></li><li><p>配置管理</p></li><li><p>服务监控</p></li><li><p>链路追踪</p><p>a服务器的服务调b，b调c，c调d，d出了问题，怎么追踪</p></li><li><p>日志管理</p></li></ul><p>分布式的解决：</p><p>springboot + springcloud。通过springcloud将这些服务网状的构建起来</p><p>springboot帮我们快速地构建出一个应用。</p><p>这些应用通过springcloud构建起来</p></li></ol><h3 id="了解自动配置原理" tabindex="-1"><a class="header-anchor" href="#了解自动配置原理" aria-hidden="true">#</a> 了解自动配置原理</h3><h4 id="依赖管理" tabindex="-1"><a class="header-anchor" href="#依赖管理" aria-hidden="true">#</a> 依赖管理</h4><ul><li><p>父项目做依赖管理</p><ol><li><p>我们引入了父项目，导入了一个spring-boot-starter-web依赖</p><p>父项目一般是做依赖管理，子项目只要继承了父项目，子项目就不需要写版本号了</p><p><img src="/study/assets/image-20211007005513089.d08420fa.png" alt="image-20211007005513089"></p><p><strong>父项目的主要功能就是做依赖管理，对依赖的版本控制</strong>，点进dependencies里去，发现所需要依赖的jar包都规定了版本号，这些需要依赖的jar包会自动被springboot引入。</p><p>几乎声明了所有开发中常用的jar的版本号</p><p>这个也可以称为<strong>自动版本仲裁机制</strong></p></li><li><p>引入依赖默认都可以不屑版本号</p><p>引入非版本仲裁的依赖，要写版本号</p></li><li><p>如果说我们需要依赖的jar包版本和springboot里父项目规定的版本号不一致，那么在pom文件里写properties标签，重新规定版本</p><p>比如：</p><p><img src="/study/assets/image-20211007005926535.75151aa0.png" alt="image-20211007005926535"></p><ul><li>查看spring-boot-dependencies里面规定的当前依赖的版本用的key</li><li>在当前项目的pom文件进行重写</li></ul></li></ol></li><li><p>开发导入<strong>starter场景启动器</strong></p><ol><li><p>starter是<strong>一组依赖</strong>的集合描述，一般引入一个starter，开发所需要的完整依赖就被引入了</p><p>见到很多spring-boot-starter-*： *代表某种场景</p><p><strong>只要引入starter，这个场景的所有常规需要的依赖都自动引入</strong></p><div class="language-xml ext-xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>见到的 *-spring-boot-starter：第三方为我们提供的简化开发的场景启动器</p></li><li><p>所有场景启动器（starter），最底层的依赖都会依赖于</p><p><img src="/study/assets/image-20211007010839779.f0840933.png" alt="image-20211007010839779"></p><p>这是springboot自动配置的核心依赖</p></li><li><p>我们要开发哪个场景，就添加哪个场景的starter，那么所需要的常规依赖都会被自动引入，这也是maven的特性，所以说springboot简化了依赖管理，就是通过spring-boot-starter-*： *代表某种场景</p></li></ol></li></ul><h4 id="自动配置" tabindex="-1"><a class="header-anchor" href="#自动配置" aria-hidden="true">#</a> 自动配置</h4><ol><li><p>自动配好tomcat</p><ul><li>引入Tomcat依赖---通过<strong>依赖管理</strong>，spring-boot-starter-web，引入了完整的依赖，包括tomcat、mvc等</li><li>自动配置好tomcat</li></ul></li><li><p>自动配好springMVC</p><ul><li>引入springMVC全套组件</li><li>自动配好springMVC常用组件</li></ul></li><li><p>自动配好web常见功能</p><ul><li>springboot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>自动配置好了包的扫描</p><ul><li><p><strong>主程序所在的包及其下面的所有子包里面的组件都会默认被扫描进来</strong>（一定要注意主程序和其他类的目录结构，不然扫描不到，这也是一种规范）</p></li><li><p>如果想要改变扫描路径</p><ul><li><p>通过注解的属性</p><p><img src="/study/assets/image-20211007012036725.c3171f38.png" alt="image-20211007012036725"></p></li><li><p>或者在主程序上添加注解@ComponentScan(&quot;xxx&quot;)</p></li></ul></li></ul></li><li><p>各种配置有默认值</p><ul><li>默认配置最终都是映射到某一个类上</li><li><strong>配置文件的值最终会绑定到某个类上</strong>，这个类会在容器中创建对象（对象交给容器创建，这是spring的IOC思想）</li></ul></li><li><p>按需加载自动配置项</p><ul><li>非常多的starter，这些starter不是全部启动，<strong>我们引入了哪个启动场景，这个场景下的自动配置才会开启</strong></li></ul><p><img src="/study/assets/image-20211007012636111.7c237183.png" alt="image-20211007012636111"></p><p>springboot所有的自动配置都依赖于这个包，在这个包里</p><p>虽然看External Libraries下有很多类，这些类并不是全部生效，里面有一些是报红的，因为我们并没有引入对应场景的starter，那么对应的自动配置并没有开启</p></li></ol><h4 id="容器功能和注解" tabindex="-1"><a class="header-anchor" href="#容器功能和注解" aria-hidden="true">#</a> 容器功能和注解</h4><ol><li><p>@Configuration</p><p><strong>我们编写一个类，用这个注解加在类上面，那么这个类就类似于一个配置文件</strong></p><p>@Configuration告诉springboot这个类是配置类，这个配置类就相当于一个配置文件，以前配置文件能做什么，现在配置类就做什么。<strong>以前通过配置文件能创建容器，通过容器能创建单例的实例化对象，那么现在配置类也能完成这些功能！！</strong></p><div class="language-java ext-java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConfig</span> <span class="token punctuation">{</span>
        <span class="token doc-comment comment">/**
     * 外部无论对配置类中的这个组件注册方法调用多少次，都是之前容器中注册的单例对象
     * @Bean:
     * 给容器中添加组件，以方法名作为组件的ID，也就是对象的名字
     * 返回类型：就是组件类型
     * 返回的值就是组件在容器中的实例（是单例的）。之前有容器，现在用springboot同样有容器，容器帮我们创建对象
     * 组件的名字默认是方法名，组件名就是对象实例的名字，也就是对象的自定义名称。方法名就是对象的自定义名称
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Pet</span> <span class="token function">tomcatPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pet</span><span class="token punctuation">(</span><span class="token string">&quot;tomcat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码写了之后，容器中就有这两个组件，也就是对象实例。</p><p>不要认为写了new，那么就是每次创建新的， 仍然是将对象交给容器创建，仍然是单例。写了上面代码之后，容器中就有这两个对象实例！！之前是在xml文件里写bean标签，这里是加上bean注解！</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 这个类也称为主程序类，是所有启动的入口
 * 告诉springboot这是一个springboot应用
 */</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainApplication</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 返回我们的IOC容器，（IOC是一种思想，就是将对象交给容器创建，是一种控制反转的思想，本来由我们创建的对象，交给外部容器来管理并创建，这就是控制反转）</span>
        <span class="token class-name">ConfigurableApplicationContext</span> run <span class="token operator">=</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">MainApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2. 查看容器里的组件</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> beanDefinitionName <span class="token operator">:</span> beanDefinitionNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beanDefinitionName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 3. 从容器中获取组件</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>我们通过这种方式在容器中注册的两个对象，或者说对象实例或组件，默认是单例的！！无论获取多少次，都是同一个实例对象，不要看到new就认为会是不同的对象。单例模式也会有new，new就是造一个单例对象，我们以后都用这个单例对象，不会再去调这个方法重复造对象。我们获取对象，不会通过调配置类里的注册组件的方法来获取对象，而是通过springboot容器拿到对象</strong></p><div class="language-java ext-java"><pre class="language-java"><code>        <span class="token comment">// 3. 从容器中获取组件</span>
        <span class="token class-name">Pet</span> tom01 <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;tom&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Pet</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Pet</span> tom02 <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;tom&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Pet</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tom01 <span class="token operator">==</span> tom02<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>这个和之前用spring或springmvc在容器中注册的对象是一样的。本质都是IOC . IOC也有两种方式，一种是基于注解，一种是基于xml配置文件，基于xml配置文件里依赖注入又有两种方式，一种是set注入，一种是构造注入，大多数都是set注入。IOC的底层采用的反射，AOP底层采用的动态代理。</p></li><li><p>即使我们通过容器获得myconfig对象，通过myconfig对象来重复调用myconfig类里的创建单例对象的方法，最后获得的对象仍然是同一个对象，是单例！！</p><div class="language-java ext-java"><pre class="language-java"><code>        <span class="token class-name">MyConfig</span> bean <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">MyConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user01 <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user02 <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user01 <span class="token operator">==</span> user02<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><strong>一旦配置类里面，在方法上加了bean，也就是在容器中注册了对象实例或者说注册了组件，那么外部无论调多少次方法，拿到的都是我们在容器中注册的单例对象！！！！取决于configuration注解的属性proxyBeanMethods = true</strong></p><div class="language-java ext-java"><pre class="language-java"><code><span class="token comment">// com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$2d5007d6@52d97ab6</span>
<span class="token class-name">MyConfig</span> myconfig <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">MyConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myconfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 上面返回的myconfig实例是spring增强后的代理对象，因为springboot2，默认configuration注解的属性proxyBeanMethods = true</span>
<span class="token comment">// 那么myconfig是代理对象，也就是通过代理对象调用注册实例的方法，springboot会检查是否已经存在实例，如果有，就返回之前创建好的实例</span>
<span class="token comment">// 而不会去重新创建，目的:保持组件单例</span>
<span class="token class-name">User</span> user01 <span class="token operator">=</span> myconfig<span class="token punctuation">.</span><span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user02 <span class="token operator">=</span> myconfig<span class="token punctuation">.</span><span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user01 <span class="token operator">==</span> user02<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果我们将configuration注解的属性proxyBeanMethods改为false</span>
<span class="token comment">// 那么拿到的myconfig对象，就是普通的对象而不是代理对象</span>
<span class="token comment">// 那么通过myconfig去调用注册实例的方法，就不会检查是否之前有创建好的实例，而会直接创建新的对象</span>
<span class="token comment">// com.atguigu.boot.config.MyConfig@654c7d2d</span>
<span class="token class-name">MyConfig</span> myconfig <span class="token operator">=</span> run<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">MyConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myconfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user01 <span class="token operator">=</span> myconfig<span class="token punctuation">.</span><span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user02 <span class="token operator">=</span> myconfig<span class="token punctuation">.</span><span class="token function">user01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user01 <span class="token operator">==</span> user02<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p><strong>configuration注解的属性proxyBeanMethods = true</strong>，那么外部随便调用多少次注册组件的方法，都会先去容器里检查是否有创建好的对象实例</p></li><li><p>proxyBeanMethods = true叫full模式</p><p>proxyBeanMethods = false叫轻量级模式，lite模式</p><p>意思就是说，去调用注册实例的方法的时候，或者说去调用创建对象的new方法的时候，会绕过容器，不会去容器里检查是否有事先创建好的对象，就是轻量级模式，启动就快，就轻量</p><p>full模式，就是说去调用创建对象的new方法的时候，即注册实例的方法，都会去容器里先检查是否有创建好的对象，有的话就直接拿来用，目的是保持单例，启动就稍慢。</p></li><li><p>向容器里注册组件，用以下注解也一样是可以的</p><ul><li><p>@Bean</p><p>给容器注册组件</p></li><li><p>@Component</p></li><li><p>@Controller</p></li><li><p>@Service</p></li><li><p>@Repository</p></li><li><p>@Import</p><p><img src="/study/assets/image-20211007170017159.0dcaaea8.png" alt="image-20211007170017159"></p><p>给容器中<strong>自动创建出这两个类的对象实例</strong></p><p>@import导入的组件，<strong>默认的名字也就是对象名字是全类名</strong></p></li></ul></li><li><p>@Conditional</p><p>满足conditional指定的条件，则进行条件注入</p></li><li><p>@ImportResources</p><p>可以导入配置文件，让配置文件里声明的bean实例对象生效</p></li></ol><h4 id="配置绑定javabean" tabindex="-1"><a class="header-anchor" href="#配置绑定javabean" aria-hidden="true">#</a> 配置绑定JavaBean</h4><ol><li><p><strong>把properties里所有的配置绑定到javaBean里</strong></p><ul><li><p>采用原生的Java代码的方式来做</p><p><img src="/study/assets/image-20211007173613033.ccde91ee.png" alt="image-20211007173613033"></p></li><li><p>在springboot里，这个过程会变得很简单</p><p>使用@Component + @ConfigurationProperties</p><div class="language-java ext-java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 为什么一定要写@Component：只有在容器中的组件才会拥有springboot提供的强大功能
 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">&quot;mycar&quot;</span><span class="token punctuation">)</span>
</code></pre></div></li><li><p>使用@EnableConfigurationProperties + @ConfigurationProperties</p><p>EnableConfigurationProperties这个注解写在配置类上，因为配置类是容器中的组件。那么这样，<strong>想要读入配置的那个JavaBean</strong>上就不用写@Component</p><p><img src="/study/assets/image-20211007175026160.b2767134.png" alt="image-20211007175026160"></p></li></ul></li></ol><h4 id="自动配置原理" tabindex="-1"><a class="header-anchor" href="#自动配置原理" aria-hidden="true">#</a> 自动配置原理</h4><ol><li><p>@SpringBootApplication</p><p><img src="/study/assets/image-20211007191020426.20ff3b77.png" alt="image-20211007191020426"></p><p>@SpringBootApplication是上图这些注解的合成注解</p><ul><li><p>@SpringBootConfiguration</p><p><img src="/study/assets/image-20211007191113896.c09bc8bf.png" alt="image-20211007191113896"></p><p>这个注解首先就是一个Configuration</p><p>@Configuration的作用就是告诉springboot这个类是配置类</p><p>也就说明Main程序这个类，也是springboot里的配置类，是核心配置类</p></li><li><p>@ComponentScan</p><p>指定扫描哪些</p></li><li><p><strong>@EnableAutoConfiguration</strong></p><p>点进@EnableAutoConfiguration，发现也是一个合成注解，是以下两个注解的合成注解</p><p><img src="/study/assets/image-20211007191512056.fe4cbd18.png" alt="image-20211007191512056"></p><ul><li><p>@AutoConfigurationPackage</p><p>自动配置包，指定了默认包规则</p><p><img src="/study/assets/image-20211007191601616.56b51d6f.png" alt="image-20211007191601616"></p><p>@Import就是给容器中导入组件</p><p>利用Registrar<strong>批量给容器注册组件</strong></p><p>Registrar把指定的包下的所有组件注册，哪个包呢？就是Main程序所在的包</p><p>所以为什么我们默认的包路径，是Main程序所在的包，原因就是@SpringBootApplication注解下的@EnableAutoConfiguration下的@AutoConfigurationPackage的@Import，导入了Registrar，Registrar把指定的包下的所有组件注册，根据@SpringBootApplication注解写在Main程序上，那么Main程序所在的包就是Registrar索要注册的默认包路径。</p></li><li><p>@Import(AutoConfigurationImportSelector.class)</p><div class="language-text ext-text"><pre class="language-text"><code>1、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件
2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类
3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件
4、从META-INF/spring.factories位置来加载一个文件。
  默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件
    spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories
    spring.factories写死了springboot一启动就要给容器中加载的所有配置类
</code></pre></div><p><strong>虽然127个所有场景的自动配置，启动的时候默认全部加载，但是最终会按需（条件）配置</strong></p><p><strong>按需配置，就是条件装配@Condition，让配置不是完全开启</strong></p><p><strong>启动的时候是全部配置都加载，最终按照条件装配，来按需配置，就是把我们需要的组件在容器中注册！！！</strong></p><div class="language-text ext-text"><pre class="language-text"><code>虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration
按照条件装配规则（@Conditional），最终会按需配置。(只有条件生效的时候，我们的对应的自动配置才会生效)
</code></pre></div></li></ul></li></ul></li><li><p>总结：</p><ul><li><p>springboot会先加载所有<strong>自动配置类</strong></p></li><li><p><strong>每个自动配置类按照条件（各种@Condition注解）进行生效</strong></p></li><li><p><strong>每个配置类生效后默认都会绑定配置文件指定的值（从xxxProperties拿值），xxxProperties类和application.Properties配置文件进行了绑定（通过注解@ConfigurationProperties），我们想要修改也很简单，只需要在application.Properties配置文件里进行修改</strong></p><p>xxxProperties只是绑定了配置文件application.properties的类而已，就可以理解为配置文件。</p></li><li><p>生效的配置类就会给容器中装配（注册）很多组件（配置类里的方法上面有注解@Bean，就是在给容器中注册组件，或者说装配）</p></li><li><p>只要容器中有这些组件，相当于这些功能就有了。</p><p>只要有用户自己配置的，就以用户的优先。</p></li><li><p>定制化配置：</p><ul><li>用户直接自己@Bean替换底层的组件</li><li>用户去看这个组件是获取的配置文件什么值，就去修改</li></ul></li></ul></li><li><p>自动配置从配置文件取值的步骤</p><ul><li><p><strong>xxxAutoConfiguration（自动配置类）给我们装配（注册）了很多组件。怎么装配的？按条件装配，@Condition</strong></p><p>装配的意思就是向容器中注册组件（通过注解@Bean），或者说实例对象，供用户使用</p></li><li><p><strong>这些组件从xxxProperties（是和application.properties绑定的类）里面拿值</strong></p></li><li><p><strong>xxxProperties和application.properties绑定，也就是从application.properties里获取值</strong></p><p><strong>通过注解@ConfigurationProperties</strong></p><p>就像</p><p><img src="/study/assets/image-20211007231310887.5470fe9f.png" alt="image-20211007231310887"></p><p>不要把xxxProperties和自动配置类搞混，自动配置类里是有很多装配组件的代码的，也就是加了@Bean的方法。自动配置类装配的这些组件（实例化对象）从xxxProperties取值。xxxProperties只是绑定了配置文件application.properties的JavaBean而已，就可以理解为配置文件。也就是一个application.properties文件对应于多个xxxProperties类。各个xxxProperties类用到application.properties文件里的自己那一部分配置（通过@ConfigurationProperties注解的属性prefix来拿配置使用）</p><p><img src="/study/assets/image-20211008004343664.59a79138.png" alt="image-20211008004343664"></p><p><strong>xxxAutoConfiguration才是自动配置类</strong></p><p><strong>上面加了注解@Configuration</strong></p><p><strong>并且加了@EnableConfigurationProperties，来让自动配置类里面需要装配的bean，绑定配置文件指定的值（从xxxProperties拿值）（这个类并不是自动配置类，不要弄混，这个类只是和applicaiton.properties绑定的类而已）</strong></p></li></ul></li></ol><h3 id="开发小技巧" tabindex="-1"><a class="header-anchor" href="#开发小技巧" aria-hidden="true">#</a> 开发小技巧</h3><ol><li><p>lombok</p><p>简化JavaBean开发</p></li></ol><h2 id="核心功能-web开发" tabindex="-1"><a class="header-anchor" href="#核心功能-web开发" aria-hidden="true">#</a> 核心功能-web开发</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><ol><li>springboot是框架的框架，整合了开发所需要的框架，比如springmvc</li><li>用springboot做web开发，底层仍然使用的是springmvc</li><li>springboot对springmvc做了很多自动配置</li></ol><h3 id="静态资源请求" tabindex="-1"><a class="header-anchor" href="#静态资源请求" aria-hidden="true">#</a> 静态资源请求</h3><ol><li><p>静态资源目录</p><p><img src="/study/assets/image-20211008181155963.09e2daef.png" alt="image-20211008181155963"><strong>类路径下</strong></p><p>访问当前项目的根路径 + / + 静态资源名就能访问到了。</p><p>映射的是<code>/**</code>，所以写资源名，就能自动找到静态资源</p><p>如果动态请求名和静态资源名相同，访问的是动态请求，找@RequestMapping</p></li><li><p>静态资源访问的原理：</p><p>静态映射 <code>/**</code></p><p>请求进来，先去找Controller能不能处理（实际是请求先要经过DispatcherServlet获取请求，然后通过server()、doServer()、doDispatch()等一系列方法将请求转发给Controller处理，涉及到处理器映射器，处理器执行链，处理器适配器，最后将请求交给处理器的方法执行），如果没有Controller能处理，那么不能处理的所有请求又都交给静态资源处理器。</p><p>接着看静态资源能不能找到，如果静态资源能找到，就能访问，如果静态资源找不到，就会返回404</p></li><li><p>静态资源访问前缀</p><p><img src="/study/assets/image-20211008183710429.e98d0629.png" alt="image-20211008183710429"></p><p>当前项目 + static-path-pattern + 静态资源名 = 能访问到静态资源</p><p>现在开发和之前用springmvc不同的是，根路径直接就是端口号后 + <code>/</code>，就是根路径，之前用springmvc，或者javaweb开发，端口号和斜杠后还有一个工程名，这叫工程路径，工程路径后才是资源路径或者动态请求！！</p></li><li><p>我们也可以改变默认的静态资源路径</p><p><img src="/study/assets/image-20211008184239530.5fb6fb5f.png" alt="image-20211008184239530"></p><p>那么resource下的haha目录下的资源才是静态资源。这是规定了静态资源默认路径位置</p></li></ol><h3 id="静态资源配置原理" tabindex="-1"><a class="header-anchor" href="#静态资源配置原理" aria-hidden="true">#</a> 静态资源配置原理</h3><ol><li><p>springboot启动默认加载很多xxxAutoConfiguration类，这些类是自动配置类</p><p>当然也会加载和web开发有关的自动配置类</p></li><li><p>springmvc功能的自动配置类WebMvcAutoConfiguration</p><p>自动配置类首先全部加载，按条件@Condition相关注解生效</p><p><img src="/study/assets/image-20211008225543585.df2cb9e4.png" alt="image-20211008225543585"></p></li><li><p><img src="/study/assets/image-20211008225917153.a54e93dd.png" alt="image-20211008225917153"></p><p>这个自动配置类，通过注解@EnableConfigurationProperties，发现用到了<strong>WebMvcProperties和ResourceProperties这两个绑定了配置文件的JavaBean</strong></p><ul><li>WebMvcProperties和配置文件中前缀为spring.mvc的配置进行了绑定</li><li>ResourceProperties和配置文件中前缀为spring.resources的配置进行了绑定</li></ul></li><li><p>xxxAutoConfiguration才是配置类，xxxProperties是与配置文件绑定的JavaBean。配置类要用到JavaBean，通过注解@EnableConfigurationProperties</p></li><li><p>配置类如果只有一个有参构造器</p><p>有参构造器所有参数的值都会从容器中确定。</p></li><li><p>为什么静态资源能从前面提到的那四个默认位置里面拿</p><p><img src="/study/assets/image-20211008232101965.42e3b6ff.png" alt="image-20211008232101965"></p></li><li><p>静态资源都有缓存策略。</p></li></ol><h3 id="欢迎页支持" tabindex="-1"><a class="header-anchor" href="#欢迎页支持" aria-hidden="true">#</a> 欢迎页支持</h3><ol><li><p>给静态资源路径下，放index.html</p></li><li><p>编写controller，能处理/index请求</p><p>这两种都会被当成欢迎页</p></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.f43a1e4d.js" defer></script>
  </body>
</html>
