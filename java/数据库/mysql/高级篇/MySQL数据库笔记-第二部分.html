<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>第二部分 MySQL高级特性篇 | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.8ebcd65c.js"><link rel="modulepreload" href="/study/assets/MySQL数据库笔记-第二部分.html.94cf6f8f.js"><link rel="modulepreload" href="/study/assets/MySQL数据库笔记-第二部分.html.f76c5889.js"><link rel="prefetch" href="/study/assets/index.html.63ddc988.js"><link rel="prefetch" href="/study/assets/index.html.66956445.js"><link rel="prefetch" href="/study/assets/index.html.057d5504.js"><link rel="prefetch" href="/study/assets/index.html.be644f92.js"><link rel="prefetch" href="/study/assets/gin.html.0670d179.js"><link rel="prefetch" href="/study/assets/golang.html.6ecf4dc7.js"><link rel="prefetch" href="/study/assets/gorm.html.b0434a83.js"><link rel="prefetch" href="/study/assets/Javaweb.html.90673469.js"><link rel="prefetch" href="/study/assets/ES.html.2b7cbc11.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.86e72d78.js"><link rel="prefetch" href="/study/assets/Java笔记.html.1b0fc904.js"><link rel="prefetch" href="/study/assets/dubbo.html.0236cacd.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.7c41ebaa.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.6f1e8a79.js"><link rel="prefetch" href="/study/assets/zookeeper.html.f0997749.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.a1f2effc.js"><link rel="prefetch" href="/study/assets/并发编程.html.a1657fcc.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.9f5ee66c.js"><link rel="prefetch" href="/study/assets/redis.html.0ad7ee13.js"><link rel="prefetch" href="/study/assets/Mybatis.html.60b4d174.js"><link rel="prefetch" href="/study/assets/spring.html.75e88086.js"><link rel="prefetch" href="/study/assets/springboot.html.bb9a3cd7.js"><link rel="prefetch" href="/study/assets/springboot.html.b3c5d30b.js"><link rel="prefetch" href="/study/assets/springMVC.html.70cfe486.js"><link rel="prefetch" href="/study/assets/kafka.html.532abbd0.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.e1b81afd.js"><link rel="prefetch" href="/study/assets/操作系统.html.0c0e47e2.js"><link rel="prefetch" href="/study/assets/flink基本篇1.html.61ec6e00.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.10488243.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.75295308.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.a1f7ea91.js"><link rel="prefetch" href="/study/assets/index.html.4307b4a4.js"><link rel="prefetch" href="/study/assets/index.html.824e7854.js"><link rel="prefetch" href="/study/assets/index.html.d1ea64c8.js"><link rel="prefetch" href="/study/assets/gin.html.2c1e74ea.js"><link rel="prefetch" href="/study/assets/golang.html.7efe3c95.js"><link rel="prefetch" href="/study/assets/gorm.html.d21550f5.js"><link rel="prefetch" href="/study/assets/Javaweb.html.33494ccb.js"><link rel="prefetch" href="/study/assets/ES.html.4c71285c.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.ddb18663.js"><link rel="prefetch" href="/study/assets/Java笔记.html.333afe5d.js"><link rel="prefetch" href="/study/assets/dubbo.html.1ab38fe1.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.6851ced2.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.819e02d1.js"><link rel="prefetch" href="/study/assets/zookeeper.html.b9d6b1e7.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.799fe2cf.js"><link rel="prefetch" href="/study/assets/并发编程.html.82d7ba9d.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.5c5fa375.js"><link rel="prefetch" href="/study/assets/redis.html.144b331c.js"><link rel="prefetch" href="/study/assets/Mybatis.html.5d7ee3db.js"><link rel="prefetch" href="/study/assets/spring.html.edc7a33c.js"><link rel="prefetch" href="/study/assets/springboot.html.4db35abc.js"><link rel="prefetch" href="/study/assets/springboot.html.5958b336.js"><link rel="prefetch" href="/study/assets/springMVC.html.147792a3.js"><link rel="prefetch" href="/study/assets/kafka.html.87bcf7fb.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.bd13eeb2.js"><link rel="prefetch" href="/study/assets/操作系统.html.8fdfda8d.js"><link rel="prefetch" href="/study/assets/flink基本篇1.html.4a910e16.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.8e6cf922.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.1bea13f4.js"><link rel="prefetch" href="/study/assets/404.html.0c613fbe.js"><link rel="prefetch" href="/study/assets/404.5c6d7bc9.js"><link rel="prefetch" href="/study/assets/Layout.d2fb59a8.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">第二部分 MySQL高级特性篇 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第01章-linux下mysql的安装与使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="第01章 Linux下MySQL的安装与使用"><!--[--><!--]--> 第01章 Linux下MySQL的安装与使用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-安装前说明" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 安装前说明"><!--[--><!--]--> 1. 安装前说明 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-查看是否安装过mysql" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 查看是否安装过MySQL"><!--[--><!--]--> 1.1 查看是否安装过MySQL <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-mysql的卸载" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 MySQL的卸载"><!--[--><!--]--> 1.2 MySQL的卸载 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-mysql的linux版安装" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. MySQL的Linux版安装"><!--[--><!--]--> 2. MySQL的Linux版安装 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-centos7下检查mysql依赖" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 CentOS7下检查MySQL依赖"><!--[--><!--]--> 2.1 CentOS7下检查MySQL依赖 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-centos7下mysql安装过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 CentOS7下MySQL安装过程"><!--[--><!--]--> 2.2 CentOS7下MySQL安装过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-查看mysql版本" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 查看MySQL版本"><!--[--><!--]--> 2.3 查看MySQL版本 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-服务的初始化" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 服务的初始化"><!--[--><!--]--> 2.4 服务的初始化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-5-启动mysql-查看状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 启动MySQL，查看状态"><!--[--><!--]--> 2.5 启动MySQL，查看状态 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-6-查看mysql服务是否自启动" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.6 查看MySQL服务是否自启动"><!--[--><!--]--> 2.6 查看MySQL服务是否自启动 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-mysql登录" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. MySQL登录"><!--[--><!--]--> 3. MySQL登录 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-首次登录" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 首次登录"><!--[--><!--]--> 3.1 首次登录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-修改密码" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 修改密码"><!--[--><!--]--> 3.2 修改密码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-设置远程登录" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 设置远程登录"><!--[--><!--]--> 3.3 设置远程登录 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-linux下修改配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. Linux下修改配置"><!--[--><!--]--> 4. Linux下修改配置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-字符集的相关操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 字符集的相关操作"><!--[--><!--]--> 5. 字符集的相关操作 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-1-各级别的字符集" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 各级别的字符集"><!--[--><!--]--> 5.1 各级别的字符集 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-2-请求到响应过程中字符集的变化" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 请求到响应过程中字符集的变化"><!--[--><!--]--> 5.2 请求到响应过程中字符集的变化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第02章-mysql的数据目录" class="router-link-active router-link-exact-active sidebar-item" aria-label="第02章 MySQL的数据目录"><!--[--><!--]--> 第02章 MySQL的数据目录 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-mysql8的主要目录结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. MySQL8的主要目录结构"><!--[--><!--]--> 1. MySQL8的主要目录结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-数据库文件的存放路径" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 数据库文件的存放路径"><!--[--><!--]--> 1.1 数据库文件的存放路径 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-相关命令目录" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 相关命令目录"><!--[--><!--]--> 1.2 相关命令目录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-配置文件目录" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 配置文件目录"><!--[--><!--]--> 1.3 配置文件目录 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-数据库和文件系统的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 数据库和文件系统的关系"><!--[--><!--]--> 2. 数据库和文件系统的关系 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-查看默认数据库" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 查看默认数据库"><!--[--><!--]--> 2.1 查看默认数据库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-数据库在文件系统中的表示" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 数据库在文件系统中的表示"><!--[--><!--]--> 2.2 数据库在文件系统中的表示 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-表在文件系统中的表示" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 表在文件系统中的表示"><!--[--><!--]--> 2.3 表在文件系统中的表示 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 小结"><!--[--><!--]--> 2.4 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第03章-用户与权限管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="第03章 用户与权限管理"><!--[--><!--]--> 第03章 用户与权限管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-用户管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 用户管理"><!--[--><!--]--> 1. 用户管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-登录mysql服务器" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 登录MySQL服务器"><!--[--><!--]--> 1.1 登录MySQL服务器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-创建用户" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 创建用户"><!--[--><!--]--> 1.2 创建用户 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-修改用户" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 修改用户"><!--[--><!--]--> 1.3 修改用户 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-4-删除用户" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 删除用户"><!--[--><!--]--> 1.4 删除用户 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-5-设置当前用户密码" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 设置当前用户密码"><!--[--><!--]--> 1.5 设置当前用户密码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-6-修改其它用户密码" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.6 修改其它用户密码"><!--[--><!--]--> 1.6 修改其它用户密码 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-权限管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 权限管理"><!--[--><!--]--> 2. 权限管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-权限列表" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 权限列表"><!--[--><!--]--> 2.1 权限列表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-授予权限的原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 授予权限的原则"><!--[--><!--]--> 2.2 授予权限的原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-授予权限" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 授予权限"><!--[--><!--]--> 2.3 授予权限 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-查看权限" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 查看权限"><!--[--><!--]--> 2.4 查看权限 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-5-收回权限" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 收回权限"><!--[--><!--]--> 2.5 收回权限 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-角色管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 角色管理"><!--[--><!--]--> 3. 角色管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-创建角色" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 创建角色"><!--[--><!--]--> 3.1 创建角色 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-给角色赋予权限" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 给角色赋予权限"><!--[--><!--]--> 3.2 给角色赋予权限 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-查看角色的权限" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 查看角色的权限"><!--[--><!--]--> 3.3 查看角色的权限 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-回收角色的权限" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 回收角色的权限"><!--[--><!--]--> 3.4 回收角色的权限 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-5-删除角色" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 删除角色"><!--[--><!--]--> 3.5 删除角色 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-6-给用户赋予角色" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.6 给用户赋予角色"><!--[--><!--]--> 3.6 给用户赋予角色 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-7-激活角色" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.7 激活角色"><!--[--><!--]--> 3.7 激活角色 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-8-撤销用户的角色" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.8 撤销用户的角色"><!--[--><!--]--> 3.8 撤销用户的角色 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-9-设置强制角色-mandatory-role" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.9 设置强制角色(mandatory role)"><!--[--><!--]--> 3.9 设置强制角色(mandatory role) <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第04章-逻辑架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="第04章 逻辑架构"><!--[--><!--]--> 第04章 逻辑架构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-逻辑架构剖析" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 逻辑架构剖析"><!--[--><!--]--> 1. 逻辑架构剖析 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-服务器处理客户端请求" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 服务器处理客户端请求"><!--[--><!--]--> 1.1 服务器处理客户端请求 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-connectors" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 Connectors"><!--[--><!--]--> 1.2 Connectors <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-第1层-连接层" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 第1层：连接层"><!--[--><!--]--> 1.3 第1层：连接层 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-4-第2层-服务层" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 第2层：服务层"><!--[--><!--]--> 1.4 第2层：服务层 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-5-第3层-引擎层" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 第3层：引擎层"><!--[--><!--]--> 1.5 第3层：引擎层 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-6-小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.6 小结"><!--[--><!--]--> 1.6 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-sql执行流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. SQL执行流程"><!--[--><!--]--> 2. SQL执行流程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-mysql-中的-sql执行流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 MySQL 中的 SQL执行流程"><!--[--><!--]--> 2.1 MySQL 中的 SQL执行流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-数据库缓冲池-buffer-pool" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 数据库缓冲池(buffer pool)"><!--[--><!--]--> 3. 数据库缓冲池(buffer pool) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-缓冲池-vs-查询缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 缓冲池 vs 查询缓存"><!--[--><!--]--> 3.1 缓冲池 vs 查询缓存 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-缓冲池如何读取数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 缓冲池如何读取数据"><!--[--><!--]--> 3.2 缓冲池如何读取数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-查看-设置缓冲池的大小" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 查看/设置缓冲池的大小"><!--[--><!--]--> 3.3 查看/设置缓冲池的大小 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-多个buffer-pool实例" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 多个Buffer Pool实例"><!--[--><!--]--> 3.4 多个Buffer Pool实例 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第05章-存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="第05章 存储引擎"><!--[--><!--]--> 第05章 存储引擎 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-查看存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 查看存储引擎"><!--[--><!--]--> 1. 查看存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-设置系统默认的存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 设置系统默认的存储引擎"><!--[--><!--]--> 2. 设置系统默认的存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-设置表的存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 设置表的存储引擎"><!--[--><!--]--> 3. 设置表的存储引擎 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-创建表时指定存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 创建表时指定存储引擎"><!--[--><!--]--> 3.1 创建表时指定存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-修改表的存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 修改表的存储引擎"><!--[--><!--]--> 3.2 修改表的存储引擎 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-引擎介绍" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 引擎介绍"><!--[--><!--]--> 4. 引擎介绍 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-innodb-引擎-具备外键支持功能的事务存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"><!--[--><!--]--> 4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-myisam-引擎-主要的非事务处理存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 MyISAM 引擎：主要的非事务处理存储引擎"><!--[--><!--]--> 4.2 MyISAM 引擎：主要的非事务处理存储引擎 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-3-archive-引擎-用于数据存档" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 Archive 引擎：用于数据存档"><!--[--><!--]--> 4.3 Archive 引擎：用于数据存档 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-4-blackhole-引擎-丢弃写操作-读操作会返回空内容" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"><!--[--><!--]--> 4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-5-csv-引擎-存储数据时-以逗号分隔各个数据项" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"><!--[--><!--]--> 4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-6-memory-引擎-置于内存的表" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.6 Memory 引擎：置于内存的表"><!--[--><!--]--> 4.6 Memory 引擎：置于内存的表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-7-federated-引擎-访问远程表" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.7 Federated 引擎：访问远程表"><!--[--><!--]--> 4.7 Federated 引擎：访问远程表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-8-merge引擎-管理多个myisam表构成的表集合" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.8 Merge引擎：管理多个MyISAM表构成的表集合"><!--[--><!--]--> 4.8 Merge引擎：管理多个MyISAM表构成的表集合 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-9-ndb引擎-mysql集群专用存储引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.9 NDB引擎：MySQL集群专用存储引擎"><!--[--><!--]--> 4.9 NDB引擎：MySQL集群专用存储引擎 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-myisam和innodb" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. MyISAM和InnoDB"><!--[--><!--]--> 5. MyISAM和InnoDB <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第06章-索引的数据结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="第06章 索引的数据结构"><!--[--><!--]--> 第06章 索引的数据结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-为什么使用索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.为什么使用索引？"><!--[--><!--]--> 1.为什么使用索引？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-索引及其优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 索引及其优缺点"><!--[--><!--]--> 2. 索引及其优缺点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-索引概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 索引概述"><!--[--><!--]--> 2.1 索引概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 优点"><!--[--><!--]--> 2.2 优点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 缺点"><!--[--><!--]--> 2.3 缺点 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-innodb中索引的推演" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. InnoDB中索引的推演"><!--[--><!--]--> 3. InnoDB中索引的推演 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-索引之前的查找" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 索引之前的查找"><!--[--><!--]--> 3.1 索引之前的查找 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-设计索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 设计索引"><!--[--><!--]--> 3.2 设计索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-常见索引概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 常见索引概念"><!--[--><!--]--> 3.3 常见索引概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-innodb的b-树索引的注意事项" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 InnoDB的B+树索引的注意事项"><!--[--><!--]--> 3.4 InnoDB的B+树索引的注意事项 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-myisam中的索引方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. MyISAM中的索引方案"><!--[--><!--]--> 4. MyISAM中的索引方案 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-myisam索引的原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 MyISAM索引的原理"><!--[--><!--]--> 4.1 MyISAM索引的原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-myisam-与-innodb对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 MyISAM 与 InnoDB对比"><!--[--><!--]--> 4.2 MyISAM 与 InnoDB对比 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-索引的代价" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 索引的代价"><!--[--><!--]--> 5. 索引的代价 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-mysql数据结构选择的合理性" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. MySQL数据结构选择的合理性"><!--[--><!--]--> 6. MySQL数据结构选择的合理性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-1-hash结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.1 Hash结构"><!--[--><!--]--> 6.1 Hash结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-2-二叉搜索树" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.2 二叉搜索树"><!--[--><!--]--> 6.2 二叉搜索树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-3-avl树" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.3 AVL树"><!--[--><!--]--> 6.3 AVL树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-4-b-tree" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.4 B-Tree"><!--[--><!--]--> 6.4 B-Tree <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-5-b-tree" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.5 B+Tree"><!--[--><!--]--> 6.5 B+Tree <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第07章-innodb数据存储结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="第07章 InnoDB数据存储结构"><!--[--><!--]--> 第07章 InnoDB数据存储结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-数据库的存储结构-页" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 数据库的存储结构：页"><!--[--><!--]--> 1. 数据库的存储结构：页 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-磁盘与内存交互基本单位-页" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 磁盘与内存交互基本单位：页"><!--[--><!--]--> 1.1 磁盘与内存交互基本单位：页 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-页结构概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 页结构概述"><!--[--><!--]--> 1.2 页结构概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-页的上层结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 页的上层结构"><!--[--><!--]--> 1.3 页的上层结构 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-页的内部结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 页的内部结构"><!--[--><!--]--> 2. 页的内部结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-第1部分-文件头部和文件尾部" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 第1部分：文件头部和文件尾部"><!--[--><!--]--> 2.1 第1部分：文件头部和文件尾部 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-第2部分-空闲空间、用户记录和最小最大记录" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 第2部分：空闲空间、用户记录和最小最大记录"><!--[--><!--]--> 2.2 第2部分：空闲空间、用户记录和最小最大记录 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-第3部分-页目录和页面头部" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 第3部分：页目录和页面头部"><!--[--><!--]--> 2.3 第3部分：页目录和页面头部 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-innodb行格式-或记录格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. InnoDB行格式（或记录格式）"><!--[--><!--]--> 3. InnoDB行格式（或记录格式） <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-指定行格式的语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 指定行格式的语法"><!--[--><!--]--> 3.1 指定行格式的语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-compact行格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 COMPACT行格式"><!--[--><!--]--> 3.2 COMPACT行格式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-dynamic和compressed行格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 Dynamic和Compressed行格式"><!--[--><!--]--> 3.3 Dynamic和Compressed行格式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-区、段和碎片区" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 区、段和碎片区"><!--[--><!--]--> 4. 区、段和碎片区 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-为什么要有区" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 为什么要有区？"><!--[--><!--]--> 4.1 为什么要有区？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-为什么要有段" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 为什么要有段？"><!--[--><!--]--> 4.2 为什么要有段？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-3-为什么要有碎片区" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 为什么要有碎片区？"><!--[--><!--]--> 4.3 为什么要有碎片区？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-4-区的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 区的分类"><!--[--><!--]--> 4.4 区的分类 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第08章-索引的创建与设计原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="第08章 索引的创建与设计原则"><!--[--><!--]--> 第08章 索引的创建与设计原则 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-索引的声明与使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 索引的声明与使用"><!--[--><!--]--> 1. 索引的声明与使用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-索引的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 索引的分类"><!--[--><!--]--> 1.1 索引的分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-创建索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 创建索引"><!--[--><!--]--> 1.2 创建索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-删除索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 删除索引"><!--[--><!--]--> 1.3 删除索引 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-mysql8-0索引新特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. MySQL8.0索引新特性"><!--[--><!--]--> 2. MySQL8.0索引新特性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-支持降序索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 支持降序索引"><!--[--><!--]--> 2.1 支持降序索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-隐藏索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 隐藏索引"><!--[--><!--]--> 2.2 隐藏索引 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-索引的设计原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 索引的设计原则"><!--[--><!--]--> 3. 索引的设计原则 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-哪些情况适合创建索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 哪些情况适合创建索引"><!--[--><!--]--> 3.1 哪些情况适合创建索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-限制索引的数目" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 限制索引的数目"><!--[--><!--]--> 3.2 限制索引的数目 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-哪些情况不适合创建索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 哪些情况不适合创建索引"><!--[--><!--]--> 3.3 哪些情况不适合创建索引 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第09章-性能分析工具的使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="第09章 性能分析工具的使用"><!--[--><!--]--> 第09章 性能分析工具的使用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-统计sql的查询成本-last-query-cost" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 统计SQL的查询成本：last_query_cost"><!--[--><!--]--> 1. 统计SQL的查询成本：last_query_cost <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-定位执行慢的sql-慢查询日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 定位执行慢的SQL：慢查询日志"><!--[--><!--]--> 2. 定位执行慢的SQL：慢查询日志 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-开启慢查询日志参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 开启慢查询日志参数"><!--[--><!--]--> 2.1 开启慢查询日志参数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-查看慢查询数目" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 查看慢查询数目"><!--[--><!--]--> 2.2 查看慢查询数目 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-慢查询日志分析工具-mysqldumpslow" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 慢查询日志分析工具：mysqldumpslow"><!--[--><!--]--> 2.3 慢查询日志分析工具：mysqldumpslow <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-关闭慢查询日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 关闭慢查询日志"><!--[--><!--]--> 2.4 关闭慢查询日志 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-查看-sql-执行成本-show-profile" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 查看 SQL 执行成本：SHOW PROFILE"><!--[--><!--]--> 3. 查看 SQL 执行成本：SHOW PROFILE <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-分析查询语句-explain" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 分析查询语句：EXPLAIN"><!--[--><!--]--> 4. 分析查询语句：EXPLAIN <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-基本语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 基本语法"><!--[--><!--]--> 4.1 基本语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-explain各列作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 EXPLAIN各列作用"><!--[--><!--]--> 4.2 EXPLAIN各列作用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-explain的进一步使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. EXPLAIN的进一步使用"><!--[--><!--]--> 5. EXPLAIN的进一步使用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-1-explain四种输出格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 EXPLAIN四种输出格式"><!--[--><!--]--> 5.1 EXPLAIN四种输出格式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-2-show-warnings的使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 SHOW WARNINGS的使用"><!--[--><!--]--> 5.2 SHOW WARNINGS的使用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-分析优化器执行计划-trace" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. 分析优化器执行计划：trace"><!--[--><!--]--> 6. 分析优化器执行计划：trace <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_7-mysql监控分析视图-sys-schema" class="router-link-active router-link-exact-active sidebar-item" aria-label="7. MySQL监控分析视图-sys schema"><!--[--><!--]--> 7. MySQL监控分析视图-sys schema <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_7-1-sys-schema视图使用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.1 Sys schema视图使用场景"><!--[--><!--]--> 7.1 Sys schema视图使用场景 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第10章-索引优化与查询优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="第10章 索引优化与查询优化"><!--[--><!--]--> 第10章 索引优化与查询优化 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-索引失效案例" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 索引失效案例"><!--[--><!--]--> 1. 索引失效案例 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-全值匹配我最爱" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 全值匹配我最爱"><!--[--><!--]--> 1.1 全值匹配我最爱 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-最佳左前缀法则" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 最佳左前缀法则"><!--[--><!--]--> 1.2 最佳左前缀法则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-主键插入顺序" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 主键插入顺序"><!--[--><!--]--> 1.3 主键插入顺序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-4-计算、函数、类型转换-自动或手动-导致索引失效" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 计算、函数、类型转换(自动或手动)导致索引失效"><!--[--><!--]--> 1.4 计算、函数、类型转换(自动或手动)导致索引失效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-5-类型转换导致索引失效" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 类型转换导致索引失效"><!--[--><!--]--> 1.5 类型转换导致索引失效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-6-范围条件右边的列索引失效" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.6 范围条件右边的列索引失效"><!--[--><!--]--> 1.6 范围条件右边的列索引失效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-7-不等于-或者-索引失效" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.7 不等于(!= 或者&lt;&gt;)索引失效"><!--[--><!--]--> 1.7 不等于(!= 或者&lt;&gt;)索引失效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-8-is-null可以使用索引-is-not-null无法使用索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.8 is null可以使用索引，is not null无法使用索引"><!--[--><!--]--> 1.8 is null可以使用索引，is not null无法使用索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-9-like以通配符-开头索引失效" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.9 like以通配符%开头索引失效"><!--[--><!--]--> 1.9 like以通配符%开头索引失效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-10-or-前后存在非索引的列-索引失效" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.10 OR 前后存在非索引的列，索引失效"><!--[--><!--]--> 1.10 OR 前后存在非索引的列，索引失效 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-11-数据库和表的字符集统一使用utf8mb4" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.11 数据库和表的字符集统一使用utf8mb4"><!--[--><!--]--> 1.11 数据库和表的字符集统一使用utf8mb4 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-关联查询优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 关联查询优化"><!--[--><!--]--> 2. 关联查询优化 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-内连接" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 内连接"><!--[--><!--]--> 2.1 内连接 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-外连接" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 外连接"><!--[--><!--]--> 2.2 外连接 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-join语句原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 JOIN语句原理"><!--[--><!--]--> 2.3 JOIN语句原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-子查询优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 子查询优化"><!--[--><!--]--> 3. 子查询优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-排序优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 排序优化"><!--[--><!--]--> 4. 排序优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-group-by优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. GROUP BY优化"><!--[--><!--]--> 5. GROUP BY优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-优化分页查询" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. 优化分页查询"><!--[--><!--]--> 6. 优化分页查询 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_7-优先考虑覆盖索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="7. 优先考虑覆盖索引"><!--[--><!--]--> 7. 优先考虑覆盖索引 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_7-1-什么是覆盖索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.1 什么是覆盖索引？"><!--[--><!--]--> 7.1 什么是覆盖索引？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_7-2-覆盖索引的利弊" class="router-link-active router-link-exact-active sidebar-item" aria-label="7.2 覆盖索引的利弊"><!--[--><!--]--> 7.2 覆盖索引的利弊 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_8-索引条件下推" class="router-link-active router-link-exact-active sidebar-item" aria-label="8. 索引条件下推"><!--[--><!--]--> 8. 索引条件下推 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_8-1-使用前后的扫描过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.1 使用前后的扫描过程"><!--[--><!--]--> 8.1 使用前后的扫描过程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_9-其它查询优化策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="9. 其它查询优化策略"><!--[--><!--]--> 9. 其它查询优化策略 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_9-1-exists-和-in-的区分" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.1 EXISTS 和 IN 的区分"><!--[--><!--]--> 9.1 EXISTS 和 IN 的区分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_9-2-count-与count-具体字段-效率" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.2 COUNT(*)与COUNT(具体字段)效率"><!--[--><!--]--> 9.2 COUNT(*)与COUNT(具体字段)效率 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_9-3-关于select" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.3 关于SELECT(*)"><!--[--><!--]--> 9.3 关于SELECT(*) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_9-4-limit-1-对优化的影响" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.4 LIMIT 1 对优化的影响"><!--[--><!--]--> 9.4 LIMIT 1 对优化的影响 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_9-5-多使用commit" class="router-link-active router-link-exact-active sidebar-item" aria-label="9.5 多使用COMMIT"><!--[--><!--]--> 9.5 多使用COMMIT <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第11章-数据库的设计规范" class="router-link-active router-link-exact-active sidebar-item" aria-label="第11章 数据库的设计规范"><!--[--><!--]--> 第11章 数据库的设计规范 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-范-式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 范 式"><!--[--><!--]--> 1. 范 式 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-范式简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 范式简介"><!--[--><!--]--> 1.1 范式简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-范式都包括哪些" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 范式都包括哪些"><!--[--><!--]--> 1.2 范式都包括哪些 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-键和相关属性的概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 键和相关属性的概念"><!--[--><!--]--> 1.3 键和相关属性的概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-4-第一范式-1st-nf" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 第一范式(1st NF)"><!--[--><!--]--> 1.4 第一范式(1st NF) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-5-第二范式-2nd-nf" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 第二范式(2nd NF)"><!--[--><!--]--> 1.5 第二范式(2nd NF) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-6-第三范式-3rd-nf" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.6 第三范式(3rd NF)"><!--[--><!--]--> 1.6 第三范式(3rd NF) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-7-小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.7 小结"><!--[--><!--]--> 1.7 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-反范式化" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 反范式化"><!--[--><!--]--> 2. 反范式化 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 概述"><!--[--><!--]--> 2.1 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-反范式的新问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 反范式的新问题"><!--[--><!--]--> 2.2 反范式的新问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-反范式的适用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 反范式的适用场景"><!--[--><!--]--> 2.3 反范式的适用场景 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-bcnf-巴斯范式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. BCNF(巴斯范式)"><!--[--><!--]--> 3. BCNF(巴斯范式) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-er模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. ER模型"><!--[--><!--]--> 4. ER模型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-er-模型包括那些要素" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 ER 模型包括那些要素？"><!--[--><!--]--> 4.1 ER 模型包括那些要素？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-关系的类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 关系的类型"><!--[--><!--]--> 4.2 关系的类型 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-数据表的设计原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 数据表的设计原则"><!--[--><!--]--> 5. 数据表的设计原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-数据库对象编写建议" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. 数据库对象编写建议"><!--[--><!--]--> 6. 数据库对象编写建议 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-1-关于库" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.1 关于库"><!--[--><!--]--> 6.1 关于库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-2-关于表、列" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.2 关于表、列"><!--[--><!--]--> 6.2 关于表、列 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-3-关于索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.3 关于索引"><!--[--><!--]--> 6.3 关于索引 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-4-sql编写" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.4 SQL编写"><!--[--><!--]--> 6.4 SQL编写 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第12章-数据库其它调优策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="第12章 数据库其它调优策略"><!--[--><!--]--> 第12章 数据库其它调优策略 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-数据库调优的措施" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 数据库调优的措施"><!--[--><!--]--> 1. 数据库调优的措施 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-调优的目标" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 调优的目标"><!--[--><!--]--> 1.1 调优的目标 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-如何定位调优问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 如何定位调优问题"><!--[--><!--]--> 1.2 如何定位调优问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-调优的维度和步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 调优的维度和步骤"><!--[--><!--]--> 1.3 调优的维度和步骤 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-优化mysql服务器" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 优化MySQL服务器"><!--[--><!--]--> 2. 优化MySQL服务器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-优化服务器硬件" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 优化服务器硬件"><!--[--><!--]--> 2.1 优化服务器硬件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-优化mysql的参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 优化MySQL的参数"><!--[--><!--]--> 2.2 优化MySQL的参数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-优化数据库结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 优化数据库结构"><!--[--><!--]--> 3. 优化数据库结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-拆分表-冷热数据分离" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 拆分表：冷热数据分离"><!--[--><!--]--> 3.1 拆分表：冷热数据分离 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-增加中间表" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 增加中间表"><!--[--><!--]--> 3.2 增加中间表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-增加冗余字段" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 增加冗余字段"><!--[--><!--]--> 3.3 增加冗余字段 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-优化数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 优化数据类型"><!--[--><!--]--> 3.4 优化数据类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-5-优化插入记录的速度" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 优化插入记录的速度"><!--[--><!--]--> 3.5 优化插入记录的速度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-6-使用非空约束" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.6 使用非空约束"><!--[--><!--]--> 3.6 使用非空约束 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-7-分析表、检查表与优化表" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.7 分析表、检查表与优化表"><!--[--><!--]--> 3.7 分析表、检查表与优化表 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-大表优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.大表优化"><!--[--><!--]--> 4.大表优化 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-限定查询的范围" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 限定查询的范围"><!--[--><!--]--> 4.1 限定查询的范围 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-读写分离" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 读写分离"><!--[--><!--]--> 4.2 读写分离 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-3-垂直拆分" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 垂直拆分"><!--[--><!--]--> 4.3 垂直拆分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-4-水平拆分" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 水平拆分"><!--[--><!--]--> 4.4 水平拆分 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第13章-事务基础知识" class="router-link-active router-link-exact-active sidebar-item" aria-label="第13章 事务基础知识"><!--[--><!--]--> 第13章 事务基础知识 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-数据库事务概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 数据库事务概述"><!--[--><!--]--> 1. 数据库事务概述 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-基本概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 基本概念"><!--[--><!--]--> 1.1 基本概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-事务的acid特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 事务的ACID特性"><!--[--><!--]--> 1.2 事务的ACID特性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-事务的状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 事务的状态"><!--[--><!--]--> 1.3 事务的状态 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-如何使用事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 如何使用事务"><!--[--><!--]--> 2. 如何使用事务 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-显式事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 显式事务"><!--[--><!--]--> 2.1 显式事务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-隐式事务" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 隐式事务"><!--[--><!--]--> 2.2 隐式事务 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-隐式提交数据的情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 隐式提交数据的情况"><!--[--><!--]--> 2.3 隐式提交数据的情况 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-小结-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 小结"><!--[--><!--]--> 2.4 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-事务隔离级别" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 事务隔离级别"><!--[--><!--]--> 3. 事务隔离级别 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-数据并发问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 数据并发问题"><!--[--><!--]--> 3.1 数据并发问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-sql中的四种隔离级别" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 SQL中的四种隔离级别"><!--[--><!--]--> 3.2 SQL中的四种隔离级别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-如何设置事务的隔离级别" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 如何设置事务的隔离级别"><!--[--><!--]--> 3.3 如何设置事务的隔离级别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第14章-mysql事务日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="第14章 MySQL事务日志"><!--[--><!--]--> 第14章 MySQL事务日志 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-redo日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. redo日志"><!--[--><!--]--> 1. redo日志 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-为什么需要redo日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 为什么需要REDO日志"><!--[--><!--]--> 1.1 为什么需要REDO日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-redo日志的好处、特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 REDO日志的好处、特点"><!--[--><!--]--> 1.2 REDO日志的好处、特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-3-redo的组成" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 redo的组成"><!--[--><!--]--> 1.3 redo的组成 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-4-redo的整体流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 redo的整体流程"><!--[--><!--]--> 1.4 redo的整体流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-5-redo-log的刷盘策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 redo log的刷盘策略"><!--[--><!--]--> 1.5 redo log的刷盘策略 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-6-不同刷盘策略演示" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.6 不同刷盘策略演示"><!--[--><!--]--> 1.6 不同刷盘策略演示 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-7-写入redo-log-buffer过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.7 写入redo log buffer过程"><!--[--><!--]--> 1.7 写入redo log buffer过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-8-redo-log-file" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.8 redo log file"><!--[--><!--]--> 1.8 redo log file <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-undo日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Undo日志"><!--[--><!--]--> 2. Undo日志 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-如何理解undo日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 如何理解Undo日志"><!--[--><!--]--> 2.1 如何理解Undo日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-undo日志的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 Undo日志的作用"><!--[--><!--]--> 2.2 Undo日志的作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-undo的存储结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 undo的存储结构"><!--[--><!--]--> 2.3 undo的存储结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-undo的类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 undo的类型"><!--[--><!--]--> 2.4 undo的类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-5-undo-log的生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 undo log的生命周期"><!--[--><!--]--> 2.5 undo log的生命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-6-小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.6 小结"><!--[--><!--]--> 2.6 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第15章-锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="第15章 锁"><!--[--><!--]--> 第15章 锁 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 概述"><!--[--><!--]--> 1. 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-mysql并发事务访问相同记录" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. MySQL并发事务访问相同记录"><!--[--><!--]--> 2. MySQL并发事务访问相同记录 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-读-读情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 读-读情况"><!--[--><!--]--> 2.1 读-读情况 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-写-写情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 写-写情况"><!--[--><!--]--> 2.2 写-写情况 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-读-写或写-读情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 读-写或写-读情况"><!--[--><!--]--> 2.3 读-写或写-读情况 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-并发问题的解决方案" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 并发问题的解决方案"><!--[--><!--]--> 2.4 并发问题的解决方案 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-锁的不同角度分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 锁的不同角度分类"><!--[--><!--]--> 3. 锁的不同角度分类 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-从数据操作的类型划分-读锁、写锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 从数据操作的类型划分：读锁、写锁"><!--[--><!--]--> 3.1 从数据操作的类型划分：读锁、写锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"><!--[--><!--]--> 3.2 从数据操作的粒度划分：表级锁、页级锁、行锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-从对待锁的态度划分-乐观锁、悲观锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 从对待锁的态度划分:乐观锁、悲观锁"><!--[--><!--]--> 3.3 从对待锁的态度划分:乐观锁、悲观锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-按加锁的方式划分-显式锁、隐式锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 按加锁的方式划分：显式锁、隐式锁"><!--[--><!--]--> 3.4 按加锁的方式划分：显式锁、隐式锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-5-其它锁之-全局锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 其它锁之：全局锁"><!--[--><!--]--> 3.5 其它锁之：全局锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-6-其它锁之-死锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.6 其它锁之：死锁"><!--[--><!--]--> 3.6 其它锁之：死锁 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-锁的内存结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 锁的内存结构"><!--[--><!--]--> 4. 锁的内存结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-锁监控" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 锁监控"><!--[--><!--]--> 5. 锁监控 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第16章-多版本并发控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="第16章 多版本并发控制"><!--[--><!--]--> 第16章 多版本并发控制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-什么是mvcc" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 什么是MVCC"><!--[--><!--]--> 1. 什么是MVCC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-快照读与当前读" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 快照读与当前读"><!--[--><!--]--> 2. 快照读与当前读 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-快照读" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 快照读"><!--[--><!--]--> 2.1 快照读 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-当前读" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 当前读"><!--[--><!--]--> 2.2 当前读 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-复习" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 复习"><!--[--><!--]--> 3. 复习 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-再谈隔离级别" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 再谈隔离级别"><!--[--><!--]--> 3.1 再谈隔离级别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-隐藏字段、undo-log版本链" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 隐藏字段、Undo Log版本链"><!--[--><!--]--> 3.2 隐藏字段、Undo Log版本链 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-mvcc实现原理之readview" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. MVCC实现原理之ReadView"><!--[--><!--]--> 4. MVCC实现原理之ReadView <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-什么是readview" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 什么是ReadView"><!--[--><!--]--> 4.1 什么是ReadView <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-设计思路" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 设计思路"><!--[--><!--]--> 4.2 设计思路 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-3-readview的规则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 ReadView的规则"><!--[--><!--]--> 4.3 ReadView的规则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-4-mvcc整体操作流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 MVCC整体操作流程"><!--[--><!--]--> 4.4 MVCC整体操作流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-举例说明" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 举例说明"><!--[--><!--]--> 5. 举例说明 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-1-read-committed隔离级别下" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 READ COMMITTED隔离级别下"><!--[--><!--]--> 5.1 READ COMMITTED隔离级别下 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-2-repeatable-read隔离级别下" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 REPEATABLE READ隔离级别下"><!--[--><!--]--> 5.2 REPEATABLE READ隔离级别下 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-3-如何解决幻读" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.3 如何解决幻读"><!--[--><!--]--> 5.3 如何解决幻读 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. 总结"><!--[--><!--]--> 6. 总结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第17章-其它数据库日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="第17章 其它数据库日志"><!--[--><!--]--> 第17章 其它数据库日志 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-mysql支持的日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. MySQL支持的日志"><!--[--><!--]--> 1. MySQL支持的日志 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-日志类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 日志类型"><!--[--><!--]--> 1.1 日志类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-日志的弊端" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 日志的弊端"><!--[--><!--]--> 1.2 日志的弊端 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-通用查询日志-general-query-log" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 通用查询日志(general query log)"><!--[--><!--]--> 2. 通用查询日志(general query log) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-查看当前状态" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 查看当前状态"><!--[--><!--]--> 2.1 查看当前状态 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-启动日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 启动日志"><!--[--><!--]--> 2.2 启动日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-停止日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 停止日志"><!--[--><!--]--> 2.3 停止日志 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-错误日志-error-log" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.错误日志(error log)"><!--[--><!--]--> 3.错误日志(error log) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-启动日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 启动日志"><!--[--><!--]--> 3.1 启动日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-查看日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 查看日志"><!--[--><!--]--> 3.2 查看日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-删除-刷新日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 删除\刷新日志"><!--[--><!--]--> 3.3 删除\刷新日志 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-二进制日志-bin-log" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 二进制日志(bin log)"><!--[--><!--]--> 4. 二进制日志(bin log) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-查看默认情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 查看默认情况"><!--[--><!--]--> 4.1 查看默认情况 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-日志参数设置" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 日志参数设置"><!--[--><!--]--> 4.2 日志参数设置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-3-查看日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 查看日志"><!--[--><!--]--> 4.3 查看日志 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-4-使用日志恢复数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 使用日志恢复数据"><!--[--><!--]--> 4.4 使用日志恢复数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-5-删除二进制日志" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.5 删除二进制日志"><!--[--><!--]--> 4.5 删除二进制日志 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-再谈二进制日志-binlog" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. 再谈二进制日志(binlog)"><!--[--><!--]--> 5. 再谈二进制日志(binlog) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-1-写入机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 写入机制"><!--[--><!--]--> 5.1 写入机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-2-binlog与redolog对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 binlog与redolog对比"><!--[--><!--]--> 5.2 binlog与redolog对比 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_5-3-两阶段提交" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.3 两阶段提交"><!--[--><!--]--> 5.3 两阶段提交 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-中继日志-relay-log" class="router-link-active router-link-exact-active sidebar-item" aria-label="6. 中继日志(relay log)"><!--[--><!--]--> 6. 中继日志(relay log) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-1-介绍" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.1 介绍"><!--[--><!--]--> 6.1 介绍 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_6-2-恢复的典型错误" class="router-link-active router-link-exact-active sidebar-item" aria-label="6.2 恢复的典型错误"><!--[--><!--]--> 6.2 恢复的典型错误 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第18章-主从复制" class="router-link-active router-link-exact-active sidebar-item" aria-label="第18章 主从复制"><!--[--><!--]--> 第18章 主从复制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-主从复制概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 主从复制概述"><!--[--><!--]--> 1. 主从复制概述 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-1-如何提升数据库并发能力" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 如何提升数据库并发能力"><!--[--><!--]--> 1.1 如何提升数据库并发能力 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-2-主从复制的作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 主从复制的作用"><!--[--><!--]--> 1.2 主从复制的作用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-主从复制的原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 主从复制的原理"><!--[--><!--]--> 2. 主从复制的原理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-原理剖析" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 原理剖析"><!--[--><!--]--> 2.1 原理剖析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-复制的基本原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 复制的基本原则"><!--[--><!--]--> 2.2 复制的基本原则 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-同步数据一致性问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 同步数据一致性问题"><!--[--><!--]--> 3. 同步数据一致性问题 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-理解主从延迟问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 理解主从延迟问题"><!--[--><!--]--> 3.1 理解主从延迟问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-主从延迟问题原因" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 主从延迟问题原因"><!--[--><!--]--> 3.2 主从延迟问题原因 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-如何减少主从延迟" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 如何减少主从延迟"><!--[--><!--]--> 3.3 如何减少主从延迟 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-如何解决一致性问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 如何解决一致性问题"><!--[--><!--]--> 3.4 如何解决一致性问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#第19章-数据库备份与恢复" class="router-link-active router-link-exact-active sidebar-item" aria-label="第19章 数据库备份与恢复"><!--[--><!--]--> 第19章 数据库备份与恢复 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_1-物理备份与逻辑备份" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 物理备份与逻辑备份"><!--[--><!--]--> 1. 物理备份与逻辑备份 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-mysqldump实现逻辑备份" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. mysqldump实现逻辑备份"><!--[--><!--]--> 2. mysqldump实现逻辑备份 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-1-备份一个数据库" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 备份一个数据库"><!--[--><!--]--> 2.1 备份一个数据库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-2-备份全部数据库" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 备份全部数据库"><!--[--><!--]--> 2.2 备份全部数据库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-3-备份部分数据库" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 备份部分数据库"><!--[--><!--]--> 2.3 备份部分数据库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-4-备份部分表" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 备份部分表"><!--[--><!--]--> 2.4 备份部分表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-5-备份单表的部分数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 备份单表的部分数据"><!--[--><!--]--> 2.5 备份单表的部分数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-6-排除某些表的备份" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.6 排除某些表的备份"><!--[--><!--]--> 2.6 排除某些表的备份 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-7-只备份结构或只备份数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.7 只备份结构或只备份数据"><!--[--><!--]--> 2.7 只备份结构或只备份数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_2-8-备份中包含存储过程、函数、事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.8 备份中包含存储过程、函数、事件"><!--[--><!--]--> 2.8 备份中包含存储过程、函数、事件 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-mysql命令恢复数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. mysql命令恢复数据"><!--[--><!--]--> 3. mysql命令恢复数据 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-1-单库备份中恢复单库" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1 单库备份中恢复单库"><!--[--><!--]--> 3.1 单库备份中恢复单库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-2-全量备份恢复" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 全量备份恢复"><!--[--><!--]--> 3.2 全量备份恢复 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-3-从全量备份中恢复单库" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 从全量备份中恢复单库"><!--[--><!--]--> 3.3 从全量备份中恢复单库 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_3-4-从单库备份中恢复单表" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 从单库备份中恢复单表"><!--[--><!--]--> 3.4 从单库备份中恢复单表 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-表的导出与导入" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 表的导出与导入"><!--[--><!--]--> 4. 表的导出与导入 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-1-表的导出" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 表的导出"><!--[--><!--]--> 4.1 表的导出 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%AB%98%E7%BA%A7%E7%AF%87/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86.html#_4-2-表的导入" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 表的导入"><!--[--><!--]--> 4.2 表的导入 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="第二部分-mysql高级特性篇" tabindex="-1"><a class="header-anchor" href="#第二部分-mysql高级特性篇" aria-hidden="true">#</a> 第二部分 MySQL高级特性篇</h1><h2 id="第01章-linux下mysql的安装与使用" tabindex="-1"><a class="header-anchor" href="#第01章-linux下mysql的安装与使用" aria-hidden="true">#</a> 第01章 Linux下MySQL的安装与使用</h2><h3 id="_1-安装前说明" tabindex="-1"><a class="header-anchor" href="#_1-安装前说明" aria-hidden="true">#</a> <strong>1.</strong> <strong>安装前说明</strong></h3><h4 id="_1-1-查看是否安装过mysql" tabindex="-1"><a class="header-anchor" href="#_1-1-查看是否安装过mysql" aria-hidden="true">#</a> <strong>1.1</strong> <strong>查看是否安装过MySQL</strong></h4><ul><li>如果你是用rpm安装, 检查一下RPM PACKAGE：</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">rpm</span> -qa <span class="token operator">|</span> <span class="token function">grep</span> -i mysql <span class="token comment"># -i 忽略大小写</span>
</code></pre></div><ul><li>检查mysql service：</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>systemctl status mysqld.service
</code></pre></div><h4 id="_1-2-mysql的卸载" tabindex="-1"><a class="header-anchor" href="#_1-2-mysql的卸载" aria-hidden="true">#</a> <strong>1.2 MySQL的卸载</strong></h4><p><strong>1.</strong> <strong>关闭</strong> <strong>mysql</strong> <strong>服务</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>systemctl stop mysqld.service
</code></pre></div><p><strong>2.</strong> <strong>查看当前</strong> <strong>mysql</strong> <strong>安装状况</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">rpm</span> -qa <span class="token operator">|</span> <span class="token function">grep</span> -i mysql
<span class="token comment"># 或</span>
yum list installed <span class="token operator">|</span> <span class="token function">grep</span> mysql
</code></pre></div><p><strong>3.</strong> <strong>卸载上述命令查询出的已安装程序</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx
</code></pre></div><p>务必卸载干净，反复执行<code>rpm -qa | grep -i mysql</code>确认是否有卸载残留</p><p><strong>4.</strong> <strong>删除</strong> <strong>mysql</strong> <strong>相关文件</strong></p><ul><li>查找相关文件</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">find</span> / -name mysql
</code></pre></div><ul><li>删除上述命令查找出的相关文件</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">rm</span> -rf xxx
</code></pre></div><p><strong>5.删除 my.cnf</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">rm</span> -rf /etc/my.cnf
</code></pre></div><h3 id="_2-mysql的linux版安装" tabindex="-1"><a class="header-anchor" href="#_2-mysql的linux版安装" aria-hidden="true">#</a> <strong>2. MySQL的Linux版安装</strong></h3><h4 id="_2-1-centos7下检查mysql依赖" tabindex="-1"><a class="header-anchor" href="#_2-1-centos7下检查mysql依赖" aria-hidden="true">#</a> <strong>2.1 CentOS7下检查MySQL依赖</strong></h4><p><strong>1.</strong> <strong>检查/tmp临时目录权限（必不可少）</strong></p><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限。执行 ：</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">chmod</span> -R <span class="token number">777</span> /tmp
</code></pre></div><p><strong>2.</strong> <strong>安装前，检查依赖</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">rpm</span> -qa<span class="token operator">|</span><span class="token function">grep</span> libaio
<span class="token function">rpm</span> -qa<span class="token operator">|</span><span class="token function">grep</span> net-tools
</code></pre></div><h4 id="_2-2-centos7下mysql安装过程" tabindex="-1"><a class="header-anchor" href="#_2-2-centos7下mysql安装过程" aria-hidden="true">#</a> <strong>2.2 CentOS7下MySQL安装过程</strong></h4><p><strong>1.</strong> <strong>将安装程序拷贝到/opt目录下</strong></p><p>在mysql的安装文件目录下执行：（必须按照顺序执行）</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">rpm</span> -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm 
<span class="token function">rpm</span> -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm 
<span class="token function">rpm</span> -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm 
<span class="token function">rpm</span> -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm 
<span class="token function">rpm</span> -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm
</code></pre></div><ul><li><code>rpm</code>是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。</li><li><code>-i</code>, --install 安装软件包</li><li><code>-v</code>, --verbose 提供更多的详细信息输出</li><li><code>-h</code>, --hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</li></ul><blockquote><p>若存在mariadb-libs问题，则执行<strong>yum remove mysql-libs</strong>即可</p></blockquote><h4 id="_2-3-查看mysql版本" tabindex="-1"><a class="header-anchor" href="#_2-3-查看mysql版本" aria-hidden="true">#</a> <strong>2.3</strong> <strong>查看MySQL版本</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysql --version 
<span class="token comment">#或</span>
mysqladmin --version
</code></pre></div><h4 id="_2-4-服务的初始化" tabindex="-1"><a class="header-anchor" href="#_2-4-服务的初始化" aria-hidden="true">#</a> <strong>2.4</strong> <strong>服务的初始化</strong></h4><p>为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化：</p><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqld --initialize --user<span class="token operator">=</span>mysql
</code></pre></div><p>说明： --initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将<code>该密码标记为过期</code>，登录后你需要设置一个新的密码。生成的<code>临时密码</code>会往日志中记录一份。</p><p>查看密码：</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">cat</span> /var/log/mysqld.log
</code></pre></div><p>root@localhost: 后面就是初始化的密码</p><h4 id="_2-5-启动mysql-查看状态" tabindex="-1"><a class="header-anchor" href="#_2-5-启动mysql-查看状态" aria-hidden="true">#</a> <strong>2.5</strong> <strong>启动MySQL，查看状态</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token comment">#加不加.service后缀都可以 </span>
启动：systemctl start mysqld.service 
关闭：systemctl stop mysqld.service 
重启：systemctl restart mysqld.service 
查看状态：systemctl status mysqld.service
</code></pre></div><h4 id="_2-6-查看mysql服务是否自启动" tabindex="-1"><a class="header-anchor" href="#_2-6-查看mysql服务是否自启动" aria-hidden="true">#</a> <strong>2.6</strong> <strong>查看MySQL服务是否自启动</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>systemctl list-unit-files<span class="token operator">|</span><span class="token function">grep</span> mysqld.service
</code></pre></div><ul><li>如不是enabled可以运行如下命令设置自启动</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>systemctl <span class="token builtin class-name">enable</span> mysqld.service
</code></pre></div><ul><li>如果希望不进行自启动，运行如下命令设置</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>systemctl disable mysqld.service
</code></pre></div><h3 id="_3-mysql登录" tabindex="-1"><a class="header-anchor" href="#_3-mysql登录" aria-hidden="true">#</a> <strong>3. MySQL登录</strong></h3><h4 id="_3-1-首次登录" tabindex="-1"><a class="header-anchor" href="#_3-1-首次登录" aria-hidden="true">#</a> <strong>3.1</strong> <strong>首次登录</strong></h4><p>通过<code>mysql -hlocalhost -P3306 -uroot -p</code>进行登录，在Enter password：录入初始化密码</p><h4 id="_3-2-修改密码" tabindex="-1"><a class="header-anchor" href="#_3-2-修改密码" aria-hidden="true">#</a> <strong>3.2</strong> <strong>修改密码</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;
</code></pre></div><h4 id="_3-3-设置远程登录" tabindex="-1"><a class="header-anchor" href="#_3-3-设置远程登录" aria-hidden="true">#</a> <strong>3.3</strong> <strong>设置远程登录</strong></h4><p><strong>1.</strong> <strong>确认网络</strong></p><p>1.在远程机器上使用ping ip地址<code>保证网络畅通</code></p><p>2.在远程机器上使用telnet命令<code>保证端口号开放</code>访问</p><p><strong>2.</strong> <strong>关闭防火墙或开放端口</strong></p><p><strong>方式一：关闭防火墙</strong></p><ul><li>CentOS6 ：</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">service</span> iptables stop
</code></pre></div><ul><li>CentOS7：</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token comment">#开启防火墙</span>
systemctl start firewalld.service
<span class="token comment">#查看防火墙状态</span>
systemctl status firewalld.service
<span class="token comment">#关闭防火墙</span>
systemctl stop firewalld.service
<span class="token comment">#设置开机启用防火墙 </span>
systemctl <span class="token builtin class-name">enable</span> firewalld.service 
<span class="token comment">#设置开机禁用防火墙 </span>
systemctl disable firewalld.service
</code></pre></div><p><strong>方式二：开放端口</strong></p><ul><li>查看开放的端口号</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>firewall-cmd --list-all
</code></pre></div><ul><li>设置开放的端口号</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>firewall-cmd --add-service<span class="token operator">=</span>http --permanent
firewall-cmd --add-port<span class="token operator">=</span><span class="token number">3306</span>/tcp --permanent
</code></pre></div><ul><li>重启防火墙</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>firewall-cmd --reload
</code></pre></div><h3 id="_4-linux下修改配置" tabindex="-1"><a class="header-anchor" href="#_4-linux下修改配置" aria-hidden="true">#</a> <strong>4. Linux下修改配置</strong></h3><ul><li>修改允许远程登陆</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>use mysql;
select Host,User from user;
update user set host = &#39;%&#39; where user =&#39;root&#39;;
flush privileges;
</code></pre></div><blockquote><p><code>%</code>是个 通配符 ，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果<code>Host=%</code>，表示所有IP都有连接权限。</p><p>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。</p></blockquote><p>配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。</p><p>**解决方法一：**升级远程连接工具版本</p><p><strong>解决方法二：</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;abc123&#39;;
</code></pre></div><h3 id="_5-字符集的相关操作" tabindex="-1"><a class="header-anchor" href="#_5-字符集的相关操作" aria-hidden="true">#</a> <strong>5.</strong> <strong>字符集的相关操作</strong></h3><h4 id="_5-1-各级别的字符集" tabindex="-1"><a class="header-anchor" href="#_5-1-各级别的字符集" aria-hidden="true">#</a> <strong>5.1</strong> <strong>各级别的字符集</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;character%&#39;;
</code></pre></div><ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul><p><strong>小结</strong></p><ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul><h4 id="_5-2-请求到响应过程中字符集的变化" tabindex="-1"><a class="header-anchor" href="#_5-2-请求到响应过程中字符集的变化" aria-hidden="true">#</a> <strong>5.2</strong> <strong>请求到响应过程中字符集的变化</strong></h4><div class="language-mermaid ext-mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TB
A<span class="token text string">(客户端)</span> <span class="token arrow operator">--&gt;</span> <span class="token label property">|&quot;使用操作系统的字符集编码请求字符串&quot;|</span> B<span class="token text string">(从character_set_client转换为character_set_connection)</span>
B <span class="token arrow operator">--&gt;</span> C<span class="token text string">(从character_set_connection转换为具体的列使用的字符集)</span>
C <span class="token arrow operator">--&gt;</span> D<span class="token text string">(将查询结果从具体的列上使用的字符集转换为character_set_results)</span>
D <span class="token arrow operator">--&gt;</span> <span class="token label property">|&quot;使用操作系统的字符集解码响应的字符串&quot;|</span> A

</code></pre></div><h2 id="第02章-mysql的数据目录" tabindex="-1"><a class="header-anchor" href="#第02章-mysql的数据目录" aria-hidden="true">#</a> 第02章 MySQL的数据目录</h2><h3 id="_1-mysql8的主要目录结构" tabindex="-1"><a class="header-anchor" href="#_1-mysql8的主要目录结构" aria-hidden="true">#</a> <strong>1. MySQL8的主要目录结构</strong></h3><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">find</span> / -name mysql
</code></pre></div><h4 id="_1-1-数据库文件的存放路径" tabindex="-1"><a class="header-anchor" href="#_1-1-数据库文件的存放路径" aria-hidden="true">#</a> <strong>1.1</strong> <strong>数据库文件的存放路径</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;datadir&#39;; # /var/lib/mysql/
</code></pre></div><p>这个数据库文件的存放路径，就相当于在windows中c盘 program data目录下的，存放数据库里的数据的路径</p><p>里面有我们创建的表以及表中的数据，这是mysql的数据路径。</p><p>在my.cnf文件中还能配置mysql的baseDir，这是mysql的安装路径。</p><h4 id="_1-2-相关命令目录" tabindex="-1"><a class="header-anchor" href="#_1-2-相关命令目录" aria-hidden="true">#</a> <strong>1.2</strong> <strong>相关命令目录</strong></h4><p><strong>相关命令目录：/usr/bin 和/usr/sbin。</strong></p><h4 id="_1-3-配置文件目录" tabindex="-1"><a class="header-anchor" href="#_1-3-配置文件目录" aria-hidden="true">#</a> <strong>1.3</strong> <strong>配置文件目录</strong></h4><p><strong>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</strong></p><h3 id="_2-数据库和文件系统的关系" tabindex="-1"><a class="header-anchor" href="#_2-数据库和文件系统的关系" aria-hidden="true">#</a> <strong>2.</strong> <strong>数据库和文件系统的关系</strong></h3><p>像InnoDB、MyISAM这样的存储引擎都是把表存储在磁盘上的，操作系统用来管理磁盘的结构被称为<code>文件系统</code>，所以用专业一点的话来表述就是：像InnoDB、MyISAM这样的存储引擎都是把表存储在文件系统上的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎会把这些数据又写回文件系统。本章学习一下InnoDB和MyISAM这两个存储引擎如何在文件系统中进行存储。</p><h4 id="_2-1-查看默认数据库" tabindex="-1"><a class="header-anchor" href="#_2-1-查看默认数据库" aria-hidden="true">#</a> 2.1 查看默认数据库</h4><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到有4个数据库是属于MySQL自带的系统数据库。</p><ul><li><p><code>mysql</code></p><p>MySQL系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息及时区信息等。</p></li><li><p><code>information_schema</code></p><p>MySQL系统自带的数据库，这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称为元数据（描述数据的数据）。在系统数据库information_schema中提供了一些以innodb_sys开头的表用于表示内部系统表。</p></li><li><p><code>performance_schema</code></p><p>MySQL系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来监控MySQL服务的各项性能指标，包括统计最近执行了哪些语句，在执行过程中的每个阶段都花费了多长时间，内存的使用情况等信息。</p></li><li><p><code>sys</code></p><p>MySQL系统自带的数据库，这个数据库主要通过视图的形式把information_schema和performance_schema结合起来，帮助系统管理员和开发人员监控MySQL的技术性能。</p></li></ul><h4 id="_2-2-数据库在文件系统中的表示" tabindex="-1"><a class="header-anchor" href="#_2-2-数据库在文件系统中的表示" aria-hidden="true">#</a> 2.2 数据库在文件系统中的表示</h4><p>使用<code>create database 数据库名</code>语句创建一个数据库的时候，在文件系统上实际发生了什么呢？其实很简单，每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，每当新建一个数据库时，MySQL会帮我们做以下两件事：</p><ul><li>在数据目录dataDir下创建一个和数据库同名的子目录。</li><li>在与该数据库同名的子目录下创建一个名为<code>db.opt</code>的文件（仅限MySQL5.7及之前版本），这个文件中包含了该数据库的各种属性，比如该数据库的字符集和比较规则。</li></ul><h4 id="_2-3-表在文件系统中的表示" tabindex="-1"><a class="header-anchor" href="#_2-3-表在文件系统中的表示" aria-hidden="true">#</a> <strong>2.3</strong> <strong>表在文件系统中的表示</strong></h4><h5 id="_2-3-1-innodb存储引擎模式" tabindex="-1"><a class="header-anchor" href="#_2-3-1-innodb存储引擎模式" aria-hidden="true">#</a> <strong>2.3.1 InnoDB存储引擎模式</strong></h5><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录(dataDir)</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><div class="language-text ext-text"><pre class="language-text"><code>表名.frm
</code></pre></div><p>这个文件里的数据是描述表结构的数据，可以理解为元数据。</p><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p><strong>① 系统表空间（system tablespace）</strong></p><p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p><p><strong>② 独立表空间(file-per-table tablespace)</strong></p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据（对于InnoDB存储引擎来说，数据和索引是存储在一起的，是聚簇索引）的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p><div class="language-text ext-text"><pre class="language-text"><code>表名.ibd
</code></pre></div><blockquote><p>MySQL8.0中不再单独提供表结构文件<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p><p>相当于表结构和表数据合一了。</p></blockquote><p><strong>③ 系统表空间与独立表空间的设置</strong></p><p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">server</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">innodb_file_per_table</span><span class="token punctuation">=</span><span class="token value attr-value">0 # 0：代表使用系统表空间； 1：代表使用独立表空间</span>
</code></pre></div><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h5 id="_2-3-2-myisam存储引擎模式" tabindex="-1"><a class="header-anchor" href="#_2-3-2-myisam存储引擎模式" aria-hidden="true">#</a> <strong>2.3.2 MyISAM存储引擎模式</strong></h5><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><div class="language-text ext-text"><pre class="language-text"><code>表名.frm
</code></pre></div><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><div class="language-text ext-text"><pre class="language-text"><code>test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sdi
test.MYD 存储数据 (MYData) 
test.MYI 存储索引 (MYIndex
</code></pre></div><p>在InnoDB中，数据即索引、索引即数据，叫做聚集索引，数据和索引是在一起的，数据和索引是存储在一起的，他们作为表数据，会存储在独立表空间中，也就是<code>表名.ibd</code>文件中。</p><p>而在MyISAM存储引擎中，表数据和索引是分开存储的，也就是表数据、索引、表的结构是三个文件。</p><p><strong>InnoDB和MyISAM两个存储引擎他们都有<code>表名.frm</code>这个表示表结构的文件。（5.7版本）</strong></p><h4 id="_2-4-小结" tabindex="-1"><a class="header-anchor" href="#_2-4-小结" aria-hidden="true">#</a> 2.4 小结</h4><p><img src="/study/assets/image-20220504000722409.81e9dd72.png" alt="image-20220504000722409"></p><h2 id="第03章-用户与权限管理" tabindex="-1"><a class="header-anchor" href="#第03章-用户与权限管理" aria-hidden="true">#</a> 第03章 用户与权限管理</h2><h3 id="_1-用户管理" tabindex="-1"><a class="header-anchor" href="#_1-用户管理" aria-hidden="true">#</a> <strong>1.</strong> <strong>用户管理</strong></h3><h4 id="_1-1-登录mysql服务器" tabindex="-1"><a class="header-anchor" href="#_1-1-登录mysql服务器" aria-hidden="true">#</a> <strong>1.1</strong> <strong>登录MySQL服务器</strong></h4><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;
</code></pre></div><ul><li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。</li><li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li><li><code>-u参数</code>后面接用户名，username为用户名。</li><li><code>-p参数</code>会提示输入密码。</li><li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;
</code></pre></div><h4 id="_1-2-创建用户" tabindex="-1"><a class="header-anchor" href="#_1-2-创建用户" aria-hidden="true">#</a> <strong>1.2</strong> <strong>创建用户</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE USER 用户名 [IDENTIFIED BY &#39;密码&#39;][,用户名 [IDENTIFIED BY &#39;密码&#39;]];
</code></pre></div><p>举例：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE USER zhang3 IDENTIFIED BY &#39;123123&#39;; # 默认host是 %
CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;
</code></pre></div><h4 id="_1-3-修改用户" tabindex="-1"><a class="header-anchor" href="#_1-3-修改用户" aria-hidden="true">#</a> <strong>1.3</strong> <strong>修改用户</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>UPDATE mysql.user SET USER=&#39;li4&#39; WHERE USER=&#39;wang5&#39;; 
FLUSH PRIVILEGES;
</code></pre></div><h4 id="_1-4-删除用户" tabindex="-1"><a class="header-anchor" href="#_1-4-删除用户" aria-hidden="true">#</a> <strong>1.4</strong> <strong>删除用户</strong></h4><p><strong>方式1：使用DROP方式删除（推荐）</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>DROP USER user[,user]…;
</code></pre></div><p>举例：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>DROP USER li4 ; # 默认删除host为%的用户
DROP USER &#39;kangshifu&#39;@&#39;localhost&#39;;
</code></pre></div><p><strong>方式2：使用DELETE方式删除（不推荐，有残留信息）</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;
FLUSH PRIVILEGES;
</code></pre></div><h4 id="_1-5-设置当前用户密码" tabindex="-1"><a class="header-anchor" href="#_1-5-设置当前用户密码" aria-hidden="true">#</a> <strong>1.5</strong> <strong>设置当前用户密码</strong></h4><p><strong>1.</strong> <strong>使用ALTER USER命令来修改当前用户密码</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER USER USER() IDENTIFIED BY &#39;new_password&#39;;
</code></pre></div><p><strong>2.</strong> <strong>使用SET语句来修改当前用户密码</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET PASSWORD=&#39;new_password&#39;;
</code></pre></div><h4 id="_1-6-修改其它用户密码" tabindex="-1"><a class="header-anchor" href="#_1-6-修改其它用户密码" aria-hidden="true">#</a> <strong>1.6</strong> <strong>修改其它用户密码</strong></h4><p><strong>1.</strong> <strong>使用ALTER语句来修改普通用户的密码</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER USER user [IDENTIFIED BY &#39;新密码&#39;] 
[,user[IDENTIFIED BY &#39;新密码&#39;]]…;
</code></pre></div><p><strong>2.</strong> <strong>使用SET命令来修改普通用户的密码</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39;=&#39;new_password&#39;;
</code></pre></div><h3 id="_2-权限管理" tabindex="-1"><a class="header-anchor" href="#_2-权限管理" aria-hidden="true">#</a> <strong>2.</strong> <strong>权限管理</strong></h3><h4 id="_2-1-权限列表" tabindex="-1"><a class="header-anchor" href="#_2-1-权限列表" aria-hidden="true">#</a> <strong>2.1</strong> <strong>权限列表</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show privileges;
</code></pre></div><ul><li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li><li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li><li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li><li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT ... INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ul><h4 id="_2-2-授予权限的原则" tabindex="-1"><a class="header-anchor" href="#_2-2-授予权限的原则" aria-hidden="true">#</a> <strong>2.2</strong> <strong>授予权限的原则</strong></h4><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p><p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p><p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p><p>3、为每个用户<code>设置满足密码复杂度的密码</code>。</p><p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p><h4 id="_2-3-授予权限" tabindex="-1"><a class="header-anchor" href="#_2-3-授予权限" aria-hidden="true">#</a> <strong>2.3</strong> <strong>授予权限</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];
</code></pre></div><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。</li><li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;
</code></pre></div><ul><li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>GRANT ALL PRIVILEGES ON *.* TO joe@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;
</code></pre></div><h4 id="_2-4-查看权限" tabindex="-1"><a class="header-anchor" href="#_2-4-查看权限" aria-hidden="true">#</a> <strong>2.4</strong> <strong>查看权限</strong></h4><ul><li>查看当前用户权限</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW GRANTS; 
# 或 
SHOW GRANTS FOR CURRENT_USER; 
# 或 
SHOW GRANTS FOR CURRENT_USER();
</code></pre></div><ul><li>查看某用户的全局权限</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW GRANTS FOR &#39;user&#39;@&#39;主机地址&#39;;
</code></pre></div><h4 id="_2-5-收回权限" tabindex="-1"><a class="header-anchor" href="#_2-5-收回权限" aria-hidden="true">#</a> <strong>2.5</strong> <strong>收回权限</strong></h4><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p><ul><li>收回权限命令</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;
</code></pre></div><ul><li>举例</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>#收回全库全表的所有权限 
REVOKE ALL PRIVILEGES ON *.* FROM joe@&#39;%&#39;; 
#收回mysql库下的所有表的插删改查权限 
REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;
</code></pre></div><ul><li>注意：<code>须用户重新登录后才能生效</code></li></ul><h3 id="_3-角色管理" tabindex="-1"><a class="header-anchor" href="#_3-角色管理" aria-hidden="true">#</a> <strong>3.</strong> <strong>角色管理</strong></h3><h4 id="_3-1-创建角色" tabindex="-1"><a class="header-anchor" href="#_3-1-创建角色" aria-hidden="true">#</a> <strong>3.1</strong> <strong>创建角色</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE ROLE &#39;role_name&#39;[@&#39;host_name&#39;] [,&#39;role_name&#39;[@&#39;host_name&#39;]]...
</code></pre></div><p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p><h4 id="_3-2-给角色赋予权限" tabindex="-1"><a class="header-anchor" href="#_3-2-给角色赋予权限" aria-hidden="true">#</a> <strong>3.2</strong> <strong>给角色赋予权限</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>GRANT privileges ON table_name TO &#39;role_name&#39;[@&#39;host_name&#39;];
</code></pre></div><p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW PRIVILEGES\G
</code></pre></div><h4 id="_3-3-查看角色的权限" tabindex="-1"><a class="header-anchor" href="#_3-3-查看角色的权限" aria-hidden="true">#</a> <strong>3.3</strong> <strong>查看角色的权限</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW GRANTS FOR &#39;role_name&#39;;
</code></pre></div><p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p><h4 id="_3-4-回收角色的权限" tabindex="-1"><a class="header-anchor" href="#_3-4-回收角色的权限" aria-hidden="true">#</a> <strong>3.4</strong> <strong>回收角色的权限</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>REVOKE privileges ON tablename FROM &#39;rolename&#39;;
</code></pre></div><h4 id="_3-5-删除角色" tabindex="-1"><a class="header-anchor" href="#_3-5-删除角色" aria-hidden="true">#</a> <strong>3.5</strong> <strong>删除角色</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>DROP ROLE role [,role2]...
</code></pre></div><p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p><h4 id="_3-6-给用户赋予角色" tabindex="-1"><a class="header-anchor" href="#_3-6-给用户赋予角色" aria-hidden="true">#</a> <strong>3.6</strong> <strong>给用户赋予角色</strong></h4><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>GRANT role [,role2,...] TO user [,user2,...];
</code></pre></div><p>查询当前已激活的角色</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SELECT CURRENT_ROLE();
</code></pre></div><h4 id="_3-7-激活角色" tabindex="-1"><a class="header-anchor" href="#_3-7-激活角色" aria-hidden="true">#</a> <strong>3.7</strong> <strong>激活角色</strong></h4><p><strong>方式1：使用set default role 命令激活角色</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET DEFAULT ROLE ALL TO &#39;kangshifu&#39;@&#39;localhost&#39;;
</code></pre></div><p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET GLOBAL activate_all_roles_on_login=ON;
</code></pre></div><p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p><h4 id="_3-8-撤销用户的角色" tabindex="-1"><a class="header-anchor" href="#_3-8-撤销用户的角色" aria-hidden="true">#</a> <strong>3.8</strong> <strong>撤销用户的角色</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>REVOKE role FROM user;
</code></pre></div><h4 id="_3-9-设置强制角色-mandatory-role" tabindex="-1"><a class="header-anchor" href="#_3-9-设置强制角色-mandatory-role" aria-hidden="true">#</a> <strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></h4><p>方式1：服务启动前设置</p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">mandatory_roles</span><span class="token punctuation">=</span><span class="token value attr-value">&#39;<span class="token inner-value">role1,role2@localhost,r3@%.atguigu.com</span>&#39;</span>
</code></pre></div><p>方式2：运行时设置</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET PERSIST mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后仍然有效
SET GLOBAL mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后失效
</code></pre></div><h2 id="第04章-逻辑架构" tabindex="-1"><a class="header-anchor" href="#第04章-逻辑架构" aria-hidden="true">#</a> 第04章 逻辑架构</h2><h3 id="_1-逻辑架构剖析" tabindex="-1"><a class="header-anchor" href="#_1-逻辑架构剖析" aria-hidden="true">#</a> <strong>1.</strong> <strong>逻辑架构剖析</strong></h3><h4 id="_1-1-服务器处理客户端请求" tabindex="-1"><a class="header-anchor" href="#_1-1-服务器处理客户端请求" aria-hidden="true">#</a> 1.1 服务器处理客户端请求</h4><p>首先MySQL是典型的C/S架构，即client/server架构，服务端程序使用的是mysqld</p><p>不论客户端进程和服务器进程采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</strong></p><p>那么服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</p><p><img src="/study/assets/image-20220504001341100.1e8ac587.png" alt="image-20220504001341100"></p><p>像InnoDB、MyISAM这样的存储引擎都是把表存储在文件系统上的。</p><p>这里的表指的是表的结构（xxx.frm）和表的数据（xxx.ibd），表的数据又指索引和数据。</p><p>InnoDB的表的数据和索引就是存储在一起的，是一级索引，都存储在<code>表名.ibd</code>中，也叫聚集索引。</p><p>MyISAM是二级索引，数据的索引和数据是分开存储的。</p><p>他们都有xxx.frm这个表结构文件。但是对于InnoDB来说，在MySQL8.0版本，这个表结构文件没有了，而是合并在<code>表名.ibd</code>文件中。</p><p>所以上图的文件系统就是这个意思。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291130782.png" alt="MySQL服务器端的逻辑架构说明"></p><p>解析器：如果SQL语句写得有问题的话，比如语法不对，那么就会在解析器这一步出错。</p><p>优化器：会对SQL进行逻辑上的优化和物理上的优化，物理上的优化就是指索引。后面会详细介绍。</p><p>上图中的数字是SQL语句通过连接，在MySQL服务中的执行顺序，注意9的意思是，存储引擎和文件系统交互，拿到数据时候，会将SQL语句和查询结果进行缓存，所以SQL语句在MySQL服务层首先是查询缓存中的数据。</p><p>要注意MySQL8.0版本就没有查询缓存了。</p><h4 id="_1-2-connectors" tabindex="-1"><a class="header-anchor" href="#_1-2-connectors" aria-hidden="true">#</a> 1.2 Connectors</h4><p>Connectors，指的是不同语言中与SQL的交互，首先要建立连接。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议，所以要用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。</p><p><strong>在TCP连接上，通过MySQL协议跟MySQL进行交互。</strong></p><h4 id="_1-3-第1层-连接层" tabindex="-1"><a class="header-anchor" href="#_1-3-第1层-连接层" aria-hidden="true">#</a> <strong>1.3</strong> <strong>第1层：连接层</strong></h4><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><blockquote><p>一个系统只会和MySQL服务器建立一个连接吗？只能有一个系统和MySQL服务器建立建立连接吗？</p><p>当然不是，多个系统都可以和MySQL服务器建立连接，每个系统建立的连接不止一个，所以为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降等问题，MySQL服务器里有专门的TCP连接池限制连接数，采用长连接模式复用TCP连接，来解决上述问题。</p></blockquote><p>TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。**所以还会有个线程池，去走后面的流程。**每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p><img src="/study/assets/image-20220504004152165.f36a37c3.png" alt="image-20220504004152165"></p><h4 id="_1-4-第2层-服务层" tabindex="-1"><a class="header-anchor" href="#_1-4-第2层-服务层" aria-hidden="true">#</a> 1.4 第2层：服务层</h4><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT ... FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正地执行查询，并将查询结果返回给用户。</li><li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SELECT id,name FROM student WHERE gender = &#39;女&#39;;
</code></pre></div><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><h4 id="_1-5-第3层-引擎层" tabindex="-1"><a class="header-anchor" href="#_1-5-第3层-引擎层" aria-hidden="true">#</a> 1.5 第3层：引擎层</h4><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。</p><p>存储引擎和物理磁盘做交互，这个交互也不是指存储引擎直接从物理磁盘中取数据，再返回给客户端，要把数据加载到内存中，因为cpu直接和磁盘交互的话，存在执行速度和效率上的差异，会降低CPU的执行效率。CPU通常是和内存做交互。</p><h4 id="_1-6-小结" tabindex="-1"><a class="header-anchor" href="#_1-6-小结" aria-hidden="true">#</a> 1.6 <strong>小结</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291131321.png" alt="image-20220329113126234"></p><p>简化为三层结构：</p><ol><li><p>连接层：客户端和服务器端建立TCP连接，建立TCP连接后，客户端发送 SQL 至服务器端，</p><p>关键点：MySQL维护一个TCP连接池管理连接，并且都是长连接模式，建立起TCP连接的请求会分配给一个线程，专门用于和客户端之间的交互，后面还有线程池去走后面的流程；</p></li><li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p></li><li><p>存储引擎层：与数据库文件（文件系统）打交道，负责数据的存储和读取。</p><p>文件系统：</p><p><img src="/study/assets/image-20220504005350560.838d5555.png" alt="image-20220504005350560"></p></li></ol><h3 id="_2-sql执行流程" tabindex="-1"><a class="header-anchor" href="#_2-sql执行流程" aria-hidden="true">#</a> <strong>2. SQL执行流程</strong></h3><h4 id="_2-1-mysql-中的-sql执行流程" tabindex="-1"><a class="header-anchor" href="#_2-1-mysql-中的-sql执行流程" aria-hidden="true">#</a> <strong>2.1 MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291133116.png" alt="image-20220329113337008"></p><p><strong>MySQL的查询流程：</strong></p><p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高（命中率很低），所以在 MySQL8.0 之后就抛弃了这个功能。</p><p><img src="/study/assets/image-20220504225324294.da2431f3.png" alt="image-20220504225324294"></p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以<code>key-value</code>对的形式，被直接缓存在内存中。<code>key</code>是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端，不需要做语法解析、查询优化等后面的步骤，如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。所以，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>**<code>大多数情况下，查询缓存是个鸡肋，这是为什么？</code>**以下三个原因：</p><ul><li><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p></li><li><p>**同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。**以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数now()，每次调用都会产生最新的当地时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，所以缓存这个查询语句是没有意义的！</p></li><li><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p></li></ul><p><strong><code>总之，因为查询缓存弊大于利，查询缓存的失效非常频繁。</code></strong></p><p>一般建议大家在静态表里使用查询缓存，什么叫静态表？就是一般我们极少更新的表，比如，一个系统配置表、字典表，这张表的查询才适合使用查询缓存。好在MySQL也提供了这种按需使用查询缓存的方式，可以将my.cnf参数query_cache_type设置成DEMAND，代表当SQL语句中有SQL_CACHE关键词时才缓存。</p><div class="language-text ext-text"><pre class="language-text"><code>#query_cache_type有三个值，0代表关闭查询缓存OFF，1代表开启ON，2代表使用DEMAND
query_cache_type=2
</code></pre></div><p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p><p><img src="/study/assets/image-20220504232259339.df63a41e.png" alt="image-20220504232259339"></p><p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。如果SQL语句正确，<strong>则会生成一个语法树。</strong></p><p><img src="/study/assets/image-20220504232445093.aa6c06aa.png" alt="image-20220504232445093"></p><p>下面是SQL解析器的执行过程</p><p><img src="/study/assets/image-20220504232621372.f7092bb7.png" alt="image-20220504232621372"></p><p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。</p><p><img src="/study/assets/image-20220504233032833.b3c8e264.png" alt="image-20220504233032833"></p><p>经过了解析器，MySQL就知道了我们要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p><strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</strong></p><p><strong>比如，优化器是在表里面有多个索引的时候，决定使用哪个索引（物理查询优化），或者在一个sql语句有多表关联查询的时候，决定各个表的连接顺序（物理查询优化），还有表达式简化（逻辑查询优化）、子查询转为连接、外连接转为内连接等。</strong></p><p><img src="/study/assets/image-20220504233335715.acf55b65.png" alt="image-20220504233335715"></p><p>在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p><p>逻辑查询优化就是通过改变sql语句的内容来使得sql查询更高效，同时为物理查询优化提供更多的候选执行计划。<strong>通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数据基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</strong></p><p>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从种选择代价最少的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p><ul><li>物理查询优化是通过<strong>索引和表连接方式</strong>等技术来进行优化，这里重点掌握索引的使用。</li><li>逻辑查询优化就是通过SQL等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</li></ul><p><strong>4.</strong> <strong>执行器</strong>：</p><p>截止到现在，还没有真正地去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。</p><p><img src="/study/assets/image-20220504234127640.335dc849.png" alt="image-20220504234127640"></p><p>在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。</p><p>如果具备权限，就打开表继续执行，打开表的时候，执行器就会根据表的引擎定义，调用存储引擎API对表进行读写。</p><p>存储引擎API只是抽象的接口，下面还有存储引擎层，具体实现还是要看表选择的存储引擎。</p><p>就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><p><img src="/study/assets/image-20220504234316804.1525e4b2.png" alt="image-20220504234316804"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291145074.png" alt="image-20220329114541991"></p><p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p><h3 id="_3-数据库缓冲池-buffer-pool" tabindex="-1"><a class="header-anchor" href="#_3-数据库缓冲池-buffer-pool" aria-hidden="true">#</a> <strong>3.</strong> <strong>数据库缓冲池(buffer pool)</strong></h3><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，<strong>在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</strong></p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><h4 id="_3-1-缓冲池-vs-查询缓存" tabindex="-1"><a class="header-anchor" href="#_3-1-缓冲池-vs-查询缓存" aria-hidden="true">#</a> <strong>3.1</strong> <strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h4><p><code>缓冲池和查询缓存不是一个东西。</code></p><p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291155004.png" alt="image-20220329115517901"></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>缓存原则：</strong></p><p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I/O 访问效率进行优化。</p><p>首先，位置决定效率，<strong>提供缓冲池就是为了在内存中可以直接访问数据。</strong></p><p>不是说缓冲池就是内存，缓冲池是DBMS来占用一部分内存来作为缓冲池。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p><p><strong>缓存池的重要性</strong></p><ul><li><p>对于使用InnoDB作为存储引擎的表来说，<strong>不管是用于存储用户数据的索引（包括聚簇索引即一级索引，还有二级索引），还是各种系统数据，都是以页的形式存放在表空间的</strong>，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据到底还是还是存储在磁盘上的。但是磁盘的速度很慢，缓冲池可以帮助我们消除cpu和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，**也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据都加载到内存中。**将整个页的数据加载到内存中之后，就可以进行读写访问了，在进行完读写访问操作之后，并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来再有请求再次访问该页面时，就可以省去磁盘IO的开销了。</p><p>注意：页在操作系统和进程的角度来讲，页是一个进程的某一部分，操作系统在运行一个进程时，也不会把进程所有数据都调入内存执行，而是每次都会按照一定的规则，比如请求分页存储管理方式，由操作系统负责将所需信息（进程的页面）从外存调入内存。操作系统以页框为单位，为各个进程分配内存空间。这里的页就是指的磁盘空间上，文件系统的表空间文件中的一部分数据，指的表空间的某个页面。</p></li></ul><p><strong>缓冲池的预读特性</strong></p><ul><li>缓冲池的作用就是提升IO效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据（优先会把热数据，就是使用频次高的数据加载到内存），大概率还会使用它周围的一些数据，因此采用“预读”的机制进行提前加载，可以减少未来可能的磁盘IO操作。</li></ul><p><strong>2.</strong> <strong>查询缓存</strong></p><p>查询缓存是提前把<code>sql语句和查询结果缓存</code>起来，是<code>key-value结构</code>，这样下次不需要执行就可以直接拿到结果。<strong>而缓冲池是缓存的是表中的大量的数据</strong>，这是两回事。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h4 id="_3-2-缓冲池如何读取数据" tabindex="-1"><a class="header-anchor" href="#_3-2-缓冲池如何读取数据" aria-hidden="true">#</a> <strong>3.2</strong> <strong>缓冲池如何读取数据</strong></h4><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断<strong>该页面（数据）是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291159111.png" alt="image-20220329115958009"></p><blockquote><p><code>如果我们执行SQL语句的时候，更新了缓冲池中的数据，那么这些数据会马上同步到磁盘上吗？</code></p><p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上，<strong>注意不是每次发生更新操作，都会立刻进行磁盘回写</strong>，缓冲池会采用一种叫做checkpoint的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p><p>比如当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些不常用的页释放掉。这里的脏页指的是缓冲池中被修改过的页，与磁盘上（文件系统）数据不一致的页。</p></blockquote><h4 id="_3-3-查看-设置缓冲池的大小" tabindex="-1"><a class="header-anchor" href="#_3-3-查看-设置缓冲池的大小" aria-hidden="true">#</a> <strong>3.3</strong> <strong>查看/设置缓冲池的大小</strong></h4><p>如果使用的是MySQL MyISAM存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为<code>key_buffer_size</code></p><p>如果使用的是InnoDB存储引擎，那么是索引和数据都要缓存，可以通过查看<code>innodb_buffer_pool_size</code>变量来查看缓冲池的大小。</p><p>InnoDB存储引擎是数据和索引存储在一起的，而MyISAM存储引擎的索引和数据是分开存储的，也就是说索引都是二级索引。</p><p>查看缓冲池的大小</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;innodb_buffer_pool_size&#39;;
</code></pre></div><p>设置缓冲池的大小</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>set global innodb_buffer_pool_size = 268435456;
</code></pre></div><p>或者</p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">server</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">innodb_buffer_pool_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">268435456</span>
</code></pre></div><h4 id="_3-4-多个buffer-pool实例" tabindex="-1"><a class="header-anchor" href="#_3-4-多个buffer-pool实例" aria-hidden="true">#</a> <strong>3.4</strong> <strong>多个Buffer Pool实例</strong></h4><p>Buffer Pool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问Buffer Pool中的数据都需要加锁处理。在Buffer Pool特别大而且多线程访问，并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把他们拆分成若干个小的Buffer Pool，每个Buffer Pool都称为一个实例，他们都是独立地去申请内存空间，独立地管理各种链表。所以在多线程并发访问时，并不会相互影响，从而提供并发处理能力。</p><p>我们可以在服务器启动的时候，通过设置以下参数去设置Buffer Pool实例的个数</p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">server</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">innodb_buffer_pool_instances</span> <span class="token punctuation">=</span> <span class="token value attr-value">2</span>
</code></pre></div><p>如何查看缓冲池的个数</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;innodb_buffer_pool_instances&#39;;
</code></pre></div><p>每个<code>Buffer Pool</code>实例实际占内存空间</p><div class="language-text ext-text"><pre class="language-text"><code>innodb_buffer_pool_size/innodb_buffer_pool_instances
</code></pre></div><p><img src="/study/assets/image-20220505162215734.c4eac240.png" alt="image-20220505162215734"></p><h2 id="第05章-存储引擎" tabindex="-1"><a class="header-anchor" href="#第05章-存储引擎" aria-hidden="true">#</a> 第05章 存储引擎</h2><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的部分划分为MySQL server功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><p>简而言之，存储引擎就是指表的类型，其实存储引擎以前叫做表处理器，它的功能就是接收上层传下来的指令，然后对表中的数据进行读写操作。</p><h3 id="_1-查看存储引擎" tabindex="-1"><a class="header-anchor" href="#_1-查看存储引擎" aria-hidden="true">#</a> <strong>1.</strong> <strong>查看存储引擎</strong></h3><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show engines;
# 或
show engines\G
</code></pre></div><h3 id="_2-设置系统默认的存储引擎" tabindex="-1"><a class="header-anchor" href="#_2-设置系统默认的存储引擎" aria-hidden="true">#</a> <strong>2.</strong> <strong>设置系统默认的存储引擎</strong></h3><ul><li>查看默认的存储引擎：</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;%storage_engine%&#39;; 
#或
SELECT @@default_storage_engine;
</code></pre></div><ul><li>修改默认的存储引擎</li></ul><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET DEFAULT_STORAGE_ENGINE=MyISAM;
</code></pre></div><p>或者修改<code>my.cnf</code>文件：</p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token key attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token value attr-value">MyISAM</span> 
</code></pre></div><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token comment"># 重启服务 </span>
systemctl restart mysqld.service
</code></pre></div><h3 id="_3-设置表的存储引擎" tabindex="-1"><a class="header-anchor" href="#_3-设置表的存储引擎" aria-hidden="true">#</a> <strong>3.</strong> <strong>设置表的存储引擎</strong></h3><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h4 id="_3-1-创建表时指定存储引擎" tabindex="-1"><a class="header-anchor" href="#_3-1-创建表时指定存储引擎" aria-hidden="true">#</a> <strong>3.1</strong> <strong>创建表时指定存储引擎</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE 表名(
    建表语句; 
) ENGINE = 存储引擎名称;
</code></pre></div><h4 id="_3-2-修改表的存储引擎" tabindex="-1"><a class="header-anchor" href="#_3-2-修改表的存储引擎" aria-hidden="true">#</a> <strong>3.2</strong> <strong>修改表的存储引擎</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER TABLE 表名 ENGINE = 存储引擎名称;
</code></pre></div><h3 id="_4-引擎介绍" tabindex="-1"><a class="header-anchor" href="#_4-引擎介绍" aria-hidden="true">#</a> <strong>4.</strong> <strong>引擎介绍</strong></h3><h4 id="_4-1-innodb-引擎-具备外键支持功能的事务存储引擎" tabindex="-1"><a class="header-anchor" href="#_4-1-innodb-引擎-具备外键支持功能的事务存储引擎" aria-hidden="true">#</a> <strong>4.1 InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h4><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。</li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。<strong>可以确保事务的完整提交(Commit)和回滚(Rollback)。</strong></li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li><li>数据文件结构： <ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。 <ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li></ul><h4 id="_4-2-myisam-引擎-主要的非事务处理存储引擎" tabindex="-1"><a class="header-anchor" href="#_4-2-myisam-引擎-主要的非事务处理存储引擎" aria-hidden="true">#</a> <strong>4.2 MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h4><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>（这个缺陷就是由于MyISAM不支持事务造成的）。</li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，<strong>对事务完整性没有要求或者以SELECT、INSERT为主的应用</strong></li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构： <ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><h4 id="_4-3-archive-引擎-用于数据存档" tabindex="-1"><a class="header-anchor" href="#_4-3-archive-引擎-用于数据存档" aria-hidden="true">#</a> <strong>4.3 Archive</strong> <strong>引擎：用于数据存档</strong></h4><h4 id="_4-4-blackhole-引擎-丢弃写操作-读操作会返回空内容" tabindex="-1"><a class="header-anchor" href="#_4-4-blackhole-引擎-丢弃写操作-读操作会返回空内容" aria-hidden="true">#</a> <strong>4.4 Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong></h4><h4 id="_4-5-csv-引擎-存储数据时-以逗号分隔各个数据项" tabindex="-1"><a class="header-anchor" href="#_4-5-csv-引擎-存储数据时-以逗号分隔各个数据项" aria-hidden="true">#</a> <strong>4.5 CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></h4><h4 id="_4-6-memory-引擎-置于内存的表" tabindex="-1"><a class="header-anchor" href="#_4-6-memory-引擎-置于内存的表" aria-hidden="true">#</a> <strong>4.6 Memory</strong> <strong>引擎：置于内存的表</strong></h4><h4 id="_4-7-federated-引擎-访问远程表" tabindex="-1"><a class="header-anchor" href="#_4-7-federated-引擎-访问远程表" aria-hidden="true">#</a> <strong>4.7 Federated</strong> <strong>引擎：访问远程表</strong></h4><h4 id="_4-8-merge引擎-管理多个myisam表构成的表集合" tabindex="-1"><a class="header-anchor" href="#_4-8-merge引擎-管理多个myisam表构成的表集合" aria-hidden="true">#</a> <strong>4.8 Merge引擎：管理多个MyISAM表构成的表集合</strong></h4><h4 id="_4-9-ndb引擎-mysql集群专用存储引擎" tabindex="-1"><a class="header-anchor" href="#_4-9-ndb引擎-mysql集群专用存储引擎" aria-hidden="true">#</a> <strong>4.9 NDB引擎：MySQL集群专用存储引擎</strong></h4><h3 id="_5-myisam和innodb" tabindex="-1"><a class="header-anchor" href="#_5-myisam和innodb" aria-hidden="true">#</a> <strong>5. MyISAM和InnoDB</strong></h3><p><img src="/study/assets/image-20220505171914132.58f364a1.png" alt="image-20220505171914132"></p><table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td><strong>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</strong></td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h2 id="第06章-索引的数据结构" tabindex="-1"><a class="header-anchor" href="#第06章-索引的数据结构" aria-hidden="true">#</a> 第06章 索引的数据结构</h2><h3 id="_1-为什么使用索引" tabindex="-1"><a class="header-anchor" href="#_1-为什么使用索引" aria-hidden="true">#</a> 1.为什么使用索引？</h3><p><strong>索引是存储引擎用于快速找到数据记录的一种数据结构</strong>，就好比一本教科书的目录部分，通过目录找到对应文章的页码，便可快速定位到需要的文章。MySQL也是一样的道理，进行数据查找时，<strong>首先查看查询条件是否命中某条索引</strong>，符合则通过索引查找相关数据，如果不符合则需要进行全表扫描，即需要一条一条记录查找，直到找到与条件符合的记录。</p><p><code>索引是数据结构。</code></p><p><img src="/study/assets/image-20220505173332961.fc8f1781.png" alt="image-20220505173332961"></p><p><img src="/study/assets/image-20220505173455290.5cd9774c.png" alt="image-20220505173455290"></p><p><img src="/study/assets/image-20220505173521250.f11dc885.png" alt="image-20220505173521250"></p><p><img src="/study/assets/image-20220505193509658.69739fdc.png" alt="image-20220505193509658"></p><h3 id="_2-索引及其优缺点" tabindex="-1"><a class="header-anchor" href="#_2-索引及其优缺点" aria-hidden="true">#</a> <strong>2.</strong> <strong>索引及其优缺点</strong></h3><h4 id="_2-1-索引概述" tabindex="-1"><a class="header-anchor" href="#_2-1-索引概述" aria-hidden="true">#</a> <strong>2.1</strong> <strong>索引概述</strong></h4><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p>**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p><p>索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度，所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><h4 id="_2-2-优点" tabindex="-1"><a class="header-anchor" href="#_2-2-优点" aria-hidden="true">#</a> <strong>2.2</strong> <strong>优点</strong></h4><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本（减少磁盘IO的次数）</code>，这也是创建索引<strong>最主要的原因。</strong></p><p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。（唯一约束的字段会自动添加唯一索引）</p><p>（3）在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</p><p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p><h4 id="_2-3-缺点" tabindex="-1"><a class="header-anchor" href="#_2-3-缺点" aria-hidden="true">#</a> <strong>2.3</strong> <strong>缺点</strong></h4><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p><p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p><p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。<strong>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</strong></p><blockquote><p>提示：（一个小的技巧）</p><p>索引可以提高查询的速度，但是会影响插入数据的速度，这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><h3 id="_3-innodb中索引的推演" tabindex="-1"><a class="header-anchor" href="#_3-innodb中索引的推演" aria-hidden="true">#</a> <strong>3. InnoDB中索引的推演</strong></h3><h4 id="_3-1-索引之前的查找" tabindex="-1"><a class="header-anchor" href="#_3-1-索引之前的查找" aria-hidden="true">#</a> <strong>3.1</strong> <strong>索引之前的查找</strong></h4><p>先来看一个精确匹配的例子：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
</code></pre></div><p><strong>1.在一个页中的查找</strong></p><p>一个数据页默认大小是16kb，一个数据页中存储数据是有限的，从磁盘也就是文件系统被操作系统调入内存，调入缓冲池，是以页为单位，某个整页的数据都会被调入缓冲池。</p><p>表中的多条记录之间，在物理磁盘上并不是紧密排列的，数据量是非常大的，我们只需要保证表中的记录之间是逻辑上连续的，就是单链表。每一条记录之间是用单链表连接的。</p><p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li><p>以主键为搜索条件</p><ul><li><p>主键一般是自增长的，所以主键可以看作是递增有序的。</p></li><li><p>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p></li></ul></li><li><p>以其他列作为搜索条件</p><ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li></ul><p><strong>2.在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。如果一个表有一亿条记录呢？索引应运而生。</p><h4 id="_3-2-设计索引" tabindex="-1"><a class="header-anchor" href="#_3-2-设计索引" aria-hidden="true">#</a> <strong>3.2</strong> <strong>设计索引</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; CREATE TABLE index_demo(
    -&gt; c1 INT,
    -&gt; c2 INT,
    -&gt; c3 CHAR(1),
    -&gt; PRIMARY KEY(c1)
    -&gt; ) ROW_FORMAT = Compact;
</code></pre></div><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203300956080.png" alt="image-20220330095642965"></p><ul><li><p><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</p></li><li><p><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的<code>地址偏移量</code>，我们用箭头来表明下一条记录是谁。</p><p>因为记录与记录之间在物理磁盘上并不是连续的，在逻辑上保证连续，通过链表。所以要记录某一条记录的下一条记录，就是next_record</p></li><li><p><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。</p></li><li><p><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p></li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301000365.png" alt="image-20220330100053271"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301001377.png" alt="image-20220330100150297"></p><h5 id="_1-一个简单的索引设计方案" tabindex="-1"><a class="header-anchor" href="#_1-一个简单的索引设计方案" aria-hidden="true">#</a> <strong>1.</strong> <strong>一个简单的索引设计方案</strong></h5><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p><ul><li><p><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></p><p><img src="/study/assets/image-20220505200229398.e640a631.png" alt="image-20220505200229398"></p><p>从图中可以看出来，index_demo表中的三条记录，都被插入到了编号为10的数据页中，此时我们再插入一条记录：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">insert</span> <span class="token keyword">into</span> index_demo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>因为页10最多只能存放3条记录（假设），所以我们不得不再分配一个数据页来存储新插入的记录。</p><p><img src="/study/assets/image-20220505200633583.2e6297d2.png" alt="image-20220505200633583"></p><p>注意：</p><ul><li><p>数据页跟数据页之间也是逻辑上连续的，在物理磁盘上并不是物理连续的，也是通过链表达到逻辑上连续。</p></li><li><p>新分配的数据页编号可能并不是连续的，他们只是通过维护着上一个页和下一个页的编号而建立了链表关系，另外，页10中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5 &gt; 4，所以这就不符合下一个数据页中的用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次记录移动，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录移动到页10中。这个过程的示意图如下：</p><p><img src="/study/assets/image-20220505201109329.f353254b.png" alt="image-20220505201109329"></p><p>这个过程表明了在对页中的记录进行增删改查的过程中，我们必须通过一些诸如记录移动的操作来始终保持这个状态一直成立：<code>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</code>这个过程我们称为<code>页分裂</code>。</p></li></ul></li><li><p><strong>给所有的页建立一个目录项。</strong></p><p>由于数据页的编号可能是不连续的，所以在向index_demo表中插入多条记录之后，可能是这样的效果：</p><p><img src="/study/assets/image-20220505201556827.26093eb1.png" alt="image-20220505201556827"></p><p>因为这些16kb的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给这些页做个目录，<strong>每个页对应一个目录项</strong>，每个目录项包括下面两个部分：</p><ul><li>页的用户记录的<strong>最小的主键值</strong>，我们用key来表示，或者说索引列的最小值（默认索引列是主键！）</li><li>页号，用page_no表示。</li></ul><p>我们为上面几个页做好的目录像这样：</p><p><img src="/study/assets/202203301004386.add9e28a.png" alt="image-20220330100409306"></p></li></ul><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li><p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。</p></li><li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p><h5 id="_2-innodb中的索引方案" tabindex="-1"><a class="header-anchor" href="#_2-innodb中的索引方案" aria-hidden="true">#</a> <strong>2. InnoDB中的索引方案</strong></h5><p><strong>① 迭代1次：目录项纪录的页</strong></p><p>上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位到具体的目录项而<code>假设</code>所有的目录项都可以在物理存储器上连续存储，但是这样做有以下几个问题：</p><ul><li>InnoDB是使用页来作为管理存储空间的基本单位，每一页最多能保证16kb的连续存储空间，而随着表中记录的增多，需要非常大的连续存储空间才能把所有目录项都存下，这对记录数量非常多的表来说是不现实的。</li><li>我们时常会对记录进行增删，假设我们把页28中的所有记录都删了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动，因为我们目前假设目录项是采用连续的物理存储空间，这样牵一发而动全身的操作效率很差。</li></ul><p>所以我们需要一种可以灵活管理所有目录项的方式，目录项长得和用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB怎么区分一条记录是普通用户记录还是目录项记录呢？使用记录头信息里的record_type属性，它的各个取值代表的意思如下：</p><ul><li>0：表示普通用户记录</li><li>1：目录项记录</li><li>2：最小记录</li><li>3：最大记录</li></ul><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301028743.png" alt="image-20220330102834658"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p>**相同点：**两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），<strong>从而</strong>在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li><p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</p></li><li><p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p></li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong></p><p>虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16kb大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页是最多只能存放4条目录项记录，所以如果此时我们再插入一条主键值为320的用户记录的话，那就需要新分配一页来存放新的目录项记录。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301034997.png" alt="image-20220330103442914"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过目录项记录页<code>确定用户记录真实所在的页</code>（二分法）。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录（二分法）。</p></li></ol><p><strong>③ 迭代3次：目录项记录页的目录页</strong></p><p><img src="/study/assets/image-20220505210019906.d61052ce.png" alt="image-20220505210019906"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301038376.png" alt="image-20220330103847284"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301040190.png" alt="image-20220330104012108"></p><p>这个数据结构，它的名称是<code>B+树</code>。</p><p><strong>每一个节点，都是数据页。</strong></p><p>叶子节点里面都是我们真实的用户数据。</p><p>叶子节点里一条一条的数据之间呢，是单向链表的方式去链接的。</p><p>每一个叶子节点之间，即叶子节点层（第0层），数据页之间是双向链表的方式链接的。</p><p><strong>非叶子节点层的页都是多个目录项记录构成的页，叫做目录页</strong>，实际也是数据页，大小也是16kb，只不过我们叫做目录页。每一个目录页里面存放的是多条目录项记录，第0层每一个节点，即每一个数据页里面存放的是多条用户数据记录。</p><p><strong>④</strong> <strong>B+Tree</strong></p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul><p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p><p>树的层次越低，IO的次数就越少！</p><h4 id="_3-3-常见索引概念" tabindex="-1"><a class="header-anchor" href="#_3-3-常见索引概念" aria-hidden="true">#</a> <strong>3.3</strong> <strong>常见索引概念</strong></h4><h5 id="_1-聚簇索引" tabindex="-1"><a class="header-anchor" href="#_1-聚簇索引" aria-hidden="true">#</a> <strong>1.</strong> <strong>聚簇索引</strong></h5><p>针对主键构建的索引</p><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据、数据即索引。</p><p><img src="/study/assets/image-20220505211735337.1f86bc65.png" alt="image-20220505211735337"></p><p>这里看到的数据，其实就是底层数据存储的方式，或者说数据结构，就是b+树，就是物理磁盘中，数据文件中的数据的存储方式。</p><p>InnoDB存储引擎，底层存储数据的目录中，有xxx.ibd文件，这个文件中存放的就是数据和索引，<strong>数据和索引是存储在一起的，你中有我、我中有你。</strong></p><p><strong>聚簇的意思就是表中的数据和索引结构是一个整体。</strong></p><p>**非聚簇索引是不存储表中的一条条记录的！！！！**索引和数据是分开存储的。</p><p>聚簇索引的叶子节点存储的都是实打实的一条条用户记录。</p><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p></li><li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p></li><li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</p></li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>我们把具有这两种特点的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处，<strong>这种聚簇索引并不需要我们在MySQL语句中显示地使用index语句去创建，InnoDB存储引擎会自动地为我们创建聚簇索引。</strong></p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，<strong>因为聚簇索引将索引和数据保存在同一个B+树中（数据存放在叶子节点，索引结构是非叶子节点，可以这样理解，非叶子节点都是存储目录项记录的页，也就是索引，叶子节点是用户记录，非叶子节点是索引，他们作为一个整体，是b+树的结构，是聚簇索引）</strong>，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快，因为页内的记录是按照主键大小进行排序的！<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动（因为我们要保证下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值，所以如果更新主键值，会存在数据移动）。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul><p><strong>限制：</strong></p><ul><li>对于MySQL数据库，目前只有InnoDB存储引擎支持聚簇索引，而MyISAM并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引，一般情况下就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择非空的唯一索引代替，如果没有这样的索引，InnoDB会隐式地定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，为了保证数据的顺序增长，所以InnoDB表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul><h5 id="_2-二级索引-辅助索引、非聚簇索引" tabindex="-1"><a class="header-anchor" href="#_2-二级索引-辅助索引、非聚簇索引" aria-hidden="true">#</a> <strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></h5><p>上面介绍的聚簇索引只能在搜索条件是主键值时才发挥作用，因为B+树中的数据都是按照主键进行排序的（不论是第0层的用户数据，也就是数据页，还是其他层的索引结构，也就是非叶子节点的目录页，都是按照主键值进行排序的）。那如果我们想以别的列作为搜索条件应该怎么办呢？</p><p>答案：我们可以多建几棵B+树，不同的B+树中采用不同的排序规则，比方说我们用c2列的大小作为数据页，页中记录的排序规则，再建一棵B+树，效果如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301050055.png" alt="image-20220330105018965"></p><p><code>这个B+树的叶子节点存储的并不是完整的用户数据记录，而是C2列+主键这两个列的值。</code></p><p>目录项记录中不再是主键+页号的搭配，而是c2列+页号的搭配。</p><p><strong>一个表有一个聚簇索引，可以有多个二级索引。</strong></p><p><strong>概念：回表</strong>：我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p><ul><li>先根据二级索引找到主键</li><li>再根据主键值到聚簇索引中进行查找。</li></ul><p>所以使用到2棵b+树。</p><p>如果把完整的用户记录放到叶子节点，那么就可以不用回表，但是太占地方了，相当于每建立一棵b+树都需要把所有的用户记录都拷贝一遍，这就太浪费存储空间了。</p><p>因为这种按照非主键列建立的b+树，需要一次回表操作才可以定位到完整的用户记录，所以这种b+树也叫做二级索引，或者辅助索引，或者非聚簇索引。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p><p><img src="/study/assets/image-20220505222843206.eb7a5d6c.png" alt="image-20220505222843206"></p><p><img src="/study/assets/image-20220505222949641.231dd0e1.png" alt="image-20220505222949641"></p><h5 id="_3-联合索引" tabindex="-1"><a class="header-anchor" href="#_3-联合索引" aria-hidden="true">#</a> <strong>3.</strong> <strong>联合索引</strong></h5><p>属于非聚簇索引。</p><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序，如果记录的c2列相同，则按照c3列的值进行排序。</p></li><li><p>b+树的叶子节点处的用户记录由c2、c3和主键列组成。</p></li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p></li><li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p></li></ul><h4 id="_3-4-innodb的b-树索引的注意事项" tabindex="-1"><a class="header-anchor" href="#_3-4-innodb的b-树索引的注意事项" aria-hidden="true">#</a> <strong>3.4 InnoDB的B+树索引的注意事项</strong></h4><h5 id="_1-根页面位置万年不动" tabindex="-1"><a class="header-anchor" href="#_1-根页面位置万年不动" aria-hidden="true">#</a> <strong>1.</strong> <strong>根页面位置万年不动</strong></h5><p>我们前边介绍B+索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便<strong>升级</strong>为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h5 id="_2-内节点中目录项记录的唯一性" tabindex="-1"><a class="header-anchor" href="#_2-内节点中目录项记录的唯一性" aria-hidden="true">#</a> <strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong></h5><p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>&#39;u&#39;</td></tr><tr><td>3</td><td>1</td><td>&#39;d&#39;</td></tr><tr><td>5</td><td>1</td><td>&#39;y&#39;</td></tr><tr><td>7</td><td>1</td><td>&#39;a&#39;</td></tr></tbody></table><p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301110222.png" alt="image-20220330111029120"></p><p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p><p>为了让新插入记录能找到自己在哪个页里，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。**所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301120304.png" alt="image-20220330112018199"></p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><h5 id="_3-一个页面最少可以存储2条记录" tabindex="-1"><a class="header-anchor" href="#_3-一个页面最少可以存储2条记录" aria-hidden="true">#</a> <strong>3.</strong> <strong>一个页面最少可以存储2条记录</strong></h5><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p><h3 id="_4-myisam中的索引方案" tabindex="-1"><a class="header-anchor" href="#_4-myisam中的索引方案" aria-hidden="true">#</a> <strong>4. MyISAM中的索引方案</strong></h3><p><strong>B树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。也就是二级索引，MyISAM不是聚簇索引。</p><h4 id="_4-1-myisam索引的原理" tabindex="-1"><a class="header-anchor" href="#_4-1-myisam索引的原理" aria-hidden="true">#</a> <strong>4.1 MyISAM索引的原理</strong></h4><p>下图是MyISAM索引的原理图。</p><p>我们知道InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用的树形结构，但是却将数据和索引分开存储，也就是MyISAM的索引是二级索引。</p><ul><li><p>将表中的记录按照记录的插入顺序，单独存储在一个文件中，称之为数据文件，且这个文件不分页，这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少条记录就成了，由于在插入数据的时候，<strong>并没有可以按照主键大小进行顺序排序</strong>（InnoDB引擎的聚簇索引，不论是目录页中的目录项记录还是叶子节点中的用户数据记录都会按照主键大小进行排序，根据插入的主键大小，还涉及到数据的移动，在不同页面中的移动，保证按主键排序，保证下一个页面的数据的主键大于上一个页面），所以我们并不能在这些数据上使用二分法进行查找。</p></li><li><p>使用MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的文件中，MyISAM会单独为表的<code>主键</code>创建一个索引，是非聚簇索引，也就是二级索引，不包含用户数据，在索引的叶子节点中存储的不是完整的用户数据记录，而是<strong>主键值+数据记录位置（记录地址）。</strong></p><p>这和前面提到的二级索引又有一点不同，比如说InnoDB中的二级索引，叶子节点中存储的数据是非主键列，也就是索引列+ 主键值（数据记录位置）</p><p>总结：</p><p>InnoDB的二级索引的叶子节点：非主键列（索引列） + 主键</p><p>MyISAM的二级索引的叶子节点：主键值+数据记录位置</p><p>总之就是二级索引的叶子节点不包含用户完整数据记录，而是数据记录位置</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301133907.png" alt="image-20220330113307813"></p><p>所有MyISAM的索引都是这样的结构，没有聚簇索引和非聚簇索引之说，我们可以将这种索引理解为非聚簇索引。因为数据和索引是分离的。MyISAM的索引文件仅仅保存数据记录的地址。</p><h4 id="_4-2-myisam-与-innodb对比" tabindex="-1"><a class="header-anchor" href="#_4-2-myisam-与-innodb对比" aria-hidden="true">#</a> <strong>4.2 MyISAM</strong> <strong>与</strong> <strong>InnoDB对比</strong></h4><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><p><strong>小结两种引擎中索引的区别：</strong></p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作（第一次是根据非聚簇索引找到数据地址，第二次是根据数据地址找到数据，而InnoDB的回表，第一次是根据非聚簇索引找到主键，第二次是根据主键去聚簇索引中进行查找），意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。</p><p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存<strong>数据记录的地址</strong>。</p><p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以<strong>非空且唯一标识数据记录的列</strong>作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><p><img src="/study/assets/image-20220506000814916.c4d2022f.png" alt="image-20220506000814916"></p><h3 id="_5-索引的代价" tabindex="-1"><a class="header-anchor" href="#_5-索引的代价" aria-hidden="true">#</a> <strong>5.</strong> <strong>索引的代价</strong></h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，<strong>每一棵B+树的每一个节点都是一个数据页</strong>，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改（维护）各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列（主键或索引列）的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><h3 id="_6-mysql数据结构选择的合理性" tabindex="-1"><a class="header-anchor" href="#_6-mysql数据结构选择的合理性" aria-hidden="true">#</a> <strong>6. MySQL数据结构选择的合理性</strong></h3><p>从MySQL的角度讲，不得不考虑一个现实的问题就是磁盘IO，如果我们能让索引的数据结构尽量减少磁盘的IO操作，所消耗的时间也就越少。</p><p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，索引可能达到几个G，甚至更多。<strong>为了减少索引在内存中的占用</strong>，数据库索引都是存储在磁盘上的，如之前所看到的数据和索引都存储在xxx.ibd文件中，这是InnoDB，因为数据和索引存储在一起，而MyISAM的索引也是单独的文件存储，存储在磁盘上的，当我们利用索引进行查询的时候，<strong>不可能一次性把所有的索引都加载到内存，只能逐一加载</strong>，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p><h4 id="_6-1-hash结构" tabindex="-1"><a class="header-anchor" href="#_6-1-hash结构" aria-hidden="true">#</a> 6.1 Hash结构</h4><p><img src="/study/assets/image-20220506002356745.f2bbc7ea.png" alt="image-20220506002356745"></p><h4 id="_6-2-二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_6-2-二叉搜索树" aria-hidden="true">#</a> <strong>6.2</strong> <strong>二叉搜索树</strong></h4><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301636830.png" alt="image-20220330163602743"></p><p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，<strong>树的每层的分叉越多越好。</strong></p><h4 id="_6-3-avl树" tabindex="-1"><a class="header-anchor" href="#_6-3-avl树" aria-hidden="true">#</a> <strong>6.3 AVL树</strong></h4><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p>为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树（Balanced Binary Tree），又称为AVL树，它在二叉搜索树上增加了基础，具有以下性质：</p><p><strong>它是一棵空树，或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p><p>这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度是<code>O(logn)</code></p><p>数据查询的时间也主要依赖于磁盘IO的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是<code>O(logn)</code>，当n比较大时，树的深度也是比较高的</p><p><strong>每访问一次节点，就需要进行一次磁盘IO操作。对于以下这棵树来说，我们需要进行5次IO操作。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301635653.png" alt="image-20220330163506536"></p><p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301637104.png" alt="image-20220330163709022"></p><p>可以看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度（M &gt; 2），所以我们需要把树从瘦高编程矮胖。树的高度是多少，那么我们就需要进行多少次磁盘IO来找到数据。</p><h4 id="_6-4-b-tree" tabindex="-1"><a class="header-anchor" href="#_6-4-b-tree" aria-hidden="true">#</a> <strong>6.4 B-Tree</strong></h4><p>B树的英文是Balance Tree，是多路平衡查找树。它的高度远小于平衡二叉树的高度。</p><p>B 树的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301638995.png" alt="image-20220330163803905"></p><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，M称为B树的阶。</p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。</p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。</p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要<code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p><ol><li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</p></li><li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</p></li><li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p></li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。</p><p><code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p><p>小结：</p><ul><li><p>B树在插入和删除节点的时候如果导致树不平衡，就通过<strong>自动调整节点的位置来保持树的自平衡</strong>。因为B树是多路平衡查找树。</p></li><li><p><strong>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据，搜索有可能在非叶子节点结束。一定要注意这点，这是和B+树很大的差别。</strong></p><p><strong>即B树的内节点中也要存储数据，并不是说用户记录即数据都是存储在叶子节点上的。</strong></p></li><li><p>其搜索性能等价于在关键字全集内做一次二分查找。</p></li></ul><p><strong>再举例1：</strong></p><p><img src="/study/assets/image-20220506185426045.5a7d7a4a.png" alt="image-20220506185426045"></p><h4 id="_6-5-b-tree" tabindex="-1"><a class="header-anchor" href="#_6-5-b-tree" aria-hidden="true">#</a> <strong>6.5 B+Tree</strong></h4><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ol><li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</p></li><li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p></li><li><p>**非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。**而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。</p></li><li><p><strong>所有关键字都在叶子节点出现</strong>，叶子节点构成一个有序链表（节点之间是双向链表，节点内部的数据是单向链表），而且叶子节点本身按照关键字的大小从小到大顺序链接。</p><p>B树的话，不是所有关键字都在叶子节点出现，因为有一些关键字是在非叶子节点中，非叶子节点也要保存数据。也就是B树的内节点既要存索引，也要存数据。</p></li></ol><blockquote><p>首先，B+树查询效率更稳定，因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到非叶子节点就可以找到关键字，而有时需要访问到叶子节点，才能找到关键字。</p><p>其次，B+树的查询效率更高，这是因为通常B+树比B树更矮胖，查询所需要的磁盘IO也会更少，同样的磁盘页大小，B+树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为B+树中，所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，因为数据是逻辑上排序的，是链表的形式，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中，则需要通过中序遍历才能完成查询范围的查找，效率要低很多，仍是因为B树并不是所有的数据都存储在叶子节点，而是非叶子节点也要存储数据！！！</p></blockquote><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</p><p>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为<strong>磁盘页对应着索引树的节点。</strong></p></blockquote><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作</p></blockquote><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><blockquote><p>1.B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针（也就是内部节点不放数据，就能放更多索引，更多指针，而一个节点就是一个磁盘页或者说数据页，那么加载一个数据页，能读取到的索引就更多，就更容易找到需要的数据，效率就更高。）。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么<strong>盘块所能容纳的关键字数量也越多</strong>。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash索引与B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p><p>4、<code>InnoDB不支持哈希索引</code></p></blockquote><h2 id="第07章-innodb数据存储结构" tabindex="-1"><a class="header-anchor" href="#第07章-innodb数据存储结构" aria-hidden="true">#</a> 第07章 InnoDB数据存储结构</h2><h3 id="_1-数据库的存储结构-页" tabindex="-1"><a class="header-anchor" href="#_1-数据库的存储结构-页" aria-hidden="true">#</a> 1. 数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InooDB存储引擎的数据存储结构。</p><h4 id="_1-1-磁盘与内存交互基本单位-页" tabindex="-1"><a class="header-anchor" href="#_1-1-磁盘与内存交互基本单位-页" aria-hidden="true">#</a> 1.1 磁盘与内存交互基本单位：页</h4><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p><p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次<code>最少</code>从磁盘中读取16KB的内容到内存中，一次<code>最少</code>把内存中的16KB内容刷新到磁盘中（回写操作也是以页为单位）。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。</p><p>之前的B+树聚簇索引结构，为什么说一个访问了几个节点，就需要进行几次和磁盘的IO操作呢？<strong>就是因为一个节点就是一个数据页或者说磁盘页。</strong></p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。</p></blockquote><h4 id="_1-2-页结构概述" tabindex="-1"><a class="header-anchor" href="#_1-2-页结构概述" aria-hidden="true">#</a> 1.2 页结构概述</h4><p><img src="/study/assets/image-20220506192846780.76d502e4.png" alt="image-20220506192846780"></p><p>页a、页b、页c...页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p><h4 id="_1-3-页的上层结构" tabindex="-1"><a class="header-anchor" href="#_1-3-页的上层结构" aria-hidden="true">#</a> 1.3 页的上层结构</h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301838071.png" alt="image-20220330183814954"></p><p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。</p><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p><h3 id="_2-页的内部结构" tabindex="-1"><a class="header-anchor" href="#_2-页的内部结构" aria-hidden="true">#</a> 2. 页的内部结构</h3><p>页如果按照类型划分的话，常见的有数据页（保存B+树节点）、系统页、UNDO页和事务数据页等。数据页是我们最常用的页。</p><h4 id="_2-1-第1部分-文件头部和文件尾部" tabindex="-1"><a class="header-anchor" href="#_2-1-第1部分-文件头部和文件尾部" aria-hidden="true">#</a> 2.1 第1部分：文件头部和文件尾部</h4><h5 id="_2-1-1-file-header-文件头部-38字节" tabindex="-1"><a class="header-anchor" href="#_2-1-1-file-header-文件头部-38字节" aria-hidden="true">#</a> 2.1.1 File Header（文件头部）（38字节）</h5><p><strong>作用</strong>： 描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p><strong>大小</strong>：38字节</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</li><li><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没有使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><ul><li><p><code>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</code>：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间<strong>不需要是物理上的连续，而是逻辑上的连续。</strong></p></li><li><p><code>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</code>：</p><p>就是对于一个很长的字符串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字符串，这个比较短的值就称为校验和。</p><p>在比较两个很长的字符串之前，先比较这两个长字符串的校验和，如果校验和都不一样，则两个长字符串肯定是不同的，所以省去了直接比较两个比较长的字符串的时间损耗。</p><p>代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</p><p><strong>作用：</strong></p><p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p><p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），<strong>这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</strong></p><p>具体的：</p><p>每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会首先被同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。这里，校验方式就是采用hash算法进行校验。</p></li><li><p><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</p></li></ul><h5 id="_2-1-2-file-trailer-文件尾部-8字节" tabindex="-1"><a class="header-anchor" href="#_2-1-2-file-trailer-文件尾部-8字节" aria-hidden="true">#</a> 2.1.2 File Trailer（文件尾部）（8字节）</h5><ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li></ul><h4 id="_2-2-第2部分-空闲空间、用户记录和最小最大记录" tabindex="-1"><a class="header-anchor" href="#_2-2-第2部分-空闲空间、用户记录和最小最大记录" aria-hidden="true">#</a> 2.2 第2部分：空闲空间、用户记录和最小最大记录</h4><p><img src="/study/assets/image-20220506201446915.0c06eef6.png" alt="image-20220506201446915"></p><h5 id="_2-2-1-free-space-空闲空间" tabindex="-1"><a class="header-anchor" href="#_2-2-1-free-space-空闲空间" aria-hidden="true">#</a> 2.2.1 Free Space (空闲空间)</h5><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p><h5 id="_2-2-2-user-records-用户记录" tabindex="-1"><a class="header-anchor" href="#_2-2-2-user-records-用户记录" aria-hidden="true">#</a> 2.2.2 User Records (用户记录)</h5><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p><h5 id="_2-2-3-infimum-supremum-最小最大记录" tabindex="-1"><a class="header-anchor" href="#_2-2-3-infimum-supremum-最小最大记录" aria-hidden="true">#</a> 2.2.3 Infimum + Supremum（最小最大记录）</h5><p><strong>记录可以比较大小吗</strong>？ 是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301913664.png" alt="image-20220330191335574"></p><p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301914167.png" alt="image-20220330191446070"></p><h4 id="_2-3-第3部分-页目录和页面头部" tabindex="-1"><a class="header-anchor" href="#_2-3-第3部分-页目录和页面头部" aria-hidden="true">#</a> 2.3 第3部分：页目录和页面头部</h4><h5 id="_2-3-1-page-directory-页目录" tabindex="-1"><a class="header-anchor" href="#_2-3-1-page-directory-页目录" aria-hidden="true">#</a> 2.3.1 Page Directory（页目录）</h5><p><strong>为什么需要页目录</strong>？ 在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p><p><strong>页目录，二分法查找</strong></p><ol><li><p>将所有的记录<code>分成几个组</code>，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</p></li><li><p>第 1 组，也就是最小记录所在的分组只有 1 个记录； 最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在 4-8 条之间。 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会<code>尽量平分</code>。</p></li><li><p>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</p></li><li><p><code>页目录用来存储每组最后一条记录的地址偏移量</code>，这些地址偏移量会按照<code>先后顺序存储</code>起来，每组的地址偏移量也被称之为<code>槽（slot）</code>，每个槽相当于指针指向了不同组的最后一个记录。</p><p><img src="/study/assets/image-20220506222057864.5b7b0d22.png" alt="image-20220506222057864"></p></li></ol><p><strong>举例：</strong></p><p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301921631.png" alt="image-20220330192130497"></p><p>从这个图中我们需要注意这么几点：</p><ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性 <ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul></li></ul><p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301924874.png" alt="image-20220330192413776"></p><p><strong>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</strong></p><p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1~8条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。</p><p>分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><h5 id="_2-3-2-page-header-页面头部" tabindex="-1"><a class="header-anchor" href="#_2-3-2-page-header-页面头部" aria-hidden="true">#</a> 2.3.2 Page Header（页面头部）</h5><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h3 id="_3-innodb行格式-或记录格式" tabindex="-1"><a class="header-anchor" href="#_3-innodb行格式-或记录格式" aria-hidden="true">#</a> 3. InnoDB行格式（或记录格式）</h3><h4 id="_3-1-指定行格式的语法" tabindex="-1"><a class="header-anchor" href="#_3-1-指定行格式的语法" aria-hidden="true">#</a> 3.1 指定行格式的语法</h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER TABLE 表名 ROW_FORMAT=行格式名称
</code></pre></div><h4 id="_3-2-compact行格式" tabindex="-1"><a class="header-anchor" href="#_3-2-compact行格式" aria-hidden="true">#</a> 3.2 COMPACT行格式</h4><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301939611.png" alt="image-20220330193949517"></p><h5 id="_3-2-1-变长字段长度列表" tabindex="-1"><a class="header-anchor" href="#_3-2-1-变长字段长度列表" aria-hidden="true">#</a> 3.2.1 变长字段长度列表</h5><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p><blockquote><p>注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p></blockquote><h5 id="_3-2-2-null值列表" tabindex="-1"><a class="header-anchor" href="#_3-2-2-null值列表" aria-hidden="true">#</a> 3.2.2 NULL值列表</h5><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。 <strong>为什么定义NULL值列表？</strong> 之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ol><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ol><blockquote><p>注意：同样顺序也是反过来存放的</p></blockquote><h5 id="_3-2-3-记录头信息-5字节" tabindex="-1"><a class="header-anchor" href="#_3-2-3-记录头信息-5字节" aria-hidden="true">#</a> 3.2.3 记录头信息（5字节）</h5><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301945235.png" alt="image-20220330194534127"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><p><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。</p><ul><li>值为0：代表记录并没有被删除</li><li>值为1：代表记录被删除掉了</li></ul><p><strong>被删除的记录为什么还在页中存储呢？</strong> 你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p></li><li><p><code>min_rec_mask</code>：B+树的每层非叶子节点中的<strong>最小记录</strong>都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录（用户记录）的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</p></li><li><p><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录：</p><ul><li>0：表示普通记录</li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录</li><li>3：表示最大记录</li></ul></li><li><p><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</p><p><strong>怎么不见heap_no值为0和1的记录呢</strong>？ MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前</p><p><img src="/study/assets/image-20220506203302015.d12b544f.png" alt="image-20220506203302015"></p></li><li><p><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</p></li><li><p><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</p><p><img src="/study/assets/image-20220506203503802.4ac2bcfc.png" alt="image-20220506203503802"></p><p><img src="/study/assets/image-20220506203537904.838614ac.png" alt="image-20220506203537904"></p><p><img src="/study/assets/image-20220506203841921.e81a2329.png" alt="image-20220506203841921"></p><p><img src="/study/assets/image-20220506203906362.e2736081.png" alt="image-20220506203906362"></p><p><img src="/study/assets/image-20220506204023122.8b5f9c20.png" alt="image-20220506204023122"></p><p>注意：新插入的记录复用了被删除记录的存储空间。因为被删除记录的空间标记为可重用空间，InnoDB会维护一条所谓的垃圾链表，这些都是被标记为已删除的记录，这些记录占用的空间都是可重用空间。</p></li></ul><h5 id="_3-2-4-记录的真实数据" tabindex="-1"><a class="header-anchor" href="#_3-2-4-记录的真实数据" aria-hidden="true">#</a> 3.2.4 记录的真实数据</h5><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p><h4 id="_3-3-dynamic和compressed行格式" tabindex="-1"><a class="header-anchor" href="#_3-3-dynamic和compressed行格式" aria-hidden="true">#</a> 3.3 Dynamic和Compressed行格式</h4><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p><p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h3 id="_4-区、段和碎片区" tabindex="-1"><a class="header-anchor" href="#_4-区、段和碎片区" aria-hidden="true">#</a> 4. 区、段和碎片区</h3><h4 id="_4-1-为什么要有区" tabindex="-1"><a class="header-anchor" href="#_4-1-为什么要有区" aria-hidden="true">#</a> 4.1 为什么要有区？</h4><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，<strong>所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</strong></p><p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>（让页在物理磁盘上是连续的，那么就能进行顺序IO）。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，<code>功大于过</code>！</p><p>顺序读取：</p><p>顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们<strong>批量读取页面</strong>，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘IO操作了。内存与磁盘的交互是以页为单位的。如果一个磁盘的吞吐量是40MB/s,那么对于一个16kb大小的页来说，一次可以顺序读取2560个页，相当于一个页的读取时间是0.4ms。采用批量读取的方式，即使是从磁盘上读取，效率也比从内存中只单独读取一个页的效率要高。所以我们要尽可能使用顺序IO。顺序读取就是为了批量读取。</p><p>我们不能保证所有的数据页都是连续的，于是引入区的概念。</p><h4 id="_4-2-为什么要有段" tabindex="-1"><a class="header-anchor" href="#_4-2-为什么要有段" aria-hidden="true">#</a> 4.2 为什么要有段？</h4><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点页面的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点页面的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。<strong>数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</strong></p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><p>一个区中的页是连续的，但是段中的区不是连续的。</p><h4 id="_4-3-为什么要有碎片区" tabindex="-1"><a class="header-anchor" href="#_4-3-为什么要有碎片区" aria-hidden="true">#</a> 4.3 为什么要有碎片区？</h4><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以**默认情况下一个只存在几条记录的小表也需要2M的存储空间么？**以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>以及<code>一些完整的区</code>的集合。</p><h4 id="_4-4-区的分类" tabindex="-1"><a class="header-anchor" href="#_4-4-区的分类" aria-hidden="true">#</a> 4.4 区的分类</h4><p>区大体上可以分为4种类型：</p><ul><li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，<strong>直属于表空间</strong>。而处于<code>FSEG</code>状态的区是附属于某个段的。</p><h2 id="第08章-索引的创建与设计原则" tabindex="-1"><a class="header-anchor" href="#第08章-索引的创建与设计原则" aria-hidden="true">#</a> 第08章 索引的创建与设计原则</h2><h3 id="_1-索引的声明与使用" tabindex="-1"><a class="header-anchor" href="#_1-索引的声明与使用" aria-hidden="true">#</a> <strong>1.</strong> <strong>索引的声明与使用</strong></h3><h4 id="_1-1-索引的分类" tabindex="-1"><a class="header-anchor" href="#_1-1-索引的分类" aria-hidden="true">#</a> <strong>1.1</strong> <strong>索引的分类</strong></h4><ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li></ul><ol><li><p>普通索引</p><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p></li><li><p>唯一性索引</p><p><strong>声明了唯一性的字段，自动地会添加唯一性索引。</strong></p><p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一性索引。</p><p>例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的，通过唯一性索引，可以更快地确定某条记录。</p></li><li><p>主键索引</p><p>**主键约束的字段就自动会有主键索引。**主键索引就是聚簇索引。</p><p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上加了非空的约束，也就是NOT NULL + UNIQUE，一张表里最多只能有一个主键索引，也就是只能有一个键被设置为主键。</p></li><li><p>单列索引</p><p>在表中的单个字段上创建索引，单列索引只根据该字段进行索引，单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p></li><li><p>多列索引（或联合索引）</p><p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引，只有在查询条件中使用了字段id时，该索引才会被使用，使用组合索引时遵循<code>最左前缀原则</code>。</p></li></ol><h4 id="_1-2-创建索引" tabindex="-1"><a class="header-anchor" href="#_1-2-创建索引" aria-hidden="true">#</a> <strong>1.2</strong> <strong>创建索引</strong></h4><p>MySQL支持多种方式在单个或多个列上创建索引：在创建表的定义语句<code>CREATE TABLE</code>中指定索引列，使用<code>ALTER TABLE</code>语句在存在的表上创建索引，或者使用<code>CREATE INDEX</code>语句在已存在的表上添加索引。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE table_name [col_name data_type] 
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]
</code></pre></div><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li><code>col_name</code>为需要创建索引的字段列，<strong>该列必须从数据表中定义的多个列中选择；</strong></li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><h5 id="_1-创建表的时候创建索引" tabindex="-1"><a class="header-anchor" href="#_1-创建表的时候创建索引" aria-hidden="true">#</a> 1.创建表的时候创建索引</h5><p>使用CREATE TABLE创建表时，除了可以定义列（字段）的数据类型外，还可以定义主键约束、唯一性约束或者外键约束，但是不论定义以上哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。在是隐式的方式创建索引。</p><p>显示的方式创建：</p><ul><li><strong>1.</strong> <strong>创建普通索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE book( 
    book_id INT , 
    book_name VARCHAR(100), 
    authors VARCHAR(100), 
    info VARCHAR(100) , 
    comment VARCHAR(100), 
    year_publication YEAR, 
    INDEX idx_bname(book_name)
);#idx_bname是索引的名字，括号里的是索引作用的字段，为哪个字段、哪个列添加的索引。
#为这个字段加上索引之后，通过这个字段去检索数据会更有效率。
</code></pre></div><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token comment">#通过命令查看索引</span>
<span class="token comment">#1.</span>
<span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> book<span class="token punctuation">;</span>
<span class="token comment">#2.</span>
<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> book<span class="token punctuation">;</span>
</code></pre></div><p><img src="/study/assets/image-20220506234506092.8d58ae0a.png" alt="image-20220506234506092"></p><p>通过上图，发现就用到了索引。</p><ul><li><p><strong>2.</strong> <strong>创建唯一索引</strong></p><p><strong>创建唯一性约束，就会自动为这个字段创建唯一性索引</strong></p><p><strong>创建唯一索引，就会自动为这个字段创建唯一性约束。</strong></p><p>声明唯一索引的字段，即这个字段的值只能是唯一的，但是允许空值null，而主键是不允许空值的。</p></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE test1( 
    id INT NOT NULL, 
    name varchar(30) NOT NULL, 
    UNIQUE INDEX uk_idx_id(id) 
);
</code></pre></div><ul><li><p><strong>3.</strong> <strong>主键索引</strong></p><p>通过定义主键约束的方式去定义主键索引。就是隐式的方式。</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> book1<span class="token punctuation">(</span>
    book_id <span class="token keyword">INT</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> auto_increament<span class="token punctuation">,</span>
    book_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    authors <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    info <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> 
    <span class="token keyword">comment</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    year_publication <span class="token keyword">YEAR</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE student ( 
    id INT(10) UNSIGNED AUTO_INCREMENT, 
    student_no VARCHAR(200),
    student_name VARCHAR(200), 
    PRIMARY KEY(id) 
);
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 删除主键索引就是通过删除主键约束的方式。
ALTER TABLE student drop PRIMARY KEY ;
</code></pre></div><ul><li><strong>4.</strong> <strong>创建单列索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE test2( 
    id INT NOT NULL, 
    name CHAR(50) NULL, 
    INDEX single_idx_name(name(20)) 
);
</code></pre></div><ul><li><strong>5.</strong> <strong>创建组合索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE test3( 
    id INT(11) NOT NULL, 
    name CHAR(30) NOT NULL, 
    age INT(11) NOT NULL, 
    info VARCHAR(255), 
    INDEX multi_idx(id,name,age)  #这个字段的索引是有严格顺序的。因为b+树索引，会涉及到按字段的值进行排序，一定是先排id，再排name、再排age。
);
</code></pre></div><p>对于联合索引，使用索引的时候要遵循最左前缀原则。</p><p>最左前缀原则，通过b+树索引结构来理解，为什么在查询的时候，where子句的第一个条件没有判断联合索引的第一个字段，索引就失效，根据b+树就很好理解，因为创建索引的时候，就是有顺序的，字段相同的，再按第二个字段排，依次类推。所以一定要遵循最左前缀原则，创建联合索引时，写在第一位的字段，一定要是最常用的字段，最可能用在过滤条件中的字段。</p><ul><li><strong>6.</strong> <strong>创建全文索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE `papers` ( 
    id` int(10) unsigned NOT NULL AUTO_INCREMENT, 
    `title` varchar(200) DEFAULT NULL, 
    `content` text, PRIMARY KEY (`id`), 
    FULLTEXT KEY `title` (`title`,`content`) 
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);
</code></pre></div><ul><li><strong>7.</strong> <strong>创建空间索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE test5( 
    geo GEOMETRY NOT NULL, 
    SPATIAL INDEX spa_idx_geo(geo) 
) ENGINE=MyISAM;
</code></pre></div><h5 id="_2-在已经存在的表上创建索引" tabindex="-1"><a class="header-anchor" href="#_2-在已经存在的表上创建索引" aria-hidden="true">#</a> <strong>2.</strong> <strong>在已经存在的表上创建索引</strong></h5><ul><li><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER TABLE table_name 
ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]
</code></pre></div><ul><li><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name 
ON table_name (col_name[length],...) [ASC | DESC]
</code></pre></div><h4 id="_1-3-删除索引" tabindex="-1"><a class="header-anchor" href="#_1-3-删除索引" aria-hidden="true">#</a> <strong>1.3</strong> <strong>删除索引</strong></h4><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER TABLE table_name DROP INDEX index_name;
</code></pre></div><p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>DROP INDEX index_name ON table_name;
</code></pre></div><h3 id="_2-mysql8-0索引新特性" tabindex="-1"><a class="header-anchor" href="#_2-mysql8-0索引新特性" aria-hidden="true">#</a> <strong>2. MySQL8.0索引新特性</strong></h3><h4 id="_2-1-支持降序索引" tabindex="-1"><a class="header-anchor" href="#_2-1-支持降序索引" aria-hidden="true">#</a> <strong>2.1</strong> <strong>支持降序索引</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
</code></pre></div><h4 id="_2-2-隐藏索引" tabindex="-1"><a class="header-anchor" href="#_2-2-隐藏索引" aria-hidden="true">#</a> <strong>2.2</strong> <strong>隐藏索引</strong></h4><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p><strong>1.</strong> <strong>创建表时直接创建</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE tablename( 
    propname1 type1[CONSTRAINT1], 
    propname2 type2[CONSTRAINT2], 
    ……
    propnamen typen, 
    INDEX [indexname](propname1 [(length)]) INVISIBLE 
);
</code></pre></div><p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE INDEX indexname 
ON tablename(propname[(length)]) INVISIBLE;
</code></pre></div><p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER TABLE tablename 
ADD INDEX indexname (propname [(length)]) INVISIBLE;
</code></pre></div><p><strong>4.</strong> <strong>切换索引可见状态</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
</code></pre></div><h3 id="_3-索引的设计原则" tabindex="-1"><a class="header-anchor" href="#_3-索引的设计原则" aria-hidden="true">#</a> <strong>3.</strong> <strong>索引的设计原则</strong></h3><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于良好的性能非常重要。</p><h4 id="_3-1-哪些情况适合创建索引" tabindex="-1"><a class="header-anchor" href="#_3-1-哪些情况适合创建索引" aria-hidden="true">#</a> <strong>3.1</strong> <strong>哪些情况适合创建索引</strong></h4><p><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong>，那么推荐添加唯一性的索引。</p><p>如果这个字段已经有了唯一性约束了，那就不需要添加唯一性索引了，因为已经有了，已经自动生成唯一性索引了。</p><p>同理，为某个字段添加唯一性索引，那么也会自动添加唯一性约束。</p><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快地确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p><p>说明：不要以为唯一索引影响了insert速度（因为在增删改的时候，也是需要对索引进行维护的），这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><p><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></p><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p><p>比如说group by根据一个字段进行分组，order by对另一个字段进行排序，那么分别对这两个字段建立单列索引，最后发现只有group by的字段建立的索引生效了，这是因为sql的执行顺序，先where筛选出来之后，再分组group by，再having，再order by，于是只有group by的列的索引生效了。</p><p>现在为这两个字段添加联合索引，发现查询的时候就大大减少了时间。建立联合索引一定要把group by的字段写在前，order by的字段写在后。</p><p><strong>4. UPDATE、DELETE</strong> <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，<code>如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索（筛选）出来这条记录</code>，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><p><strong>5.DISTINCT</strong> <strong>字段需要创建索引</strong></p><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p><strong>6.</strong> <strong>多表</strong> <strong>JOIN</strong> <strong>连接操作时，创建索引注意事项</strong></p><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<strong><code>对 WHERE 条件创建索引</code></strong>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。比如course_id在student_info表和course表中都为int(11)类型，而不能一个为int，另一个为varchar类型。</p><p>如果一个为int类型，另一个为varchar类型，那么在join on的时候，MySQL会存在隐式的转换，一旦发生了隐式的转换，那么就是用了函数，用了函数，这个索引就会失效，查询效率就会降低。</p><p><strong>7.</strong> <strong>使用列的类型小的创建索引</strong></p><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><p>我们在定义表结构的时候要显示地指定列的类型，以整数类型为例，有TINYINT，MEDIUMINT，INT，BIGINT等，他们占用的存储空间依次递增，对应的列的索引占的存储空间也是依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的数据类型，就是占的存储空间范围小，从而索引占的空间小，一个数据页能存下更多的索引，即一个节点能放下更多的索引，节点就少，节点是数据页，是内存与磁盘IO交互的基本单位，那么与磁盘IO的次数越少，效率越高。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li><strong>数据类型越小，索引占用的存储空间就越少</strong>，在一个数据页（节点）内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，<strong>其他所有的二级索引的节点处都会存储一份记录的主键值</strong>，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p><p><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></p><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间，在我们需要为这个字符串建立索引的时候，那就意味着在对应的B+树中有以下两个问题：</p><ul><li>B+树索引的记录需要把该列的完整字符串存储起来，更费时。叶子节点是完整的用户记录，非叶子节点是目录项记录，是索引列+页号的形式。索引列是字符串的，那么需要占用很大存储空间，一个数据页（目录页）即一个节点存储的索引就更少，所需要的节点就更多，增加了与磁盘的IO，可以这么理解。</li><li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较的时候，会占用更多时间。</li></ul><p>我们可以通过截取字段的前面一部分内容建立索引，这个叫做前缀索引。这样在查找记录时虽然不能精确地定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值进行回表查询。</p><p>区分度计算公式：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>count(distinct left(列名, 索引长度))/count(*)
</code></pre></div><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【<code>强制</code>】在 varchar 字段上建立索引时，<strong>必须指定索引长度，没必要对全字段建立索引</strong>，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>。</p><p><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></p><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p><p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p><p><strong>10.</strong> <strong>使用最频繁的列放到联合索引的左侧</strong></p><p><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p><h4 id="_3-2-限制索引的数目" tabindex="-1"><a class="header-anchor" href="#_3-2-限制索引的数目" aria-hidden="true">#</a> <strong>3.2</strong> <strong>限制索引的数目</strong></h4><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li><strong>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</strong></li></ul><h4 id="_3-3-哪些情况不适合创建索引" tabindex="-1"><a class="header-anchor" href="#_3-3-哪些情况不适合创建索引" aria-hidden="true">#</a> <strong>3.3</strong> <strong>哪些情况不适合创建索引</strong></h4><p><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></p><p><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></p><p><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></p><p><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong></p><p><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p><p><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></p><p><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></p><p><img src="/study/assets/image-20220507160540797.4591d3ad.png" alt="image-20220507160540797"></p><h2 id="第09章-性能分析工具的使用" tabindex="-1"><a class="header-anchor" href="#第09章-性能分析工具的使用" aria-hidden="true">#</a> 第09章 性能分析工具的使用</h2><p>在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p><h3 id="_1-统计sql的查询成本-last-query-cost" tabindex="-1"><a class="header-anchor" href="#_1-统计sql的查询成本-last-query-cost" aria-hidden="true">#</a> <strong>1.</strong> <strong>统计SQL的查询成本：last_query_cost</strong></h3><p>一条SQL查询语句在执行前需要确定查询执行计划（优化器），如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本（优化器、查询优化阶段），从中选择<code>成本最小</code>的一个作为最终执行的执行计划。</p><p>SQL语句：查询缓存-解析器-优化器-执行器</p><p>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的last_query_cost变量值来得到当前查询的查询成本。它通常也是我们评价一个sql查询的执行效率的一个常用指标。<code>这个查询成本对应的是SQL语句所需要读取的页的数量。</code>数据页在B+树索引中就是一个节点！！</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW STATUS LIKE &#39;last_query_cost&#39;;
</code></pre></div><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><h3 id="_2-定位执行慢的sql-慢查询日志" tabindex="-1"><a class="header-anchor" href="#_2-定位执行慢的sql-慢查询日志" aria-hidden="true">#</a> <strong>2.</strong> <strong>定位执行慢的SQL：慢查询日志</strong></h3><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p><p>它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql语句执行超过5秒钟，我们就算慢SQL，希望能收集到超过5秒的sql，结合explain进行全面分析。</p><p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>慢查询日志支持将日志记录写入文件。</p><h4 id="_2-1-开启慢查询日志参数" tabindex="-1"><a class="header-anchor" href="#_2-1-开启慢查询日志参数" aria-hidden="true">#</a> <strong>2.1</strong> <strong>开启慢查询日志参数</strong></h4><p><strong>1.</strong> <strong>开启slow_query_log</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>set global slow_query_log=&#39;ON&#39;;
</code></pre></div><p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;%slow_query_log%;
</code></pre></div><p><strong>2.</strong> <strong>修改long_query_time阈值</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;%long_query_time%&#39;;
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 
mysql &gt; set global long_query_time = 1; 
mysql&gt; show global variables like &#39;%long_query_time%&#39;; 

#对当前session的long_query_time有效
mysql&gt; set long_query_time=1; 
mysql&gt; show variables like &#39;%long_query_time%&#39;;
</code></pre></div><p>这样的方式修改配置，都是临时的方式，一旦服务重启，配置就失效了，如果想永久修改配置，那么就去配置文件中进行修改。</p><p><img src="/study/assets/image-20220507163818901.901def3f.png" alt="image-20220507163818901"></p><p><img src="/study/assets/image-20220507164734700.7fbfb371.png" alt="image-20220507164734700"></p><h4 id="_2-2-查看慢查询数目" tabindex="-1"><a class="header-anchor" href="#_2-2-查看慢查询数目" aria-hidden="true">#</a> <strong>2.2</strong> <strong>查看慢查询数目</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;
</code></pre></div><h4 id="_2-3-慢查询日志分析工具-mysqldumpslow" tabindex="-1"><a class="header-anchor" href="#_2-3-慢查询日志分析工具-mysqldumpslow" aria-hidden="true">#</a> <strong>2.3</strong> <strong>慢查询日志分析工具：mysqldumpslow</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token comment">#得到返回记录集最多的10个SQL </span>
mysqldumpslow -s r -t <span class="token number">10</span> /var/lib/mysql/atguigu-slow.log 
<span class="token comment">#得到访问次数最多的10个SQL </span>
mysqldumpslow -s c -t <span class="token number">10</span> /var/lib/mysql/atguigu-slow.log
<span class="token comment">#得到按照时间排序的前10条里面含有左连接的查询语句 </span>
mysqldumpslow -s t -t <span class="token number">10</span> -g <span class="token string">&quot;left join&quot;</span> /var/lib/mysql/atguigu-slow.log 
<span class="token comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 </span>
mysqldumpslow -s r -t <span class="token number">10</span> /var/lib/mysql/atguigu-slow.log <span class="token operator">|</span> <span class="token function">more</span>
</code></pre></div><h4 id="_2-4-关闭慢查询日志" tabindex="-1"><a class="header-anchor" href="#_2-4-关闭慢查询日志" aria-hidden="true">#</a> <strong>2.4</strong> <strong>关闭慢查询日志</strong></h4><p>在开发中，不是调优的时候，就关闭慢查询日志，多少会影响SQL的性能。</p><p><strong>方式1：永久性方式</strong></p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">slow_query_log</span><span class="token punctuation">=</span><span class="token value attr-value">OFF</span>
<span class="token comment">#或</span>
<span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token comment">#slow_query_log =OFF</span>
</code></pre></div><p><strong>方式2：临时性方式</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET GLOBAL slow_query_log=off;
</code></pre></div><h3 id="_3-查看-sql-执行成本-show-profile" tabindex="-1"><a class="header-anchor" href="#_3-查看-sql-执行成本-show-profile" aria-hidden="true">#</a> <strong>3.</strong> <strong>查看</strong> <strong>SQL</strong> <strong>执行成本：SHOW PROFILE</strong></h3><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>show variables like &#39;profiling&#39;;
#开启
set profiling = &#39;ON&#39;;
#查看，能看到当前会话一共执行了几个查询
show profiles;
</code></pre></div><p><img src="/study/assets/image-20220507165929442.54f87386.png" alt="image-20220507165929442"></p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token comment">#如果我们想查看最近一次查询的开销，可以使用：</span>
<span class="token keyword">show</span> profile<span class="token punctuation">;</span>
<span class="token comment">#我们也可以查看指定Query ID的查询语句的开销</span>
<span class="token keyword">show</span> profile cpu<span class="token punctuation">,</span>block io <span class="token keyword">for</span> query <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/study/assets/image-20220507170030634.1b53a78c.png" alt="image-20220507170030634"></p><p><img src="/study/assets/image-20220507170059960.6f42d8cd.png" alt="image-20220507170059960"></p><h3 id="_4-分析查询语句-explain" tabindex="-1"><a class="header-anchor" href="#_4-分析查询语句-explain" aria-hidden="true">#</a> <strong>4.</strong> <strong>分析查询语句：EXPLAIN</strong></h3><p>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具对查询语句做针对性的分析。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。</p><p>MySQL中有专门负责优化select语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，<strong>为客户端的请求Query提供它认为最优的执行计划。</strong></p><p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么（物理查询优化），采用哪些索引（物理查询优化），对于每个表采用什么访问方法来具体执行查询等。<strong>MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划</strong>，看懂EXPLAIN语句的各个输出项，可以针对性地提升我们的查询语句的性能。</p><p>能做什么？</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li><strong>哪些索引可以使用</strong></li><li><strong>哪些索引被实际使用</strong></li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p><img src="/study/assets/image-20220507171258096.6ed85af6.png" alt="image-20220507171258096"></p><h4 id="_4-1-基本语法" tabindex="-1"><a class="header-anchor" href="#_4-1-基本语法" aria-hidden="true">#</a> <strong>4.1</strong> <strong>基本语法</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>EXPLAIN SELECT select_options 
#或者
DESCRIBE SELECT select_options
</code></pre></div><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h4 id="_4-2-explain各列作用" tabindex="-1"><a class="header-anchor" href="#_4-2-explain各列作用" aria-hidden="true">#</a> <strong>4.2 EXPLAIN各列作用</strong></h4><p><strong>1. table</strong></p><p>EXPLAIN语句执行后可能会出现多条记录，<strong>一条记录对应着一个表！</strong></p><p><strong>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</strong></p><p><strong>2. id</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li></ul><p>出现了几个select关键字，id值就会有几个。<code>但是要注意：就算sql语句出现了两个select关键字，比如子查询，那么explain的时候也不见得有2个id值，这是因为查询优化器可能对涉及到子查询的语句进行重写，转变为多表查询，多表查询，那么select关键字就只有1个了。</code></p><p>比如说子查询，那么一个sql语句中可能有两个select关键字，就有两个id。（前提是没有被查询优化器转换成多表查询）</p><p>在一个大的查询语句中，每个select关键字都对应一个唯一的id。</p><p><strong>3. select_type</strong></p><p>select关键字对应的那个查询的类型，确定小查询在整个大查询中扮演了一个什么角色。</p><p>一条大的查询语句里边可以包含若干个select关键字，每个select关键字代表着一个小的查询语句，而每个select关键字的from子句中都可以包含若干张表（这些表用来做连接查询），<code>每一张表都对应着执行计划输出中的一条记录</code>，对于在同一个select关键字中的表来说，他们的id值是相同的。</p><p>MySQL为每一个select关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。下面是select_type可能的值。</p><p><img src="/study/assets/image-20220507200231991.d61b0b6a.png" alt="image-20220507200231991"></p><p>对于包含子查询的大查询来说，它是由几个小查询组成的，<strong>其中最左边的查询的select_type的值就是primary</strong></p><p>对于包含UNION或者UNION ALL的查询来说，<strong>最左边的查询的select_type的值是primary，其余查询的select_type是union</strong></p><p><img src="/study/assets/image-20220507213023844.6d23c3dd.png" alt="image-20220507213023844"></p><p><img src="/study/assets/image-20220507213340990.41822ac4.png" alt="image-20220507213340990"></p><p><strong>4. partitions</strong></p><p><strong>5. type（重点）</strong></p><p><img src="/study/assets/image-20220507213742681.142e924b.png" alt="image-20220507213742681"></p><p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong></p><p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）</strong></p><ul><li><p>System</p><p>当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法是system</p></li><li><p>const</p><p>当我们根据主键或者是唯一的二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p></li><li><p>eq_ref</p><p><img src="/study/assets/image-20220507214421081.62173eed.png" alt="image-20220507214421081"></p><p><img src="/study/assets/image-20220507214433475.9f94d878.png" alt="image-20220507214433475"></p></li><li><p>ref</p><p>当通过普通的二级索引列与常数进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p></li><li><p>range</p><p><img src="/study/assets/image-20220507215125805.6003bcc1.png" alt="image-20220507215125805"></p></li><li><p>index</p><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index，比如说我们建立了联合索引给以下2个字段a b</p><p>当where子句中只出现了b，而select子句中只有a，这时根据where子句，本来是用不上联合索引，因为没有遵循最左前缀原则，但是MySQL优化器给查询语句进行了优化，用上这个联合索引，但是需要根据这整个联合索引，扫描全部的索引记录，这时访问方法就是index。</p></li></ul><p><strong>6. possible_keys和key</strong></p><p>在EXPLAIN语句的输出执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时<strong>可能用到的索引</strong>有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。</p><p><strong>7. key_len（重点）</strong></p><p>实际用到的索引长度（即：字节数）</p><p>帮我们检查是否充分利用上了索引，值越大越好，主要针对联合索引有参考意义。</p><p><strong>key_len的长度计算公式：</strong></p><div class="language-text ext-text"><pre class="language-text"><code>varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) 

varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)

char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) 

char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)
</code></pre></div><p><strong>8. ref</strong></p><p><strong>9. rows（重点）</strong></p><p>预估的需要读取的记录条数</p><p><strong>10. filtered</strong></p><p><strong>11. Extra</strong></p><h3 id="_5-explain的进一步使用" tabindex="-1"><a class="header-anchor" href="#_5-explain的进一步使用" aria-hidden="true">#</a> <strong>5. EXPLAIN的进一步使用</strong></h3><h4 id="_5-1-explain四种输出格式" tabindex="-1"><a class="header-anchor" href="#_5-1-explain四种输出格式" aria-hidden="true">#</a> <strong>5.1 EXPLAIN四种输出格式</strong></h4><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p><p><strong>1.</strong> <strong>传统格式</strong></p><p><strong>2. JSON格式</strong></p><p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p><p><strong>3. TREE格式</strong></p><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><p><strong>4.</strong> <strong>可视化输出</strong></p><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p><h4 id="_5-2-show-warnings的使用" tabindex="-1"><a class="header-anchor" href="#_5-2-show-warnings的使用" aria-hidden="true">#</a> <strong>5.2 SHOW WARNINGS的使用</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
# 查看优化后的执行语句
mysql&gt; SHOW WARNINGS\G
</code></pre></div><h3 id="_6-分析优化器执行计划-trace" tabindex="-1"><a class="header-anchor" href="#_6-分析优化器执行计划-trace" aria-hidden="true">#</a> <strong>6.</strong> <strong>分析优化器执行计划：trace</strong></h3><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 开启
SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; 
# 设置大小
set optimizer_trace_max_mem_size=1000000;
# 使用
select * from student where id &lt; 10;
select * from information_schema.optimizer_trace\G
</code></pre></div><h3 id="_7-mysql监控分析视图-sys-schema" tabindex="-1"><a class="header-anchor" href="#_7-mysql监控分析视图-sys-schema" aria-hidden="true">#</a> <strong>7. MySQL监控分析视图-sys schema</strong></h3><h4 id="_7-1-sys-schema视图使用场景" tabindex="-1"><a class="header-anchor" href="#_7-1-sys-schema视图使用场景" aria-hidden="true">#</a> <strong>7.1 Sys schema视图使用场景</strong></h4><p><strong>索引情况</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>#1. 查询冗余索引 
select * from sys.schema_redundant_indexes; 
#2. 查询未使用过的索引 
select * from sys.schema_unused_indexes; 
#3. 查询索引的使用情况 
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=&#39;dbname&#39; ;
</code></pre></div><p><strong>表相关</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 1. 查询表的访问量 
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; 
# 2. 查询占用bufferpool较多的表 
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10; 
# 3. 查看表的全表扫描情况 
select * from sys.statements_with_full_table_scans where db=&#39;dbname&#39;;
</code></pre></div><p><strong>语句相关</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>#1. 监控SQL执行的频率 
select db,exec_count,query from sys.statement_analysis order by exec_count desc; 
#2. 监控使用了排序的SQL 
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1; 
#3. 监控使用了临时表或者磁盘临时表的SQL 
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;
</code></pre></div><p><strong>IO相关</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>#1. 查看消耗磁盘IO的文件 
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
</code></pre></div><p><strong>Innodb</strong> <strong>相关</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>#1. 行锁阻塞情况 
select * from sys.innodb_lock_waits;
</code></pre></div><h2 id="第10章-索引优化与查询优化" tabindex="-1"><a class="header-anchor" href="#第10章-索引优化与查询优化" aria-hidden="true">#</a> 第10章 索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？</p><ul><li>索引失效、没有充分利用到索引---索引优化</li><li>关联查询太多JOIN---SQL优化</li><li>服务器调优及各个参数设置（缓冲、线程数等）--调整my.cnf</li><li>数据过多--分库分表</li></ul><p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分为<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块</p><ul><li>物理查询优化是指通过索引和表连接方式等技术来进行优化，这里重点掌握索引的使用。</li><li>逻辑查询优化就是通过SQL等价变换提升查询效率，直白一点就是换一种查询写法执行效率可能更高。</li></ul><h3 id="_1-索引失效案例" tabindex="-1"><a class="header-anchor" href="#_1-索引失效案例" aria-hidden="true">#</a> <strong>1.</strong> <strong>索引失效案例</strong></h3><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p><h4 id="_1-1-全值匹配我最爱" tabindex="-1"><a class="header-anchor" href="#_1-1-全值匹配我最爱" aria-hidden="true">#</a> <strong>1.1</strong> <strong>全值匹配我最爱</strong></h4><h4 id="_1-2-最佳左前缀法则" tabindex="-1"><a class="header-anchor" href="#_1-2-最佳左前缀法则" aria-hidden="true">#</a> <strong>1.2</strong> <strong>最佳左前缀法则</strong></h4><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引<code>后面</code>的字段都无法被使用。</strong><code>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</code></p><p>比如现在有索引：</p><p><img src="/study/assets/image-20220508230451144.3c5b8f15.png" alt="image-20220508230451144"></p><p>查询语句如下：</p><p><img src="/study/assets/image-20220508230501235.2b021fa1.png" alt="image-20220508230501235"></p><p>根据最左前缀原则，查询条件中有联合索引的第一个字段age，那么这个联合索引肯定能被用上，但是不是用了这个联合索引的全部，是用了联合索引的第一个字段，联合索引第一个字段之后的索引都失效了，因为查询条件中age之后不是第二个字段，这个要根据B+树来思考，B+树联合索引，首先会根据第一个字段排序，然后第一个字段相同的话会根据第二个字段排序，依次类推。查询条件中被有写第二个字段，那么之后的索引当然会失效，因为在索引树中若不先找第二个字段，就无法找第三个字段。</p><p>所以查询条件中一定要写联合索引的第一个字段，索引才生效。</p><p>上图这种情况也只有联合索引的第一个字段生效。</p><p><img src="/study/assets/image-20220508230751274.cb85b876.png" alt="image-20220508230751274"></p><h4 id="_1-3-主键插入顺序" tabindex="-1"><a class="header-anchor" href="#_1-3-主键插入顺序" aria-hidden="true">#</a> <strong>1.3</strong> <strong>主键插入顺序</strong></h4><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的（聚簇索引会被InnoDB隐式创建）。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p><h4 id="_1-4-计算、函数、类型转换-自动或手动-导致索引失效" tabindex="-1"><a class="header-anchor" href="#_1-4-计算、函数、类型转换-自动或手动-导致索引失效" aria-hidden="true">#</a> <strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></h4><p><img src="/study/assets/image-20220508233703417.37504d51.png" alt="image-20220508233703417"></p><p>下面这个语句可以使用上索引</p><p>要是SQL语句用上了计算、函数，那么就要考虑换个写法。</p><h4 id="_1-5-类型转换导致索引失效" tabindex="-1"><a class="header-anchor" href="#_1-5-类型转换导致索引失效" aria-hidden="true">#</a> <strong>1.5</strong> <strong>类型转换导致索引失效</strong></h4><p><img src="/study/assets/image-20220508234123285.ae53250a.png" alt="image-20220508234123285"></p><p>下面的语句可以使用上索引，因为上面的语句会做类型转换。</p><h4 id="_1-6-范围条件右边的列索引失效" tabindex="-1"><a class="header-anchor" href="#_1-6-范围条件右边的列索引失效" aria-hidden="true">#</a> <strong>1.6</strong> <strong>范围条件右边的列索引失效</strong></h4><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。<strong>（创建的联合索引中，务必把范围涉及到的字段写在最后）</strong></p><p>为什么会失效，就是因为范围查询，找不到具体的值，是一个范围，所以后面的列会失效，这要从b+树的角度来理解，找到了一个数据页中的一条数据之后，不管是目录项还是用户数据项，接着才能往下找，因为联合索引就是按照字段的值来进行排序的，如果是范围的话，就没有办法往下找了。</p></blockquote><p><img src="/study/assets/image-20220508234708282.82a35a31.png" alt="image-20220508234708282"></p><p>这条sql语句，优化器会自动将我们的where条件中的顺序做转换。</p><p>在联合索引中，将会使用到范围的列写在最右。相当于给我们暗示，最后去考虑范围索引。</p><h4 id="_1-7-不等于-或者-索引失效" tabindex="-1"><a class="header-anchor" href="#_1-7-不等于-或者-索引失效" aria-hidden="true">#</a> <strong>1.7</strong> <strong>不等于(!= 或者&lt;&gt;)索引失效</strong></h4><h4 id="_1-8-is-null可以使用索引-is-not-null无法使用索引" tabindex="-1"><a class="header-anchor" href="#_1-8-is-null可以使用索引-is-not-null无法使用索引" aria-hidden="true">#</a> <strong>1.8 is null可以使用索引，is not null无法使用索引</strong></h4><blockquote><p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&#39;&#39;)</p><p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p></blockquote><h4 id="_1-9-like以通配符-开头索引失效" tabindex="-1"><a class="header-anchor" href="#_1-9-like以通配符-开头索引失效" aria-hidden="true">#</a> <strong>1.9 like以通配符%开头索引失效</strong></h4><p>在使用LIKE关键字进行查询的语句中，如果匹配字符串的第一个字符为“%”，索引就不会起作用，只有“%”不在第一个位置，索引才会起作用。</p><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h4 id="_1-10-or-前后存在非索引的列-索引失效" tabindex="-1"><a class="header-anchor" href="#_1-10-or-前后存在非索引的列-索引失效" aria-hidden="true">#</a> <strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong></h4><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><h4 id="_1-11-数据库和表的字符集统一使用utf8mb4" tabindex="-1"><a class="header-anchor" href="#_1-11-数据库和表的字符集统一使用utf8mb4" aria-hidden="true">#</a> <strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong></h4><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p><p>一般性建议</p><ul><li><p>对于单列索引：</p><p>尽量选择针对当前query过滤性更好的字段</p></li><li><p>对于联合索引：</p><ul><li>当前query中，过滤性最好的字段，也就是散列值更小的字段，过滤效果好的字段，应该尽量放在联合索引的前面</li><li>尽量选择能够包含当前query中where子句中的字段作为联合索引</li><li>若有范围查询，尽量将范围查询的字段写在联合索引的最后面</li></ul></li></ul><h3 id="_2-关联查询优化" tabindex="-1"><a class="header-anchor" href="#_2-关联查询优化" aria-hidden="true">#</a> <strong>2.</strong> <strong>关联查询优化</strong></h3><h4 id="_2-1-内连接" tabindex="-1"><a class="header-anchor" href="#_2-1-内连接" aria-hidden="true">#</a> 2.1 内连接</h4><blockquote><p>结论1：<strong>对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</strong></p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，<strong>则有索引的字段所在的表会被作为被驱动表</strong></p><p>结论3：对于内连接来说，两个表的层级是一样的，不存在主表和从表，那么由优化器来决定哪个表是驱动表，哪个表是被驱动表，在两个表的连接条件都存在索引或者都不存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p><p>因为被驱动表是被比较次数更多的，所以更需要对被驱动表进行优化，可以这么理解。被驱动表有索引，成本更低！！</p></blockquote><h4 id="_2-2-外连接" tabindex="-1"><a class="header-anchor" href="#_2-2-外连接" aria-hidden="true">#</a> 2.2 外连接</h4><ul><li><p>以左外连接为例，左边的表即主表是驱动表，右边的表即从表，是被驱动表。</p><p>被驱动表上建立索引，那么效率会更好，是因为join的底层执行方式，驱动表中拿一条数据，每拿一条都要和被驱动表中的所有数据进行比较，所以被驱动表的比较字段上需要建立索引</p><p><img src="/study/assets/image-20220509001427900.4192f424.png" alt="image-20220509001427900"></p><p>为什么不是给左表中的这个字段建立索引效果更好呢？是因为这是左外链接，本来左表中的数据就是全要的，左外连接的意思就是说结果集中除了满足条件的数据之外，主表中的其他数据即不满足on条件中的数据，也要返回。</p><p>给主表和从表中的这个用于比较的字段都添加上索引效果更好。</p><p>JOIN底层会把<code>被驱动表</code>的数据加载到缓存中，因为每拿一次主表的数据，都要和从表的所有数据进行比较，所以把从表的所有数据都加载到缓存中。</p></li></ul><h4 id="_2-3-join语句原理" tabindex="-1"><a class="header-anchor" href="#_2-3-join语句原理" aria-hidden="true">#</a> 2.3 JOIN语句原理</h4><h5 id="_2-3-1-外连接和内连接" tabindex="-1"><a class="header-anchor" href="#_2-3-1-外连接和内连接" aria-hidden="true">#</a> 2.3.1 外连接和内连接</h5><p>join方式连接多个表，本质上是各个表之间数据的循环匹配。</p><p>驱动表和被驱动表：</p><ul><li>驱动表就是主表</li><li>被驱动表就是从表、非驱动表</li></ul><p>对于内连接来说</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">join</span> b <span class="token keyword">on</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>a 一定是驱动表吗，b一定是被驱动表吗。</p><p>不一定，优化器会根据查询语句做优化，决定先查哪张表，先查询的那张表就是驱动表，反之就是被驱动表。</p><p>可以理解为优化器要对被驱动表做优化，如果字段有索引，那么有索引的字段所在的那个表是被驱动表。如果on条件里面，字段都没有索引，或者都有索引，那么是小表驱动大表。</p><p>对于外连接来说</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> a <span class="token keyword">left</span> <span class="token keyword">join</span> b <span class="token keyword">on</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>也不一定a就是驱动表，b就是被驱动表，因为查询优化器可能会给这个sql语句做优化，优化之后可能会变成内连接，那么谁是驱动表谁是被驱动表，就由优化器决定了。</p><h5 id="_2-3-2-simple-nested-loop-join-简单嵌套循环索引" tabindex="-1"><a class="header-anchor" href="#_2-3-2-simple-nested-loop-join-简单嵌套循环索引" aria-hidden="true">#</a> 2.3.2 Simple Nested-Loop Join（简单嵌套循环索引）</h5><p>算法相当简单，从表A中取出一条数据，遍历表B，将匹配到的数据放到result，以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p><p><img src="/study/assets/image-20220509181504432.b2685c95.png" alt="image-20220509181504432"></p><p>当然MySQL肯定不会进行这么粗暴的表连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p><h5 id="_2-3-3-index-nested-loop-join-索引嵌套循环连接" tabindex="-1"><a class="header-anchor" href="#_2-3-3-index-nested-loop-join-索引嵌套循环连接" aria-hidden="true">#</a> 2.3.3 Index Nested-Loop Join（索引嵌套循环连接）</h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求<strong>被驱动表上必须<code>有索引</code>才行。</strong></p><p>通过外层表匹配条件直接与<strong>内层表索引</strong>进行匹配，避免和内层表的每条记录去进行比较，这样极大地减少了对内层表的匹配次数。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png" alt="image-20220401182649509"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故MySQL优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><h5 id="_2-3-4-block-nested-loop-join-块嵌套循环连接" tabindex="-1"><a class="header-anchor" href="#_2-3-4-block-nested-loop-join-块嵌套循环连接" aria-hidden="true">#</a> 2.3.4 Block Nested-Loop Join（块嵌套循环连接）</h5><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。<code>每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存</code>，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png" alt="image-20220401183344880"></p><blockquote><p>join buffer缓存的不只是关联表的列，select后面的列也会被缓存起来。</p><p><img src="/study/assets/image-20220509183558237.255c63f3.png" alt="image-20220509183558237"></p></blockquote><p>小结：</p><ul><li>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</li><li>永远用小表驱动大表（其本质是减少外层循环的数据数量）</li><li>为被驱动表匹配的条件增加索引（减少内层表的循环匹配次数，增加索引之后，外层表的一条数据就不需要和内层表全表数据进行匹配，而是根据索引匹配）</li><li>增大join buffer size的大小（一次缓存驱动表的数据越多，那么被驱动表的扫描次数就越少）</li><li>减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</li></ul><h5 id="_2-3-5-hash-join" tabindex="-1"><a class="header-anchor" href="#_2-3-5-hash-join" aria-hidden="true">#</a> 2.3.5 Hash Join</h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。 <ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul></li></ul><h3 id="_3-子查询优化" tabindex="-1"><a class="header-anchor" href="#_3-子查询优化" aria-hidden="true">#</a> <strong>3.</strong> <strong>子查询优化</strong></h3><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> **语句实现比较复杂的查询。但是，子查询的执行效率不高。**原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>**在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h3 id="_4-排序优化" tabindex="-1"><a class="header-anchor" href="#_4-排序优化" aria-hidden="true">#</a> <strong>4.</strong> <strong>排序优化</strong></h3><p>在MySQL中，支持两种排序方式，分别是FileSort排序和Index排序：</p><ul><li>Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高</li><li>Filesort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件IO到磁盘进行排序的情况，效率较低。</li></ul><ol><li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p></li><li><p>尽量使用 Index 完成 ORDER BY 排序。<strong>如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</strong></p></li><li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p></li></ol><h3 id="_5-group-by优化" tabindex="-1"><a class="header-anchor" href="#_5-group-by优化" aria-hidden="true">#</a> <strong>5. GROUP BY优化</strong></h3><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h3 id="_6-优化分页查询" tabindex="-1"><a class="header-anchor" href="#_6-优化分页查询" aria-hidden="true">#</a> <strong>6.</strong> <strong>优化分页查询</strong></h3><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a
WHERE t.id = a.id;
</code></pre></div><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;
</code></pre></div><h3 id="_7-优先考虑覆盖索引" tabindex="-1"><a class="header-anchor" href="#_7-优先考虑覆盖索引" aria-hidden="true">#</a> <strong>7.</strong> <strong>优先考虑覆盖索引</strong></h3><h5 id="_7-1-什么是覆盖索引" tabindex="-1"><a class="header-anchor" href="#_7-1-什么是覆盖索引" aria-hidden="true">#</a> <strong>7.1</strong> <strong>什么是覆盖索引？</strong></h5><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><h5 id="_7-2-覆盖索引的利弊" tabindex="-1"><a class="header-anchor" href="#_7-2-覆盖索引的利弊" aria-hidden="true">#</a> <strong>7.2</strong> <strong>覆盖索引的利弊</strong></h5><p><strong>好处：</strong></p><p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p><p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p><strong>弊端：</strong></p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><h3 id="_8-索引条件下推" tabindex="-1"><a class="header-anchor" href="#_8-索引条件下推" aria-hidden="true">#</a> <strong>8.</strong> <strong>索引条件下推</strong></h3><h4 id="_8-1-使用前后的扫描过程" tabindex="-1"><a class="header-anchor" href="#_8-1-使用前后的扫描过程" aria-hidden="true">#</a> <strong>8.1</strong> <strong>使用前后的扫描过程</strong></h4><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层</p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><h3 id="_9-其它查询优化策略" tabindex="-1"><a class="header-anchor" href="#_9-其它查询优化策略" aria-hidden="true">#</a> <strong>9.</strong> <strong>其它查询优化策略</strong></h3><h4 id="_9-1-exists-和-in-的区分" tabindex="-1"><a class="header-anchor" href="#_9-1-exists-和-in-的区分" aria-hidden="true">#</a> <strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong></h4><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p><h4 id="_9-2-count-与count-具体字段-效率" tabindex="-1"><a class="header-anchor" href="#_9-2-count-与count-具体字段-效率" aria-hidden="true">#</a> <strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong></h4><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p>**环节2：**如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p><p>**环节3：**在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h4 id="_9-3-关于select" tabindex="-1"><a class="header-anchor" href="#_9-3-关于select" aria-hidden="true">#</a> <strong>9.3</strong> <strong>关于SELECT(*)</strong></h4><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将**&quot;*&quot;按序转换成所有列名**，这会大大的耗费资源和时间。</p><p>② 无法使用<code>覆盖索引</code></p><h4 id="_9-4-limit-1-对优化的影响" tabindex="-1"><a class="header-anchor" href="#_9-4-limit-1-对优化的影响" aria-hidden="true">#</a> <strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong></h4><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p><h4 id="_9-5-多使用commit" tabindex="-1"><a class="header-anchor" href="#_9-5-多使用commit" aria-hidden="true">#</a> <strong>9.5</strong> <strong>多使用COMMIT</strong></h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li><p>回滚段上用于恢复数据的信息</p></li><li><p>被程序语句获得的锁</p></li><li><p>redo / undo log buffer 中的空间</p></li><li><p>管理上述 3 种资源中的内部花费</p></li></ul><h2 id="第11章-数据库的设计规范" tabindex="-1"><a class="header-anchor" href="#第11章-数据库的设计规范" aria-hidden="true">#</a> 第11章 数据库的设计规范</h2><h3 id="_1-范-式" tabindex="-1"><a class="header-anchor" href="#_1-范-式" aria-hidden="true">#</a> <strong>1.</strong> <strong>范 式</strong></h3><h4 id="_1-1-范式简介" tabindex="-1"><a class="header-anchor" href="#_1-1-范式简介" aria-hidden="true">#</a> <strong>1.1</strong> <strong>范式简介</strong></h4><p>**在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h4 id="_1-2-范式都包括哪些" tabindex="-1"><a class="header-anchor" href="#_1-2-范式都包括哪些" aria-hidden="true">#</a> <strong>1.2</strong> <strong>范式都包括哪些</strong></h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p><p>高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式，在第一范式的基础上进一步满足更多规范要求的称为第二范式，其余范式依次类推。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png" alt="image-20220403092826169"></p><h4 id="_1-3-键和相关属性的概念" tabindex="-1"><a class="header-anchor" href="#_1-3-键和相关属性的概念" aria-hidden="true">#</a> <strong>1.3</strong> <strong>键和相关属性的概念</strong></h4><p>范式的定义会用到主键和候选键，数据库中的键由一个或者多个属性组成。数据表中常用的几种键和属性的定义：</p><ul><li>超键：能唯一标识元组（表中的一条条数据）的<code>属性集</code>叫做超键（属性集里可能有多余的属性，比如一个能唯一标识记录的属性加上多余的属性，这个属性集也能够唯一标识数据，所以这个属性集是超键）</li><li>候选键：如果超键不包含多余的属性（多余的属性是指不能唯一标识数据的属性），那么这个超键就是候选键（从超键中去除掉多余的属性，就是候选键）</li><li>主键：<strong>用户可以从候选键中选择一个作为主键</strong>（主键在一个表中只能有一个，但是候选键可以有多个）</li><li>外键：如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键</li><li>主属性：<strong>包含在任一候选键中的属性称为主属性</strong></li><li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。</li></ul><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h4 id="_1-4-第一范式-1st-nf" tabindex="-1"><a class="header-anchor" href="#_1-4-第一范式-1st-nf" aria-hidden="true">#</a> <strong>1.4</strong> <strong>第一范式(1st NF)</strong></h4><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p><p><img src="/study/assets/image-20220509220055881.0e9e232d.png" alt="image-20220509220055881"></p><h4 id="_1-5-第二范式-2nd-nf" tabindex="-1"><a class="header-anchor" href="#_1-5-第二范式-2nd-nf" aria-hidden="true">#</a> <strong>1.5</strong> <strong>第二范式(2nd NF)</strong></h4><p>第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p><blockquote><p><code>要求中的主键，其实可以拓展替换为候选键。</code></p></blockquote><p><img src="/study/assets/image-20220509220637171.6721ae17.png" alt="image-20220509220637171"></p><p>第二范式中的主键可以说成候选键，主键里可以有多个属性。</p><p>上图中，姓名和年龄没有完全依赖于主属性，只依赖于主属性的一部分---球员编号</p><p>比赛时间、比赛场地没有完全依赖于主属性，只依赖于一部分---比赛编号</p><p>得分 就是完全依赖于球员编号和比赛编号，那么就是完全依赖。</p><blockquote><p>对于非主属性来说，如果不完全依赖于主属性，会产生什么问题呢？</p><ul><li>数据冗余：如果一个球员可以参加m场比赛，那么球员的姓名和年龄就重复了m-1次，一个比赛也可以有多个球员参加，那么比赛的时间和场地就会重复多次。</li><li>插入异常：如果我们想要添加一场新的比赛，但是这时候还没有确定参加的球员都有谁，那么就没法插入。</li><li>删除异常：如果要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息也删除掉。</li><li>更新异常：如果我们调整了某个比赛的信息，那么数据表中所有这个比赛信息都要进行更新。</li></ul><p>为了避免出现上述情况，我们可以把球员比赛表设计为下面的三张表：</p><ul><li>球员表----属性：球员编号、姓名、年龄等</li><li>比赛表----属性：比赛编号、比赛时间、比赛场地等</li><li>球员比赛关系表----属性：球员编号、比赛编号、得分等</li></ul><p>这样的话，每张表都符合第二范式</p></blockquote><blockquote><p>第一范式告诉我们每一个属性是原子性的不可以再分，第二范式告诉我们每一张表就是一个独立的对象，一张表只表达一个意思。</p><p>第二范式要求实体的属性完全依赖于主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该抽取出来形成一个新的实体。</p></blockquote><h4 id="_1-6-第三范式-3rd-nf" tabindex="-1"><a class="header-anchor" href="#_1-6-第三范式-3rd-nf" aria-hidden="true">#</a> <strong>1.6</strong> <strong>第三范式(3rd NF)</strong></h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段<code>直接相关</code>，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在&quot;A--&gt;B--&gt;C&quot;的决定关系）通俗地讲，该规则的意思是<strong>所有<code>非主键属性</code>之间不能有依赖关系</strong>，必须<code>相互独立</code>。也就是说不能出现非主属性的传递依赖.</p><p>这里的主键可以理解为一个属性集，可以拓展为候选键。</p><p>非主属性就是非候选键中的属性。</p><p><img src="/study/assets/image-20220509222742980.84e98516.png" alt="image-20220509222742980"></p><h4 id="_1-7-小结" tabindex="-1"><a class="header-anchor" href="#_1-7-小结" aria-hidden="true">#</a> 1.7 小结</h4><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p>**范式的优点：**数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p>**范式的缺点：**范式的使用，可能<code>降低查询的效率</code>。<strong>因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</strong></p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><h3 id="_2-反范式化" tabindex="-1"><a class="header-anchor" href="#_2-反范式化" aria-hidden="true">#</a> <strong>2.</strong> <strong>反范式化</strong></h3><h4 id="_2-1-概述" tabindex="-1"><a class="header-anchor" href="#_2-1-概述" aria-hidden="true">#</a> <strong>2.1</strong> <strong>概述</strong></h4><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol><p><img src="/study/assets/image-20220509223609674.96b7d316.png" alt="image-20220509223609674"></p><h4 id="_2-2-反范式的新问题" tabindex="-1"><a class="header-anchor" href="#_2-2-反范式的新问题" aria-hidden="true">#</a> <strong>2.2</strong> <strong>反范式的新问题</strong></h4><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h4 id="_2-3-反范式的适用场景" tabindex="-1"><a class="header-anchor" href="#_2-3-反范式的适用场景" aria-hidden="true">#</a> <strong>2.3</strong> <strong>反范式的适用场景</strong></h4><p><strong>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</strong></p><p><strong>1.</strong> <strong>增加冗余字段的建议</strong></p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code></p><p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><h3 id="_3-bcnf-巴斯范式" tabindex="-1"><a class="header-anchor" href="#_3-bcnf-巴斯范式" aria-hidden="true">#</a> <strong>3. BCNF(巴斯范式)</strong></h3><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p><h3 id="_4-er模型" tabindex="-1"><a class="header-anchor" href="#_4-er模型" aria-hidden="true">#</a> <strong>4. ER模型</strong></h3><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p><p>我们不是为了创建ER模型而创建ER模型的</p><p>ER模型是为我们设计并创建一个优秀数据库服务的。</p><h4 id="_4-1-er-模型包括那些要素" tabindex="-1"><a class="header-anchor" href="#_4-1-er-模型包括那些要素" aria-hidden="true">#</a> 4.1 ER 模型包括那些要素？</h4><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。</p><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。可以理解为实体就是一个表。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。属性就是一个表中的属性、列、字段。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h4 id="_4-2-关系的类型" tabindex="-1"><a class="header-anchor" href="#_4-2-关系的类型" aria-hidden="true">#</a> <strong>4.2</strong> <strong>关系的类型</strong></h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code>：指实体之间的关系是一一对应的</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p><h3 id="_5-数据表的设计原则" tabindex="-1"><a class="header-anchor" href="#_5-数据表的设计原则" aria-hidden="true">#</a> <strong>5.</strong> <strong>数据表的设计原则</strong></h3><p>数据表设计的一般原则：&quot;三少一多&quot;</p><p><strong>1.</strong> <strong>数据表的个数越少越好</strong></p><p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p><p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p><p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h3 id="_6-数据库对象编写建议" tabindex="-1"><a class="header-anchor" href="#_6-数据库对象编写建议" aria-hidden="true">#</a> <strong>6.</strong> <strong>数据库对象编写建议</strong></h3><h4 id="_6-1-关于库" tabindex="-1"><a class="header-anchor" href="#_6-1-关于库" aria-hidden="true">#</a> <strong>6.1</strong> <strong>关于库</strong></h4><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>;</p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。</p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h4 id="_6-2-关于表、列" tabindex="-1"><a class="header-anchor" href="#_6-2-关于表、列" aria-hidden="true">#</a> <strong>6.2</strong> <strong>关于表、列</strong></h4><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。</p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item</p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。</p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。</p></li><li><p>【强制】建表必须有comment。</p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。</p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CREATE TABLE user_info ( 
    `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;, 
    `user_id` bigint(11) NOT NULL COMMENT &#39;用户id&#39;, 
    `username` varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;, 
    `email` varchar(30) NOT NULL COMMENT &#39;用户邮箱&#39;, 
    `nickname` varchar(45) NOT NULL COMMENT &#39;昵称&#39;, 
    `birthday` date NOT NULL COMMENT &#39;生日&#39;, 
    `sex` tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;, 
    `short_introduce` varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;, 
    `user_resume` varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;, 
    `user_register_ip` int NOT NULL COMMENT &#39;用户注册时的源ip&#39;, 
    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;, 
    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;, 
    `user_review_status` tinyint NOT NULL COMMENT &#39;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#39;,
    PRIMARY KEY (`id`), 
    UNIQUE KEY `uniq_user_id` (`user_id`), 
    KEY `idx_username`(`username`), 
    KEY `idx_create_time_status`(`create_time`,`user_review_status`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;网站用户基本信息&#39;
</code></pre></div><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h4 id="_6-3-关于索引" tabindex="-1"><a class="header-anchor" href="#_6-3-关于索引" aria-hidden="true">#</a> <strong>6.3</strong> <strong>关于索引</strong></h4><ol><li><p>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值<code>禁止被更新</code>。</p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。</p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。</p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h4 id="_6-4-sql编写" tabindex="-1"><a class="header-anchor" href="#_6-4-sql编写" aria-hidden="true">#</a> <strong>6.4 SQL编写</strong></h4><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol><h2 id="第12章-数据库其它调优策略" tabindex="-1"><a class="header-anchor" href="#第12章-数据库其它调优策略" aria-hidden="true">#</a> 第12章 数据库其它调优策略</h2><h3 id="_1-数据库调优的措施" tabindex="-1"><a class="header-anchor" href="#_1-数据库调优的措施" aria-hidden="true">#</a> <strong>1.</strong> <strong>数据库调优的措施</strong></h3><h4 id="_1-1-调优的目标" tabindex="-1"><a class="header-anchor" href="#_1-1-调优的目标" aria-hidden="true">#</a> <strong>1.1</strong> <strong>调优的目标</strong></h4><ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h4 id="_1-2-如何定位调优问题" tabindex="-1"><a class="header-anchor" href="#_1-2-如何定位调优问题" aria-hidden="true">#</a> <strong>1.2</strong> <strong>如何定位调优问题</strong></h4><ul><li><strong>用户的反馈（主要）</strong></li><li><strong>日志分析（主要）</strong></li><li><strong>服务器资源使用监控</strong></li><li><strong>数据库内部状况监控</strong></li><li><strong>其它</strong></li></ul><h4 id="_1-3-调优的维度和步骤" tabindex="-1"><a class="header-anchor" href="#_1-3-调优的维度和步骤" aria-hidden="true">#</a> <strong>1.3</strong> <strong>调优的维度和步骤</strong></h4><p><strong>第1步：选择适合的</strong> <strong>DBMS</strong></p><p><strong>第2步：优化表设计</strong></p><p><strong>第3步：优化逻辑查询</strong></p><p><strong>第4步：优化物理查询</strong></p><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引和表连接等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p><p>在这个部分中，我们需要掌握的重点是对索引的创建和使用。</p><p><strong>第5步：使用</strong> <strong>Redis</strong> <strong>或</strong> <strong>Memcached</strong> <strong>作为缓存</strong></p><p><strong>第6步：库级优化</strong></p><p><strong>1、读写分离</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031025279.png" alt="image-20220403102536170"></p><p><strong>2、数据分片</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031026743.png" alt="image-20220403102618627"></p><h3 id="_2-优化mysql服务器" tabindex="-1"><a class="header-anchor" href="#_2-优化mysql服务器" aria-hidden="true">#</a> <strong>2.</strong> <strong>优化MySQL服务器</strong></h3><h4 id="_2-1-优化服务器硬件" tabindex="-1"><a class="header-anchor" href="#_2-1-优化服务器硬件" aria-hidden="true">#</a> <strong>2.1</strong> <strong>优化服务器硬件</strong></h4><p>**服务器的硬件性能直接决定着MySQL数据库的性能。**硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。</p><p>（1）<code>配置较大的内存</code></p><p>（2）<code>配置高速磁盘系统</code></p><p>（3）<code>合理分布磁盘I/O</code></p><p>（4）<code>配置多处理器</code></p><h4 id="_2-2-优化mysql的参数" tabindex="-1"><a class="header-anchor" href="#_2-2-优化mysql的参数" aria-hidden="true">#</a> <strong>2.2</strong> <strong>优化MySQL的参数</strong></h4><ul><li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li><li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li><li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。 <ul><li>当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。</li><li>当query_cache_type=2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</li><li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参数的值。默认为64K，可以设置为4M。</li><li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。 <ul><li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li><li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul></li><li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li><li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。</li><li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li></ul><h3 id="_3-优化数据库结构" tabindex="-1"><a class="header-anchor" href="#_3-优化数据库结构" aria-hidden="true">#</a> <strong>3.</strong> <strong>优化数据库结构</strong></h3><h4 id="_3-1-拆分表-冷热数据分离" tabindex="-1"><a class="header-anchor" href="#_3-1-拆分表-冷热数据分离" aria-hidden="true">#</a> <strong>3.1</strong> <strong>拆分表：冷热数据分离</strong></h4><p>拆分表的思路是，把一个包含很多字段的表拆分成2个或者多个相对较小的表，这样做的原因是，这些表中某些字段的操作频率很高（热数据），经常要进行查询或者更新操作，而另外一些字段的使用频率很低（冷数据），冷热数据分离，可以减小表的宽度。如果放在一个表里面，又根据聚簇索引即主键索引，叶子节点会存放用户的完整数据记录，那么每次查询都要读取大记录，会消耗较多的资源。</p><p>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。表越宽，把表装载进内存缓冲池时所占用的内存越大，也会消耗更多的IO。</p><p>冷热数据分离的目的是：</p><ul><li>减少磁盘IO，保证热数据的内存缓存命中率</li><li>更有效地利用缓存，避免读入无用的冷数据。</li></ul><p><img src="/study/assets/image-20220510011844211.a5b1fb3c.png" alt="image-20220510011844211"></p><h4 id="_3-2-增加中间表" tabindex="-1"><a class="header-anchor" href="#_3-2-增加中间表" aria-hidden="true">#</a> <strong>3.2</strong> <strong>增加中间表</strong></h4><p>对于需要经常进行联合查询的表，可以建立中间表以提高查询效率，通过建立中间表，把需要经常联合查询的数据插入到中间表中，<strong>然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</strong></p><h4 id="_3-3-增加冗余字段" tabindex="-1"><a class="header-anchor" href="#_3-3-增加冗余字段" aria-hidden="true">#</a> <strong>3.3</strong> <strong>增加冗余字段</strong></h4><p>反范式化的设计。</p><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。但是，合理地加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表与表之间的关系也越多，需要连接查询的情况就越多，这是由于每个表都表示一个意思，没有冗余字段，在设计上看起来更合理，在有些查询上，就需要用到多个表连接查询。为了提升效率，我们可以考虑增加冗余字段来减少连接。</p><h4 id="_3-4-优化数据类型" tabindex="-1"><a class="header-anchor" href="#_3-4-优化数据类型" aria-hidden="true">#</a> <strong>3.4</strong> <strong>优化数据类型</strong></h4><p>改进表的设计时，可以考虑字段的数据类型，这个问题在大家刚从事开发时基本不算问题，但是，随着参与的项目越来越大，数据量也越来越多的时候，就不能只从系统稳定性的角度来思考问题了，还要考虑到系统整体的稳定性和效率，此时，优先选择符合存储需要的最小的数据类型。</p><p>这个最小指的是存储数据占用的空间最小，范围最小，但是要满足业务需求。</p><p>列的字段越大，建立索引时所需要的空间也就越大（聚簇索引会默认创建，数据和索引是一起的），这样一个数据页中所能存储的索引节点的数量就越少，在遍历时，所需要的IO次数就越多，索引的性能就越差。</p><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，**INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。**刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</strong>。</p><p>跟文本类型数据相比，大整数（BIGINT）往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><p>MySQL内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。</p><p>如果一定要使用这类型数据，建议把BLOB或是TEXT列分离到单独的扩展表中。</p><p><strong>情况4：避免使用ENUM类型</strong></p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优</strong>。</p><h4 id="_3-5-优化插入记录的速度" tabindex="-1"><a class="header-anchor" href="#_3-5-优化插入记录的速度" aria-hidden="true">#</a> <strong>3.5</strong> <strong>优化插入记录的速度</strong></h4><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><p><strong>② 禁用唯一性检查</strong></p><p><strong>③ 使用批量插入</strong></p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p><strong>2. InnoDB引擎的表：</strong></p><p><strong>① 禁用唯一性检查</strong></p><p><strong>② 禁用外键检查</strong></p><p><strong>③ 禁止自动提交</strong></p><h4 id="_3-6-使用非空约束" tabindex="-1"><a class="header-anchor" href="#_3-6-使用非空约束" aria-hidden="true">#</a> <strong>3.6</strong> <strong>使用非空约束</strong></h4><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong></p><p>这样做的好处是：</p><ul><li>进行比较和计算时，省去对NULL值的判断是否为空的开销，提高存储效率。</li><li>非空字段也容易创建索引，因为索引NULL列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间。</li></ul><h4 id="_3-7-分析表、检查表与优化表" tabindex="-1"><a class="header-anchor" href="#_3-7-分析表、检查表与优化表" aria-hidden="true">#</a> <strong>3.7</strong> <strong>分析表、检查表与优化表</strong></h4><p><strong>1.</strong> <strong>分析表</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…
</code></pre></div><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，**以便在主从架构中，从服务能够同步数据。**可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</strong></p><p><strong>2.</strong> <strong>检查表</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
</code></pre></div><p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p><p><strong>3.</strong> <strong>优化表</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
</code></pre></div><p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。</p><p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p><h3 id="_4-大表优化" tabindex="-1"><a class="header-anchor" href="#_4-大表优化" aria-hidden="true">#</a> 4.大表优化</h3><h4 id="_4-1-限定查询的范围" tabindex="-1"><a class="header-anchor" href="#_4-1-限定查询的范围" aria-hidden="true">#</a> 4.1 限定查询的范围</h4><p>禁止不带任何限制数据范围条件的查询语句。</p><h4 id="_4-2-读写分离" tabindex="-1"><a class="header-anchor" href="#_4-2-读写分离" aria-hidden="true">#</a> 4.2 读写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><ul><li><p>一主一从模式</p><p><img src="/study/assets/image-20220510184237766.a6b5d13a.png" alt="image-20220510184237766"></p></li><li><p>双主双从模式</p><p><img src="/study/assets/image-20220510184313614.91983300.png" alt="image-20220510184313614"></p></li></ul><h4 id="_4-3-垂直拆分" tabindex="-1"><a class="header-anchor" href="#_4-3-垂直拆分" aria-hidden="true">#</a> 4.3 垂直拆分</h4><p>当数据量达到千万级以上的时候，有时候我们需要把**一个数据库切成多份（一个数据库里就是多张数据表，相当于把多张数据表进行分组，放到不同的数据库服务器上），放到不同的数据库服务器上。**减少对单一服务器的访问压力。</p><p><img src="/study/assets/image-20220510184704055.11e0de7d.png" alt="image-20220510184704055"></p><ul><li><p>如果数据库中的数据表过多，可以采用<code>垂直分库</code>的方式，<strong>将关联的数据表部署在同一个数据库服务器上。</strong></p></li><li><p>如果数据表中的<code>列</code>过多，可以采用<code>垂直分表</code>的方式，将一张数据表拆分成多张数据表，把经常一起使用的列放到同一张表里。</p><p><img src="/study/assets/image-20220510184941761.37f9f278.png" alt="image-20220510184941761"></p></li></ul><p>垂直拆分的优点：</p><p>可以使得列数据变小，在查询时减少读取的Block数，减少IO次数，此外，垂直拆分可以简化表的结构，易于维护。</p><p>缺点：</p><p>主键会出现冗余，因为分表操作。需要管理冗余列，并会引起join操作。此外，垂直拆分会使得事务更加复杂。</p><h4 id="_4-4-水平拆分" tabindex="-1"><a class="header-anchor" href="#_4-4-水平拆分" aria-hidden="true">#</a> 4.4 水平拆分</h4><p><img src="/study/assets/image-20220510185252533.5971615f.png" alt="image-20220510185252533"></p><p>水平拆分和垂直拆分的不同是：水平拆分的每张小表都保持相同的表结构，而垂直拆分并不是将拆分的表保持相同的表结构。</p><h2 id="第13章-事务基础知识" tabindex="-1"><a class="header-anchor" href="#第13章-事务基础知识" aria-hidden="true">#</a> 第13章 事务基础知识</h2><h3 id="_1-数据库事务概述" tabindex="-1"><a class="header-anchor" href="#_1-数据库事务概述" aria-hidden="true">#</a> <strong>1.</strong> <strong>数据库事务概述</strong></h3><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p><p>MySQL存储引擎中，只有InnoDB是支持事务的。</p><h4 id="_1-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-1-基本概念" aria-hidden="true">#</a> <strong>1.1</strong> <strong>基本概念</strong></h4><p>**事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p>**事务处理的原则：**保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，<strong>整个事务</strong>回滚(<code>rollback</code>)到最初状态。</p><h4 id="_1-2-事务的acid特性" tabindex="-1"><a class="header-anchor" href="#_1-2-事务的acid特性" aria-hidden="true">#</a> <strong>1.2</strong> <strong>事务的ACID特性</strong></h4><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个<strong>不可分割的工作单位</strong>，**要么全部提交，要么全部失败回滚。**事务一定是作为一个整体出现。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢？满足预定的约束的状态就叫做合法的状态。通俗一点，这状态是由我们自己定义的（比如满足现实世界中的约束），满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的。如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p><p><img src="/study/assets/image-20220510190929111.ea3c246c.png" alt="image-20220510190929111"></p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p><img src="/study/assets/image-20220510191837001.201fb832.png" alt="image-20220510191837001"></p><p>这个例子就是没有遵守事务的隔离性。</p><ul><li><strong>持久性（durability）：</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code>，接下来的其他操作和数据库故障不应该对其有任何影响。**持久性是指数据会回写到磁盘中，永久保存下来。**上面图片中，隔离性的例子，就是因为B的值没有回写到磁盘，就有另一个事务也来操作这个数据，就导致结果不对，实际上应该一个事务要对其他并发访问这个数据表的事务隔离，所以当前事务应该是到中止状态或者说提交状态，即数据已经持久化之后，另外的事务才能来操作这个表。</p><p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志（REDO）</code>和<code>回滚日志（UNDO）</code>。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><blockquote><p>总结：</p><p>ACID是事务的四大特性，原子性是基础，隔离性是手段，一致性是约束，持久性是目的。</p></blockquote><h4 id="_1-3-事务的状态" tabindex="-1"><a class="header-anchor" href="#_1-3-事务的状态" aria-hidden="true">#</a> <strong>1.3</strong> <strong>事务的状态</strong></h4><ul><li><strong>活动的（active）</strong></li></ul><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p><ul><li><strong>部分提交的（partially committed）</strong></li></ul><p>当事务中的最后一个操作执行完成（<code>还没有提交</code>），但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p><ul><li><strong>失败的（failed）</strong></li></ul><p>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p><ul><li><strong>中止的（aborted）</strong></li></ul><p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到<strong>事务执行前的状态</strong>。换句话说，就是要撤销失败事务（事务是一系列操作）对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p><ul><li><strong>提交的（committed）</strong></li></ul><p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。数据变成持久状态。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031104063.png" alt="image-20220403110448951"></p><p>图中可见，<code>只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。</code>对于已经提交的事务来说，该事务对数据库所做的修改将永久生效。对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p><h3 id="_2-如何使用事务" tabindex="-1"><a class="header-anchor" href="#_2-如何使用事务" aria-hidden="true">#</a> <strong>2.</strong> <strong>如何使用事务</strong></h3><p>使用事务有两种方式</p><ul><li>显示事务</li><li>隐式事务</li></ul><p>事务的完成过程</p><ul><li>开启事务</li><li>一系列DML操作</li><li>...</li><li>事务结束状态：提交状态（COMMIT）、中止状态（ROLLBACK）</li></ul><h4 id="_2-1-显式事务" tabindex="-1"><a class="header-anchor" href="#_2-1-显式事务" aria-hidden="true">#</a> <strong>2.1</strong> <strong>显式事务</strong></h4><p><strong>步骤1：</strong> <code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; BEGIN; 
#或者 
mysql&gt; START TRANSACTION;
</code></pre></div><p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边可以跟随几个<code>修饰符</code>：</p><p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>②<code>READ WRITE</code>（这是默认的）：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p><p><img src="/study/assets/image-20220510193537606.f5a39192.png" alt="image-20220510193537606"></p><p>**步骤2：**一系列事务中的操作（主要是DML，不含DDL）</p><p>**步骤3：**提交事务 或 中止事务（即回滚事务）</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 提交事务。当提交事务后，对数据库的修改是永久性的。
mysql&gt; COMMIT;
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 回滚事务。即撤销正在进行的所有没有提交的修改 
mysql&gt; ROLLBACK; 

# 将事务回滚到某个保存点。 
mysql&gt; ROLLBACK TO [SAVEPOINT]
#要注意将事务回滚到保存点，不是事务最终的状态，事务也不是中止状态，回滚到保存点之后，还要考虑之后的操作，并且最后还要ROLLBACK，还是COMMIT。
</code></pre></div><p>其中关于SAVEPOINT相关操作有：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。
SAVEPOINT 保存点名称;
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 删除某个保存点
RELEASE SAVEPOINT 保存点名称;
</code></pre></div><h4 id="_2-2-隐式事务" tabindex="-1"><a class="header-anchor" href="#_2-2-隐式事务" aria-hidden="true">#</a> <strong>2.2</strong> <strong>隐式事务</strong></h4><ul><li><p>显式地使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。<strong>这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</strong></p></li><li><p>把系统变量<code>autocommit</code>的值设置为<code>OFF</code></p><p>在autocommit的值是ON的情况下，**每一个DML操作都是一个独立的事务。**这就是隐式事务</p></li></ul><h4 id="_2-3-隐式提交数据的情况" tabindex="-1"><a class="header-anchor" href="#_2-3-隐式提交数据的情况" aria-hidden="true">#</a> <strong>2.3</strong> <strong>隐式提交数据的情况</strong></h4><ul><li><p>DDL操作会自动提交数据，不受autocommit影响</p><p>默认情况下DML操作会自动提交数据，默认情况就是autocommit为true</p></li><li><p><strong>数据定义语言（Data definition language，缩写为：DDL）</strong></p><p>当我们使用create、drop、alter等语句去修改数据库对象时，就会隐式地提交前边语句所属的事务。</p></li><li><p><strong>隐式使用或修改mysql数据库中的表</strong></p><p><img src="/study/assets/image-20220510194504708.3911bb1b.png" alt="image-20220510194504708"></p></li><li><p><strong>事务控制或关于锁定的语句</strong></p><ul><li><p>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上一个事务。</p><p><img src="/study/assets/image-20220510194539697.593d800f.png" alt="image-20220510194539697"></p></li><li><p>当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会<code>隐式的提交</code>前边语句所属的事务。</p></li><li><p>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<code>隐式的提交</code>前边语句所属的事务。</p></li></ul></li></ul><h4 id="_2-4-小结-1" tabindex="-1"><a class="header-anchor" href="#_2-4-小结-1" aria-hidden="true">#</a> 2.4 小结</h4><ul><li><p>当我们设置autocommit=0时，不论是否采用start transaction或者begin的方式开启事务，都需要用commit进行提交，让事务生效，使用rollback对事务进行回滚。</p></li><li><p>当我们设置autocommit=1时，每条SQL语句都会自动进行提交。</p><p>不过这时，如果采用start transaction或者begin的方式开启事务，那么这个事务只有在commit的时候才会生效，在rollback时才会回滚。</p></li></ul><h3 id="_3-事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-事务隔离级别" aria-hidden="true">#</a> <strong>3.</strong> <strong>事务隔离级别</strong></h3><p>MySQL是一个客户端/服务端架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（session），每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说，可能同时处理多个事务。</p><p>事务有隔离性，理论上在某个事务对某个数据进行访问的时候，其他事务应该进行排队。当该事务提交之后，其他事务才可以继续访问这个数据。<code>但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，那就看二者如何权衡取舍了。</code></p><h4 id="_3-1-数据并发问题" tabindex="-1"><a class="header-anchor" href="#_3-1-数据并发问题" aria-hidden="true">#</a> <strong>3.1</strong> <strong>数据并发问题</strong></h4><p><strong>可能会出现的问题</strong></p><p><strong>1.</strong> <strong>脏写（</strong><code>Dirty Write</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code></p><p>未提交事务Session B修改数据，但是未提交，这个时候我们select是能看到数据的，因为这个数据才内存中，我们做了修改，但是没提交，意味着事务没有进入生命周期的最终状态，即中止状态或提交状态，这里就是没有进入提交状态，也就是B修改的数据没有回写到磁盘中，那么这个时候事务A来修改这个数据的话，仍然是能够修改的。这就是脏写。</p><p>所以要明确，一个事务对数据做了修改，但是没有提交，不意味着我们select看不到这个数据！这个数据是存在的，只不过没有回写到磁盘，没有持久化，持久化才是目的！！那么没有持久化，而数据存在于内存中时，其他事务来操作，那么就出现了问题。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124086.png" alt="image-20220403112416944"></p><p>Session A和Session B各开启了一个事务，事务B先将studentno列为1的记录的name列更新为&#39;李四&#39;，然后事务A接着又把这条数据的name列修改为‘张三’，如果之后session B中的事务进行了回滚（那么说明事务进行了生命周期的最终状态---中止状态，刷盘了，即数据从内存回写到磁盘了，持久化了），那么session A中的更新也就不复存在，这种现象就是脏写。</p><p>这时session A中的事务就没有效果了，明明把数据更新了，也提交了，但是看不到效果。这里大家对事务的隔离级别比较了解的话，会发现默认隔离级别下，上面session A中的事务对数据的更新语句会处于等待状态。</p><p><strong>2.</strong> <strong>脏读（</strong><code>Dirty Read</code><strong>）</strong></p><p>对于两个事务 Session A、Session B，Session A<code>读取</code>了已经被 Session B<code>更新</code>但还<code>没有被提交</code>的字段（这里再次强调，是能读到的，只不过session B没有进行提交，数据没有进行持久化，没有回写到磁盘）。之后若 Session B<code>回滚</code>（那么事务进入到中止状态），Session A<code>读取</code>的内容就是<code>临时且无效</code>的。</p><p>事务的提交状态和中止状态才是事务生命周期的最终状态。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124136.png" alt="image-20220403112435995"></p><p><img src="/study/assets/image-20220510223605049.b62c8336.png" alt="image-20220510223605049"></p><p>事务A读到了这个表的临时数据！！这就是脏读，因为这是临时数据，是脏数据！</p><p><strong>脏读是事务A读取到其他事务没有提交的临时数据。</strong></p><p>不可重复读，是事务A正常读取数据，只不过这个数据被别的事务修改了，再次读就不同了，所以是不可重复读。</p><p><strong>3.</strong> <strong>不可重复读（</strong><code>Non-Repeatable Read</code><strong>）</strong></p><p>对于两个事务Session A、Session B，Session A<code>读取</code>了一个字段，然后 Session B<code>更新</code>了该字段。 之后Session A<code>再次读取</code>同一个字段，<code>值就不同</code>了。那就意味着发生了不可重复读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031124331.png" alt="image-20220403112458183"></p><p><strong>4.</strong> <strong>幻读（</strong><code>Phantom</code><strong>）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中<code>读取</code>了一个字段, 然后 Session B 在该表中<code>插入</code>了一些新的行。 之后, 如果 Session A<code>再次读取</code>同一个表, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031125847.png" alt="image-20220403112514712"></p><p><strong>注意1：</strong></p><p>有的同学会有疑问，那如果Session B中<code>剔除了</code>一些符合<code>studentno &gt; 0</code>的记录而不是插入新记录，那么Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算<code>幻读</code>呢？这种现象<code>不属于幻读</code>，<strong>幻读强调的是一个事物按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</strong></p><p><strong>注意2：</strong></p><p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到之前读取没有获取到的记录。</p><h4 id="_3-2-sql中的四种隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-2-sql中的四种隔离级别" aria-hidden="true">#</a> <strong>3.2 SQL中的四种隔离级别</strong></h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们没有必要解决全部的问题，有一些问题是可以接受的，比如不可重复读和幻读，因为事务A读了一些数据，事务B增加了一些数据，或者修改了事务A之前查询的数据，事务A中的操作语句再次查询时，发现数据不一样了，这个在某些场景下会被认为是正常的情况，但是幻读和不可重复读仍然是并发事务的问题！！</p><p>不可能解决所有并发问题，如果全部解决，那么隔离级别会被设置得很高，这会导致数据库性能很差！！一般不会这样做。</p><p>问题严重性排序</p><div class="language-text ext-text"><pre class="language-text"><code>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读 
</code></pre></div><p>我们愿意舍弃一部分隔离性来换取一部分性能，这里就体现在设立一些隔离级别，隔离级别越低，那么并发问题越多。</p><p>要在并发问题和数据库性能上达到一个平衡。</p><p><code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p><ul><li><p><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。<strong>不能避免脏读、不可重复读、幻读。</strong></p></li><li><p><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：**一个事务只能看见已经提交事务所做的改变。**这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p><p>不可重复读的意思是说只要事务B修改数据并提交之后，那么这个数据不是脏数据，能被事务A读到。</p><p>脏读是指事务A读到了事务B没有提交的临时数据或者说脏数据。</p></li><li><p><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并<code>提交</code>，那么事务A再读该数据，读到的还是原来的内容<code>(如果是读已提交隔离级别，那么事务B对数据进行了修改，然后提交，说明数据不是临时数据，那么就会被事务A读到，那么事务A在当前事务中就读到了不同的数据，这是不可重复读的问题，不是脏读，因为读到的数据是已提交的数据，是持久化的数据，所以不是脏读，但是两次读到的数据仍然不一样，是因为没有解决不可重复读的问题)</code>。可以避免脏读、不可重复读，但幻读问题仍然存在。<code>这是MySQL的默认隔离级别</code>。</p></li><li><p><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。<strong>所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</strong></p></li></ul><p>可重复读这个隔离级别也是可以解决幻读的，但是需要我们手动对select操作加行锁也就是独占锁----这也正是可串行化隔离级别MySQL会为我们隐式做的事情。在可重复读这个隔离级别，我们手动做，手动添加行锁（独占锁）来解决幻读。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031127542.png" alt="image-20220403112740425"></p><p>脏写这个问题太严重了，不论哪种隔离级别，都解决了脏写。</p><p><img src="/study/assets/image-20220510225155107.b9e126b9.png" alt="image-20220510225155107"></p><h4 id="_3-3-如何设置事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-3-如何设置事务的隔离级别" aria-hidden="true">#</a> <strong>3.3</strong> <strong>如何设置事务的隔离级别</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; 
#其中，隔离级别格式： 
&gt; READ UNCOMMITTED 
&gt; READ COMMITTED 
&gt; REPEATABLE READ 
&gt; SERIALIZABLE
</code></pre></div><p>或者：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#39;隔离级别&#39; 
#其中，隔离级别格式： 
&gt; READ-UNCOMMITTED 
&gt; READ-COMMITTED 
&gt; REPEATABLE-READ 
&gt; SERIALIZABLE
</code></pre></div><h2 id="第14章-mysql事务日志" tabindex="-1"><a class="header-anchor" href="#第14章-mysql事务日志" aria-hidden="true">#</a> 第14章 MySQL事务日志</h2><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。 <ul><li>REDO LOG 称为<code>重做日志</code>，<strong>提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</strong></li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><blockquote><p>REDO和UNDO都可以视为是一种恢复操作，但是：</p><ul><li><p>REDO: 是存储引擎层（InnoDB）生成的日志，记录的是“物理级别”上的页修改操作，比如页号xxx，偏移量yyy写入了zzz数据，主要是为了保证数据的可靠性。</p></li><li><p>UNDO：是存储引擎层（InnoDB）生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT操作，那么undo log就记录一条与之相反的delete操作，主要用于事务的回滚和一致性非锁定读。</p><p>undo log记录的是每个修改操作的逆操作。</p></li></ul></blockquote><h3 id="_1-redo日志" tabindex="-1"><a class="header-anchor" href="#_1-redo日志" aria-hidden="true">#</a> <strong>1. redo日志</strong></h3><p>InnoDB存储引擎是以页为单位来管理存储空间的，在真正访问页面之间，需要把磁盘上的页缓存到内存中的缓冲区之后才可以访问。</p><p>所有的变更都必须先更新到缓冲池中的数据，然后缓冲池中的脏页（也就是没有回写到磁盘中的数据页）会以一定的频率被刷入磁盘（checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样可以保证整体的性能。</p><h4 id="_1-1-为什么需要redo日志" tabindex="-1"><a class="header-anchor" href="#_1-1-为什么需要redo日志" aria-hidden="true">#</a> <strong>1.1</strong> <strong>为什么需要REDO日志</strong></h4><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务<code>提交后</code>即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p><p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来（那么就需要记录）。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。这就是REDO日志。</p><p>InnoDB引擎的事务采用了WAL（Write-Ahead Logging），这种技术的思想就是先写日志，再写磁盘，<code>只有日志写入成功，才算事务提交成功</code>，这里的日志就是redo log。当发生宕机且数据未刷新到磁盘时，数据库服务重启后可以通过redo log来恢复，保证了ACID中的D，这就是redo log的作用。</p><h4 id="_1-2-redo日志的好处、特点" tabindex="-1"><a class="header-anchor" href="#_1-2-redo日志的好处、特点" aria-hidden="true">#</a> <strong>1.2 REDO日志的好处、特点</strong></h4><p><strong>1.</strong> <strong>好处</strong></p><ul><li><strong>redo日志降低了刷盘频率</strong></li><li><strong>redo日志占用的空间非常小</strong></li></ul><p><strong>2.</strong> <strong>特点</strong></p><ul><li><strong>redo日志是顺序写入磁盘的</strong></li><li><strong>事务执行过程中，redo log不断记录</strong></li></ul><h4 id="_1-3-redo的组成" tabindex="-1"><a class="header-anchor" href="#_1-3-redo的组成" aria-hidden="true">#</a> <strong>1.3 redo的组成</strong></h4><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li></ul><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。</p><ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul><h4 id="_1-4-redo的整体流程" tabindex="-1"><a class="header-anchor" href="#_1-4-redo的整体流程" aria-hidden="true">#</a> <strong>1.4 redo的整体流程</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031147714.png" alt="image-20220403114709581"></p><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</p><p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</p><p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</p><p>第4步：<code>定期</code>将内存中修改的数据刷新到磁盘中</p><blockquote><p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h4 id="_1-5-redo-log的刷盘策略" tabindex="-1"><a class="header-anchor" href="#_1-5-redo-log的刷盘策略" aria-hidden="true">#</a> <strong>1.5 redo log的刷盘策略</strong></h4><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一定的频率刷入到真正的redo log file中。这里的一定的频率怎么看待呢？就是所说的刷盘策略。</p><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统<code>默认</code>master thread每隔1s进行一次重做日志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>）</li><li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。<strong>由os自己决定什么时候同步到磁盘文件。</strong></li></ul><h4 id="_1-6-不同刷盘策略演示" tabindex="-1"><a class="header-anchor" href="#_1-6-不同刷盘策略演示" aria-hidden="true">#</a> <strong>1.6</strong> <strong>不同刷盘策略演示</strong></h4><p><strong>1.</strong> <strong>流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152952.png" alt="image-20220403115232833"></p><blockquote><p>小结：Innodb_flush_log_at_trx_commit=1</p><p>只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152607.png" alt="image-20220403115249492"></p><p><img src="/study/assets/image-20220511172652113.3fb1c363.png" alt="image-20220511172652113"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031153931.png" alt="image-20220403115300809"></p><blockquote><p>虽然用户可以通过设置Innodb_flush_log_at_trx_commit的值为0或2，来提高事务提交的性能，但需清楚，这种设置方法丧失了事务的ACID特性。</p></blockquote><h4 id="_1-7-写入redo-log-buffer过程" tabindex="-1"><a class="header-anchor" href="#_1-7-写入redo-log-buffer过程" aria-hidden="true">#</a> <strong>1.7</strong> <strong>写入redo log buffer过程</strong></h4><p><strong>1.</strong> <strong>补充概念：Mini-Transaction</strong></p><p>MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条（一组）redo日志</p><p>在进行崩溃恢复的时候，这一组redo日志作为一个不可分割的整体。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040912119.png" alt="image-20220404091224993"></p><p><strong>2. redo</strong> <strong>日志写入log buffer</strong></p><p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个问题就是应该写在哪个block的哪个偏移量处（一个block的大小是512个字节），所以InnoDB的设计者特意提供了一个称之为buf_free的全局变量，该变量指明后续写入的redo日志应该写到log buffer中的哪个位置。</p><p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到redo log buffer中，也就是说不同事务的mtr的redo log可能是交替写入log buffer的。</p><p><strong>一个mtr内部的redo log那一定是挨着的</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040915708.png" alt="image-20220404091511602"></p><p>一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就写入log buffer，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。</p><h4 id="_1-8-redo-log-file" tabindex="-1"><a class="header-anchor" href="#_1-8-redo-log-file" aria-hidden="true">#</a> <strong>1.8 redo log file</strong></h4><p><strong>1.</strong> <strong>相关参数设置</strong></p><ul><li><p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1... ib_logfilen。默认2个，最大100个。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。</p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p></li></ul><p><strong>2.</strong> <strong>日志文件组</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040920532.png" alt="image-20220404092038421"></p><p><strong>3. checkpoint</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040921715.png" alt="image-20220404092106617"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><h3 id="_2-undo日志" tabindex="-1"><a class="header-anchor" href="#_2-undo日志" aria-hidden="true">#</a> <strong>2. Undo日志</strong></h3><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p><h4 id="_2-1-如何理解undo日志" tabindex="-1"><a class="header-anchor" href="#_2-1-如何理解undo日志" aria-hidden="true">#</a> <strong>2.1</strong> <strong>如何理解Undo日志</strong></h4><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><p>整个事务的数据要作为一个整体！！！</p><p><img src="/study/assets/image-20220511184826408.dd1764ed.png" alt="image-20220511184826408"></p><p>此外，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h4 id="_2-2-undo日志的作用" tabindex="-1"><a class="header-anchor" href="#_2-2-undo日志的作用" aria-hidden="true">#</a> <strong>2.2 Undo日志的作用</strong></h4><ul><li><p><strong>作用1：回滚数据</strong></p><p>用户对undo日志可能有误解：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此，undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子，<strong>所有修改逻辑都被取消掉了</strong>，但是数据结构和页本身在回滚之后可能大不相同。</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务，数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中的某几条记录，同时还有一个别的事务在对同一个页中的另几条记录做修改。因此，不能将一个页回滚到事务开始之前的样子，因为这样会影响其他事务正在进行的工作。所以undo日志是逻辑日志，会将增删改这三种修改操作逆向地执行回去，不会影响其他事务对本数据库的修改，只是当前事务的所有操作回滚回去。</p></li><li><p><strong>作用2：MVCC（详情看第16章）</strong></p><p>undo的另一个作用是mvcc，即在InnoDB存储引擎中MVCC的实现是通过undo来完成，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p></li></ul><h4 id="_2-3-undo的存储结构" tabindex="-1"><a class="header-anchor" href="#_2-3-undo的存储结构" aria-hidden="true">#</a> <strong>2.3 undo的存储结构</strong></h4><p><strong>1.</strong> <strong>回滚段与undo页</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><p><strong>2.</strong> <strong>回滚段与事务</strong></p><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p><strong>当事务提交时，InnoDB存储引擎会做以下两件事情：</strong></p><ul><li><strong>将undo log放入列表中，以供之后的purge操作</strong></li><li><strong>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</strong></li></ul></li></ol><p><strong>3.</strong> <strong>回滚段中的数据分类</strong></p><ol><li><p>未提交的回滚数据(uncommitted undo information)</p><p>该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</p></li><li><p>已经提交但未过期的回滚数据(committed undo information)</p><p>该数据关联的事务已经提交，但仍受到undo retention参数的保持时间的影响。</p></li><li><p>事务已经提交并过期的数据(expired undo information)</p><p>事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖“事务已经提交并过期的数据”。</p></li></ol><p>事务提交后并不能马上删除undo log及undo log所在的页，这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本，故事务提交时将undo log放入一个链表中，是否可以最终删除undo log及undo log所在的页由purge线程来决定。</p><h4 id="_2-4-undo的类型" tabindex="-1"><a class="header-anchor" href="#_2-4-undo的类型" aria-hidden="true">#</a> <strong>2.4 undo的类型</strong></h4><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><p>insert undo log</p><p>insert undo log是指在insert操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p></li><li><p>update undo log</p><p>update undo log记录的是对delete 和 update操作产生的逻辑上的undo log，该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入undo log链表，等待purge线程（清除线程）进行最后的删除。</p></li></ul><h4 id="_2-5-undo-log的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-5-undo-log的生命周期" aria-hidden="true">#</a> <strong>2.5 undo log的生命周期</strong></h4><p><img src="/study/assets/image-20220512155401343.facd798a.png" alt="image-20220512155401343"></p><p><strong>1.</strong> <strong>简要生成过程</strong></p><p><strong>只有Buffer Pool的流程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040937761.png" alt="image-20220404093706650"></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040938657.png" alt="image-20220404093832512"></p><p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务之前的状态写入undo log中，假设更新到一半出错了，我们就可以通过Undo Log回滚到事务之前。</p><p>并不是说事务提交之后，回滚段中的undo log segment中的undo log 及undo log数据页就会删除，要放入链表中，最终等待purge线程来删除。</p><p>insert的undo log在事务提交之后可以立即删除。</p><p>5到6步之间，有一个page cache，这是现代操作系统改善效率提供的机制，redo log buffer刷盘到redo log持久化文件的这个过程会有一个策略。</p><p>Binlog是实现主从复制的，实现主机和从机之间的数据同步。</p><p><strong>2.</strong> <strong>详细生成过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040939231.png" alt="image-20220404093950136"></p><p><strong>当我们执行INSERT时：</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>begin; 
INSERT INTO user (name) VALUES (&quot;tom&quot;);
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040940543.png" alt="image-20220404094033441"></p><p><strong>当我们执行UPDATE时：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941624.png" alt="image-20220404094105525"></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>UPDATE user SET id=2 WHERE id=1;
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941449.png" alt="image-20220404094142337"></p><p><strong>3. undo log是如何回滚的</strong></p><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li><p>通过undo no=3的日志把id=2的数据删除</p></li><li><p>通过undo no=2的日志把id=1的数据的deletemark还原成0</p></li><li><p>通过undo no=1的日志把id=1的数据的name还原成Tom</p></li><li><p>通过undo no=0的日志把id=1的数据删除</p></li></ol><p><strong>4. undo log的删除</strong></p><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p><h4 id="_2-6-小结" tabindex="-1"><a class="header-anchor" href="#_2-6-小结" aria-hidden="true">#</a> <strong>2.6</strong> <strong>小结</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040944948.png" alt="image-20220404094436830"></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p><h2 id="第15章-锁" tabindex="-1"><a class="header-anchor" href="#第15章-锁" aria-hidden="true">#</a> 第15章 锁</h2><h3 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> <strong>1.</strong> <strong>概述</strong></h3><p>事务的隔离性由锁来实现！</p><p>锁是计算机协调多个进程或线程并发访问某一资源的机制，在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程访问，这就是保证线程安全性，保证数据的一致性（一致性同样可以理解为是满足约束条件状态的数据）和完整性。这个思想在数据库领域中同样重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。<strong>同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。</strong> 锁冲突 也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h3 id="_2-mysql并发事务访问相同记录" tabindex="-1"><a class="header-anchor" href="#_2-mysql并发事务访问相同记录" aria-hidden="true">#</a> <strong>2. MySQL并发事务访问相同记录</strong></h3><h4 id="_2-1-读-读情况" tabindex="-1"><a class="header-anchor" href="#_2-1-读-读情况" aria-hidden="true">#</a> <strong>2.1</strong> <strong>读-读情况</strong></h4><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h4 id="_2-2-写-写情况" tabindex="-1"><a class="header-anchor" href="#_2-2-写-写情况" aria-hidden="true">#</a> <strong>2.2</strong> <strong>写-写情况</strong></h4><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。</p><p>这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始没有锁结构和记录进行关联。如图。</p><p><img src="/study/assets/image-20220512162022056.c5b5eddc.png" alt="image-20220512162022056"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有锁结构和这条记录相关联，当没有的时候就会在内存中生成一个锁结构与之关联。比如，<code>事务T1</code>要对这条记录做改动，就需要生成一个锁结构与之关联。</p><p><img src="/study/assets/image-20220512162208201.602b64ed.png" alt="image-20220512162208201"></p><p>在锁结构里有很多信息，为了简化理解，只把比较重要的两个属性拿了出来：</p><ul><li>trx信息：代表这个锁结构是哪个事务生成</li><li>is_waiting：代表当前事务是否在等待。</li></ul><p>当事务T1要改动这条记录，生成了一个<strong>锁结构</strong>与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，我们把这个场景就称之为<code>获取锁成功</code>,或者加锁成功，然后就可以继续执行操作了。</p><p>**在事务T1提交之前，**另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为true，表示当前事务需要等待，我们把这个场景称为获取锁失败或者说加锁失败。图示：</p><p><img src="/study/assets/image-20220512164808936.343be76c.png" alt="image-20220512164808936"></p><p>锁结构是与记录关联，锁结构里记录了事务信息和is_waiting。</p><p>在事务T1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，<strong>发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程（MySQL是有连接池、有线程池来执行SQL语句的）唤醒</strong>，让它继续执行，此时事务T2就算获取到锁了。效果图：</p><p><img src="/study/assets/image-20220512165212730.e6925630.png" alt="image-20220512165212730"></p><h4 id="_2-3-读-写或写-读情况" tabindex="-1"><a class="header-anchor" href="#_2-3-读-写或写-读情况" aria-hidden="true">#</a> <strong>2.3</strong> <strong>读-写或写-读情况</strong></h4><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p><p>各个数据库厂商对SQL标准的支持可能不一样，比如MySQL在可重复读隔离级别上就已经解决了幻读问题，这是通过MVCC，后续会讲解。</p><h4 id="_2-4-并发问题的解决方案" tabindex="-1"><a class="header-anchor" href="#_2-4-并发问题的解决方案" aria-hidden="true">#</a> <strong>2.4</strong> <strong>并发问题的解决方案</strong></h4><p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li><strong>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</strong></li></ul><p>所谓的<code>MVCC</code>，就是<strong>生成</strong>一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本**（历史版本由<code>undo日志</code>构建）**。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p><p><strong>正式因为能够读取数据的历史记录版本，所以才解决了不可重复读和幻读的问题，因为不可重复读和幻读问题相当于都是读到了数据表中的被其他事务更新了之后的数据！！！</strong></p><p><strong>ReadView就相当于是屏障，当前事务只能够读取这道屏障之前的已提交事务所作的修改</strong></p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，**ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，**也就是避免了脏读现象，但是没有避免不可重复读和幻读，因为每次select操作都会生成一个ReadView，在ReadView之前的其他事务所做的更改能被看到，所以如果有其他事务修改数据，那么能被看到，导致不可重复读问题。</li><li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作 </code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这ReadView，这样也就避免了不可重复读和幻读的问题。所以后面的select操作读到的数据都是ReadView之前的事务修改提交的数据，也就是第一次select之后，若后面有其他事务对数据修改或做了添加，那么其实是读不到的，所以解决了不可重复读和幻读的问题！</li></ul></blockquote><ul><li><p><strong>方案二：读、写操作都采用<code>加锁</code>的方式。</strong></p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本。</p><p>比如，在银行存款业务中，需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写入到数据库中，在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其它事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像<code>写-写</code>一样需要排队执行。</p><p><img src="/study/assets/image-20220512171649266.b85c6f9d.png" alt="image-20220512171649266"></p></li><li><p>小结对比发现：</p><ul><li><strong>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突（读用MVCC，写加锁），<code>性能更高</code>。</strong></li><li><strong>采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要<code>排队执行</code>（读写都加锁），影响性能。</strong></li></ul></li></ul><p><strong>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。</strong></p><h3 id="_3-锁的不同角度分类" tabindex="-1"><a class="header-anchor" href="#_3-锁的不同角度分类" aria-hidden="true">#</a> <strong>3.</strong> <strong>锁的不同角度分类</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204050933339.png" alt="image-20220405093322184"></p><h4 id="_3-1-从数据操作的类型划分-读锁、写锁" tabindex="-1"><a class="header-anchor" href="#_3-1-从数据操作的类型划分-读锁、写锁" aria-hidden="true">#</a> <strong>3.1</strong> <strong>从数据操作的类型划分：读锁、写锁</strong></h4><p>对于数据库中并发事务的读-读情况并不会引起什么问题，对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些并发问，需要使用MVCC来读，对写加锁，或者对读写都加锁的方式来解决并发问题。在使用对读写都加锁的方式来解决并发问题这种情况，由于既要允许读-读情况不受影响，又要使<code>写-写、读-写、写-读</code>情况中的操作相互阻塞，所以MySQL实现一个由<strong>两种类型的锁组成的锁系统</strong>来解决，这两种类型的锁通常被称为共享锁（Shared Lock， S Lock）和排他锁（Exclusive Lock, X Lock），也叫读锁（readLock）和写锁（write lock）。共享锁就是读锁，排他锁就是写锁。</p><ul><li><code>读锁</code>：也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，**多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。**但是对其他事务的写操作是阻塞的！</li><li><code>写锁</code>：也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于</strong> <strong>InnoDB</strong> <strong>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><blockquote><p>举例（行级读写锁）：</p><p>如果一个事务T1已经获得了某个行r的读锁，那么此时另外一个事务T2是可以获得这个行r的读锁的，获取锁就是锁结构和这个行记录进行关联！！因为读取操作并没有改变行r的数据，<strong><code>但是如果某个事务T3，想获得行r的写锁（排他锁），则它必须等待T1、T2释放掉行r上的读锁才行。</code></strong></p></blockquote><table><thead><tr><th></th><th>X锁</th><th>S锁</th></tr></thead><tbody><tr><td>X锁</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S锁</td><td>不兼容</td><td>兼容</td></tr></tbody></table><p><strong>1. 锁定读</strong></p><p>说读锁就是S锁即共享锁，其实不太严谨，其实读锁也可以加上排他的行为！！并不一定就是读锁就是共享锁。</p><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，<strong>有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务<code>读写</code>该记录</strong>，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li>对读取的记录加<code>S锁</code>：</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SELECT ... LOCK IN SHARE MODE;
# 或
SELECT ... FOR SHARE; #(8.0新增语法)
</code></pre></div><p>在普通的select语句后边加LOCK IN SHARE MODE，如果当前事务执行了该语句，那么他会为读取到的记录（读取到的记录不止一行）加共享锁，**这样允许别的事务继续获取<code>这些记录</code>的共享锁（比方说别的事务也是用了<code>select ... lock in share mode</code>语句来读取这些记录），但是不能获取这些记录的排他锁（比如说别的事务使用<code>select ... for update</code>或者直接修改记录，也就是执行写操作），**如果别的事务想要获取这些记录的<code>排他锁</code>，那么他们会<code>阻塞</code>，<strong>直到当前<code>事务提交</code>之后将这些记录上的<code>共享锁</code>释放掉。</strong></p><ul><li>对读取的记录加<code>X锁</code>：<strong>（读锁加上排他的行为）</strong></li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SELECT ... FOR UPDATE;
</code></pre></div><p>在普通的select语句后边加上for update，如果当前事务执行了该语句，那么他会为读取到的记录（读取到的记录不止一行）加上排他锁，这样<strong>既不允许别的事务获取这些记录的共享锁</strong>（比方说别的事务也是用了<code>select ... lock in share mode</code>语句来读取这些记录），<strong>也不允许别的事务获取这些记录的排他锁</strong>（比如说别的事务使用<code>select ... for update</code>或者直接修改记录，也就是执行写操作）。如果别的事务想要获取这些记录的<code>共享锁</code>和<code>排他锁</code>，那么他们会<code>阻塞</code>，<strong>直到当前<code>事务提交</code>之后将这些记录上的<code>排他锁</code>释放掉。</strong></p><p><strong>MySQL8.0新特性：</strong></p><p>在5.7及之前的版本，SELECT ... FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT ... FOR UPDATE, SELECT ... FOR SHARE 添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>NOWAIT：如果查询的行已经加锁，会立即报错返回</li><li>SKIP LOCKED：如果查询的行已经加锁，只返回结果中不包含被锁定的行</li></ul><p><strong>2. 写操作（自动加排他锁！）</strong></p><p>读操作也就是select，即可以为读到的数据加上共享锁，也可以为它们加上排他锁。</p><p><strong>写操作也就是以下三种操作一定是为操作的数据加上排他锁。</strong></p><p><strong>也就是写操作会自动加排他锁！</strong></p><p>比如说别的事务使用<code>select ... for update</code>或者直接修改记录，也就是执行写操作，会加排他锁。</p><p>select ... for update是读操作加排他锁，也就是读锁加上排他的特性，修改记录是写操作，会自动加排他锁！！！</p><ul><li><p><code>DELETE</code>：</p><p>对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p></li><li><p><code>UPDATE</code>：在对一条记录做UPDATE操作时分为三种情况：</p><ul><li><p>情况1：未修改该记录的键值，并且<strong>被更新的列占用的存储空间在修改前后未发生变化。</strong></p><p>则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原纪录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。</p></li><li><p>情况2：未修改该记录的键值，并且<strong>至少有一个被更新的列占用的存储空间在修改前后发生变化。</strong></p><p>则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p></li><li><p>情况3：修改该记录的键值。</p><p>则相当于在原纪录上做<code>DELECT</code>操作之后再来一次<code>INSERT</code>操作。</p></li></ul></li><li><p><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p></li></ul><p>总结：</p><ul><li>DELETE和UPDATE操作先加上排他锁或者说先获取到要操作的记录的排他锁，再执行操作。</li><li>INSERT操作不用显示加上排他锁，而是由MySQL提供隐式锁。</li></ul><h4 id="_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" tabindex="-1"><a class="header-anchor" href="#_3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" aria-hidden="true">#</a> <strong>3.2</strong> <strong>从数据操作的粒度划分：表级锁、页级锁、行锁</strong></h4><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情，锁的粒度越小，意味着需要管理的锁资源越多，耗费的资源越多。因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了锁粒度的概念。</p><p>对一条记录加锁或者说获得一条记录的锁，影响的只是这条记录而已，我们就说这个锁的粒度比较细，其实一个事务也可以在表级别进行加锁，自然就称为表锁或者表级锁。对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。按锁的粒度划分主要分为表锁、行锁和页锁。</p><h5 id="_1-表锁-table-lock" tabindex="-1"><a class="header-anchor" href="#_1-表锁-table-lock" aria-hidden="true">#</a> <strong>1.</strong> <strong>表锁（Table Lock）</strong></h5><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>，并且表锁是<code>开销最少</code>的策略（因为粒度比较大）。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>的问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><p><strong>① 表级别的S锁、X锁</strong>（InnoDB不会添加，除非用户手动获取锁）</p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是<strong>不会</strong>为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，<code>手动</code>获取InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p><ul><li><p><code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。</p></li><li><p><code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</p></li></ul><p>总结：MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p><p>MyISAM引擎加表级锁：</p><p><img src="/study/assets/image-20220512202803992.7a8408d0.png" alt="image-20220512202803992"></p><p><strong>② 意向锁 （intention lock）</strong></p><ol><li><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p><p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><p>2、意向锁是一种<code>不与行级锁冲突的表级锁</code>，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p></li><li><p>意向锁分为两种：</p><ul><li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
SELECT column FROM table ... LOCK IN SHARE MODE;
</code></pre></div><ul><li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 
SELECT column FROM table ... FOR UPDATE;
</code></pre></div><p>即：<strong>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁。</strong></p></li><li><p><strong>意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。<strong>简单来说就是给更大一级级别的空间示意里面是否已经上过锁。</strong></p><p>在数据表的场景中，<strong>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</strong>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排它锁即可。</p><ul><li>如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>（InnoDB会为我们自动添加）</li><li>如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上<code>添加意向排他锁</code>（InnoDB会为我们自动添加）</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p></li><li><p>意向锁会与普通的排他/共享锁互斥</p><p><img src="/study/assets/image-20220512214929906.dd94068a.png" alt="image-20220512214929906"></p><p>注意这里的排他/共享锁都是表级锁，意向锁不会与行级的共享/排他锁互斥。</p></li><li><p>意向锁和意向锁之间是共享的</p><p><img src="/study/assets/image-20220512215337713.6f00d430.png" alt="image-20220512215337713"></p><p>这是因为这是意向锁！反映的实际上是这个表里有某些行上了锁，比如select操作一条数据的时候，获取了这条数据的排他锁，或者说给这条数据上了排他锁，那么这个表也自动地被InnoDB上了意向排他锁，那么此时另一个事务给这个表里的另一条数据上排他锁的时候，当然是可以的，那么此时这个表被另一个事务也自动地上了意向排他锁，所以意向排他锁之间是兼容的。另外三种关系也是一样的。</p><p>根本原因就是意向锁是反映的这个表里的某些数据上了锁，比如事务A给a、b、c三条数据上了锁，事务B给e、d、f三条数据上了锁，那么这个表相当于由于两个事务操作，由InnoDB上了两个意向锁，这里肯定是兼容的，因为行锁之间并没有冲突，所以反映行锁的意向锁之间当然不会冲突！</p></li><li><p>结论</p><ul><li>InnoDB支持多粒度锁，特定场景下，意向锁可以和表级锁共存。</li><li>意向锁之间不排斥，原因在上面解释了，但除了IS与S外，<strong>意向锁会与表级共享锁和表级排他锁互斥。</strong></li><li><strong>IX、IS是表级锁，不会和行级的S、X发生冲突，只会和表级的S、X锁发生冲突。IS和S除外，因为都是共享锁。</strong></li><li>意向锁在保证了行级锁，并发性的前提下，实现了行锁和表锁共存，并且满足事务隔离性的需求。</li></ul><p>事务的隔离性是通过锁来实现的！！</p></li></ol><p><strong>③ 自增锁（AUTO-INC锁）</strong></p><p><strong>1. “Simple inserts”</strong> <strong>（简单插入）</strong></p><p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。</p><p><strong>2. “Bulk inserts”</strong> <strong>（批量插入）</strong></p><p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p><p><strong>3. “Mixed-mode inserts”</strong> <strong>（混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p><p>对于上面数据插入的案例，MySQL采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INT锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INT锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INT锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p><p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT ... SELECT，REPLACE ... SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可拓展的锁定模式，但是当使用基于语句的复制或恢复方案时，<strong>从二进制日志重播SQL语句时，这是不安全的。</strong></p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p><strong>④ 元数据锁（MDL锁）</strong></p><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</strong></p><p>读锁之间不互斥，因此可以有多个线程<strong>同时对一张表</strong>增删改查，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性！！解决了DML操作和DDL操作之间的一致性问题。</p><p>不需要显示使用，在访问一个表时会被自动加上。</p><h5 id="_2-innodb中的行锁" tabindex="-1"><a class="header-anchor" href="#_2-innodb中的行锁" aria-hidden="true">#</a> <strong>2. InnoDB中的行锁</strong></h5><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p><p>**优点：**锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code></p><p>**缺点：**对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务；二是采用了行级锁。</p><p><strong>① 记录锁（Record Locks）</strong></p><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。</p><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong></p><ol><li><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。</p><p><img src="/study/assets/image-20220512223646812.30a6743a.png" alt="image-20220512223646812"></p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的</strong>。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。<strong>而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。（这会导致死锁）</strong></p></li><li><p>间隙锁的创建</p><p>在两条记录范围之间，去做select操作，做select操作的同时，添加行级的共享锁或排他锁，那么就会添加上共享gap锁或间隙gap锁，这个锁不回限制其他事务对这条记录继续添加记录锁或gap锁。</p><p>比如在3-8之间的任意一条数据，做select操作，添加行级记录锁，此时相当于给3-8开区间的所有数据都添加上了锁，这就是间隙锁，防止数据插入。</p><p>如果在主键值最大的后面添加间隙锁，比如给id为25的数据添加间隙锁，25这个数据当然是不存在的，等价于给id &gt; 20的任意记录添加间隙锁，效果是对id &gt; 20的范围添加了间隙锁，就不能插入id比20大的数据了。</p></li><li><p>间隙锁导致死锁的问题</p><p><img src="/study/assets/image-20220512225928434.ef6bca70.png" alt="image-20220512225928434"></p></li></ol><p><strong>③ 临键锁（Next-Key Locks）</strong></p><p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。Next-Key Locks是在存储引擎<code>innodb</code>、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>begin; 
select * from student where id &lt;=8 and id &gt; 3 for update;
</code></pre></div><p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><p><strong>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。</strong></p><p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p><p><img src="/study/assets/image-20220512232420415.cd1d0229.png" alt="image-20220512232420415"></p><p>从图中可以看到，由于T1持有gap锁，所以T2和T3需要生成一个插入意向锁的锁结构并处于等待状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能获取到对应的插入意向锁了（本质上就是把插入意向锁对应锁结构的is_waiting属性改为false），T2和T3之间并不会阻塞，它们可以同时获取到id值为8的插入意向锁，然后执行插入操作。</p><h5 id="_3-页锁" tabindex="-1"><a class="header-anchor" href="#_3-页锁" aria-hidden="true">#</a> <strong>3.</strong> <strong>页锁</strong></h5><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h4 id="_3-3-从对待锁的态度划分-乐观锁、悲观锁" tabindex="-1"><a class="header-anchor" href="#_3-3-从对待锁的态度划分-乐观锁、悲观锁" aria-hidden="true">#</a> <strong>3.3</strong> <strong>从对待锁的态度划分:乐观锁、悲观锁</strong></h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><p><strong>1.</strong> <strong>悲观锁（Pessimistic Locking）</strong></p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p>select ... for update 是MySQL中悲观锁。</p><p>注意：<strong>select ... for update 语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong></p><p><strong>2.</strong> <strong>乐观锁（Optimistic Locking）</strong></p><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1.</strong> <strong>乐观锁的版本号机制</strong></p><p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，**会获取 version 字段的取值。**然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p><strong>2.</strong> <strong>乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将<strong>当前数据的时间戳和更新之前取得的时间戳</strong>进行比较，如果两者一致则更新成功，否则说明这个数据被其他事务已经进行了更改，当前事务对数据的修改就不会成功，就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），<strong>从而证明当前拿到的数据是否最新。</strong></p><p><strong>3.</strong> <strong>两种锁的适用场景</strong></p><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><p><code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p><code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p></li></ol><p><img src="/study/assets/image-20220513000732732.284ad065.png" alt="image-20220513000732732"></p><h4 id="_3-4-按加锁的方式划分-显式锁、隐式锁" tabindex="-1"><a class="header-anchor" href="#_3-4-按加锁的方式划分-显式锁、隐式锁" aria-hidden="true">#</a> <strong>3.4</strong> <strong>按加锁的方式划分：显式锁、隐式锁</strong></h4><p><strong>1.</strong> <strong>隐式锁</strong></p><ul><li><p>**情景一：**对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p></li><li><p>**情景二：**对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p></li></ul><p>即：一个事务对新插入的记录可以不显示的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p><strong>2.</strong> <strong>显式锁</strong></p><p>通过特定的语句进行加锁，我们一般称之为显示加锁。</p><h4 id="_3-5-其它锁之-全局锁" tabindex="-1"><a class="header-anchor" href="#_3-5-其它锁之-全局锁" aria-hidden="true">#</a> <strong>3.5</strong> <strong>其它锁之：全局锁</strong></h4><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>Flush tables with read lock
</code></pre></div><h4 id="_3-6-其它锁之-死锁" tabindex="-1"><a class="header-anchor" href="#_3-6-其它锁之-死锁" aria-hidden="true">#</a> <strong>3.6</strong> <strong>其它锁之：死锁</strong></h4><ol><li><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</p><p><img src="/study/assets/image-20220513171605954.ef7ae0fe.png" alt="image-20220513171605954"></p></li><li><p>产生死锁的必要条件</p><ul><li>两个或者两个以上的事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ul></li><li><p>如何处理死锁</p><p>**方式1：**等待，直到超时（innodb_lock_wait_timeout=50s）</p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。</p><p>**方式2：**使用死锁检测进行死锁处理</p><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。</p><p>有死锁，InnoDB会选择回滚undo量最小的事务。</p></li><li><p>如何避免死锁</p><ul><li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</li><li>调整业务逻辑SQL执行顺序，避免update/delete这种长时间持有锁的SQL在事务前面</li><li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短资源锁定的时间，发生锁冲突的几率也就更小</li><li>在并发比较高的系统中，不要显示加锁，特别是在事务里显示加锁。</li><li>降低隔离级别。</li></ul></li></ol><h3 id="_4-锁的内存结构" tabindex="-1"><a class="header-anchor" href="#_4-锁的内存结构" aria-hidden="true">#</a> <strong>4.</strong> <strong>锁的内存结构</strong></h3><p>我们前边说对一条记录加锁的本质就是在内存中创建一个锁结构与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？比如：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
</code></pre></div><p>理论上创建多个锁结构没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了，所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个锁结构中：</p><ul><li>在同一个事务中对数据上锁</li><li>上锁的数据在同一个页面中</li><li>等待状态一样</li><li>加锁的类型是一样的</li></ul><p>InnoDB的锁结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051514736.png" alt="image-20220405151409557"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息</code>：</p><p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息。</p><p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code>：</p><p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code>：</p><p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁：记载了三个重要的信息： <ul><li>Space ID ：记录所在表空间。</li><li>Page Number ：记录所在页号。</li><li>n_bits ：对于行锁来说，<strong>一条记录就对应着一个比特位</strong>，一个页面中包含很多记录，用不同的比特位来区分到底是<strong>哪一条记录加了锁</strong>。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属性代表使用了多少比特位。</li></ul></li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p></blockquote><p><code>4. type_mode</code>：</p><p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051518659.png" alt="image-20220405151829547"></p><ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下： <ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。</li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。</li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。</li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。</li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用： <ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li><strong>行锁</strong>的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在 <code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型： <ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。</li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。</li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code>属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中： <ul><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code>：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code>：</p><p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个 heap_no 属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射到页内的一条记录。</p><h3 id="_5-锁监控" tabindex="-1"><a class="header-anchor" href="#_5-锁监控" aria-hidden="true">#</a> <strong>5.</strong> <strong>锁监控</strong></h3><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; show status like &#39;innodb_row_lock%&#39;;
</code></pre></div><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。</p><p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p><h2 id="第16章-多版本并发控制" tabindex="-1"><a class="header-anchor" href="#第16章-多版本并发控制" aria-hidden="true">#</a> 第16章 多版本并发控制</h2><h3 id="_1-什么是mvcc" tabindex="-1"><a class="header-anchor" href="#_1-什么是mvcc" aria-hidden="true">#</a> <strong>1.</strong> <strong>什么是MVCC</strong></h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。<strong>换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</strong></p><h3 id="_2-快照读与当前读" tabindex="-1"><a class="header-anchor" href="#_2-快照读与当前读" aria-hidden="true">#</a> <strong>2.</strong> <strong>快照读与当前读</strong></h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。<strong>当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC读的是快照，本质是采用乐观锁思想的一种方式。</strong></p><h4 id="_2-1-快照读" tabindex="-1"><a class="header-anchor" href="#_2-1-快照读" aria-hidden="true">#</a> <strong>2.1</strong> <strong>快照读</strong></h4><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的</strong> <strong>SELECT</strong> <strong>都属于快照读</strong>，即不加锁的非阻塞读。</p><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h4 id="_2-2-当前读" tabindex="-1"><a class="header-anchor" href="#_2-2-当前读" aria-hidden="true">#</a> <strong>2.2</strong> <strong>当前读</strong></h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><p>当前读就是读取最新数据，为了做之后的修改操作，当然不能读取到历史数据。</p><p>快照读只是为了读数据，而不是为了之后的修改，所以不一定要读取到数据的最新值，也不会引起并发问题，增加了并发性，但是又并没有上锁，所以是乐观锁思想。</p><h3 id="_3-复习" tabindex="-1"><a class="header-anchor" href="#_3-复习" aria-hidden="true">#</a> <strong>3.</strong> <strong>复习</strong></h3><h4 id="_3-1-再谈隔离级别" tabindex="-1"><a class="header-anchor" href="#_3-1-再谈隔离级别" aria-hidden="true">#</a> <strong>3.1</strong> <strong>再谈隔离级别</strong></h4><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536648.png" alt="image-20220405153617536"></p><p>另图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051536125.png" alt="image-20220405153632021"></p><p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问。如果我们想要解决幻读问，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题！它可以在大多数情况下替代行级锁，降低系统的开销。</p><h4 id="_3-2-隐藏字段、undo-log版本链" tabindex="-1"><a class="header-anchor" href="#_3-2-隐藏字段、undo-log版本链" aria-hidden="true">#</a> <strong>3.2</strong> <strong>隐藏字段、Undo Log版本链</strong></h4><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。隐藏列一共有三个：隐式生成聚簇索引的主键列、事务ID列、回滚指针列。</p><ul><li><p><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给trx_id 隐藏列。</p></li><li><p><code>roll_pointer（回滚指针）</code>：每次对某条聚簇索引记录进行改动时，都会先把旧的版本写入到 undo日志中，然后才进行修改，然后将修改的SQL语句写入redo log buffer，然后将redo log buffer按某种策略刷盘到磁盘中，也就是写入到redo log file中，这其中涉及到page cache。然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><p>回滚指针是和undo log链打交道的。</p><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的undo log segment也会被系统回收。（也就是该undo日志占用的undo 页面链表要么被重用，要么被释放。）</p></blockquote><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志都由记录行格式的roll_pointer（回滚指针）指向（INSERT操作对应的undo log没有该属性，因为该记录在insert之前没有更早的版本）。可以将这些undo 日志都连起来，串成一个链表：</p><p><img src="/study/assets/image-20220513184324327.3c6919a3.png" alt="image-20220513184324327"></p><p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的数据旧版本都会被roll_pointer属性连接成一个链表，我们把这个链称为版本链，版本链的头节点就是当前记录的最新值。</p><p>每个版本中还包含生成该版本时对应的事务id。</p></li></ul><h3 id="_4-mvcc实现原理之readview" tabindex="-1"><a class="header-anchor" href="#_4-mvcc实现原理之readview" aria-hidden="true">#</a> <strong>4. MVCC实现原理之ReadView</strong></h3><p>MVCC 的实现依赖于：<strong>隐藏字段、Undo Log版本链、Read View</strong>。</p><h4 id="_4-1-什么是readview" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是readview" aria-hidden="true">#</a> <strong>4.1</strong> <strong>什么是ReadView</strong></h4><p><strong>在MVCC机制中，多个事务对同一个行记录进行更新时会产生多个历史快照，这些历史快照保存在undo log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</strong></p><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的<strong>读视图</strong>。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，启动了但还没提交）。</p><p>ReadView和事务是一对一的。</p><h4 id="_4-2-设计思路" tabindex="-1"><a class="header-anchor" href="#_4-2-设计思路" aria-hidden="true">#</a> <strong>4.2</strong> <strong>设计思路</strong></h4><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>MVCC是针对<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>这两个隔离级别的。</p><p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li></ol><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p></blockquote><ol start="2"><li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。</p></li><li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p></li></ol><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><h4 id="_4-3-readview的规则" tabindex="-1"><a class="header-anchor" href="#_4-3-readview的规则" aria-hidden="true">#</a> <strong>4.3 ReadView的规则</strong></h4><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，<strong>表明生成该版本数据的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</strong></li><li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。 <ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h4 id="_4-4-mvcc整体操作流程" tabindex="-1"><a class="header-anchor" href="#_4-4-mvcc整体操作流程" aria-hidden="true">#</a> <strong>4.4 MVCC整体操作流程</strong></h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li><p>首先获取事务自己的版本号，也就是事务 ID；</p></li><li><p>获取 ReadView；</p></li><li><p>查询得到的数据，根据得到的数据的事务id，然后与 ReadView 中的事务版本号进行比较；</p></li><li><p>如果不符合 ReadView 规则，就需要从 Undo Log（版本链） 中获取历史快照；</p></li><li><p>最后返回符合规则的数据。</p></li></ol><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性（判断可见性是判断历史版本数据的事务id和创建该readView的事务id比较，比较活跃事务id，活跃事务id中的最小事务id，以及low_limit_id），依次类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><blockquote><p>InnoDB中，MVCC是通过undo log + read view进行数据读取，undo log保存了历史快照，而read view规则帮我们判断当前版本的数据是否可见。</p></blockquote><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><p>如表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051549618.png" alt="image-20220405154948505"></p><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051550072.png" alt="image-20220405155041964"></p><p><code>有一种屏障的意思，来保证历史版本数据的可见性。</code></p><h3 id="_5-举例说明" tabindex="-1"><a class="header-anchor" href="#_5-举例说明" aria-hidden="true">#</a> <strong>5.</strong> <strong>举例说明</strong></h3><h4 id="_5-1-read-committed隔离级别下" tabindex="-1"><a class="header-anchor" href="#_5-1-read-committed隔离级别下" aria-hidden="true">#</a> <strong>5.1 READ COMMITTED隔离级别下</strong></h4><p><strong>READ COMMITTED</strong> <strong>：每次读取数据前都生成一个ReadView</strong>。</p><h4 id="_5-2-repeatable-read隔离级别下" tabindex="-1"><a class="header-anchor" href="#_5-2-repeatable-read隔离级别下" aria-hidden="true">#</a> <strong>5.2 REPEATABLE READ隔离级别下</strong></h4><p><strong>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了。</strong></p><h4 id="_5-3-如何解决幻读" tabindex="-1"><a class="header-anchor" href="#_5-3-如何解决幻读" aria-hidden="true">#</a> <strong>5.3</strong> <strong>如何解决幻读</strong></h4><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051556631.png" alt="image-20220405155640520"></p><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>select * from student where id &gt;= 1;
</code></pre></div><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p><p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，<strong>并<code>提交</code>事务。</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>insert into student(id,name) values(2,&#39;李四&#39;); 
insert into student(id,name) values(3,&#39;王五&#39;);
</code></pre></div><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559345.png" alt="image-20220405155909223"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051559867.png" alt="image-20220405155941753"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h3 id="_6-总结" tabindex="-1"><a class="header-anchor" href="#_6-总结" aria-hidden="true">#</a> <strong>6.</strong> <strong>总结</strong></h3><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView</li><li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul><blockquote><p>说明：我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的，数据还得回滚的，不能真正物理地删除。</p></blockquote><h2 id="第17章-其它数据库日志" tabindex="-1"><a class="header-anchor" href="#第17章-其它数据库日志" aria-hidden="true">#</a> 第17章 其它数据库日志</h2><h3 id="_1-mysql支持的日志" tabindex="-1"><a class="header-anchor" href="#_1-mysql支持的日志" aria-hidden="true">#</a> <strong>1. MySQL支持的日志</strong></h3><h4 id="_1-1-日志类型" tabindex="-1"><a class="header-anchor" href="#_1-1-日志类型" aria-hidden="true">#</a> <strong>1.1</strong> <strong>日志类型</strong></h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p><ul><li><p>**慢查询日志：**记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p></li><li><p>**通用查询日志：**记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p></li><li><p>**错误日志：**记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</p></li><li><p>**二进制日志：**记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p></li><li><p>**中继日志：**用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p></li><li><p>**数据定义语句日志：**记录数据定义语句执行的元数据操作。</p></li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h4 id="_1-2-日志的弊端" tabindex="-1"><a class="header-anchor" href="#_1-2-日志的弊端" aria-hidden="true">#</a> <strong>1.2</strong> <strong>日志的弊端</strong></h4><ul><li><p>日志功能会<code>降低MySQL数据库的性能</code>。</p></li><li><p>日志会<code>占用大量的磁盘空间</code>。</p></li></ul><h3 id="_2-通用查询日志-general-query-log" tabindex="-1"><a class="header-anchor" href="#_2-通用查询日志-general-query-log" aria-hidden="true">#</a> <strong>2.</strong> <strong>通用查询日志(general query log)</strong></h3><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h4 id="_2-1-查看当前状态" tabindex="-1"><a class="header-anchor" href="#_2-1-查看当前状态" aria-hidden="true">#</a> <strong>2.1</strong> <strong>查看当前状态</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; SHOW VARIABLES LIKE &#39;%general%&#39;;
</code></pre></div><h4 id="_2-2-启动日志" tabindex="-1"><a class="header-anchor" href="#_2-2-启动日志" aria-hidden="true">#</a> <strong>2.2</strong> <strong>启动日志</strong></h4><p><strong>方式1：永久性方式</strong></p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">general_log</span><span class="token punctuation">=</span><span class="token value attr-value">ON</span> 
<span class="token key attr-name">general_log_file</span><span class="token punctuation">=</span><span class="token value attr-value">[path[filename]] #日志文件所在目录路径，filename为日志文件名</span>
</code></pre></div><p><strong>方式2：临时性方式</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET GLOBAL general_log=on; # 开启通用查询日志
SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置
SET GLOBAL general_log=off; # 关闭通用查询日志
SHOW VARIABLES LIKE &#39;general_log%&#39;; # 查看设置后情况
</code></pre></div><h4 id="_2-3-停止日志" tabindex="-1"><a class="header-anchor" href="#_2-3-停止日志" aria-hidden="true">#</a> <strong>2.3</strong> <strong>停止日志</strong></h4><p><strong>方式1：永久性方式</strong></p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">general_log</span><span class="token punctuation">=</span><span class="token value attr-value">OFF</span>
</code></pre></div><p><strong>方式2：临时性方式</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SET GLOBAL general_log=off;
SHOW VARIABLES LIKE &#39;general_log%&#39;;
</code></pre></div><h3 id="_3-错误日志-error-log" tabindex="-1"><a class="header-anchor" href="#_3-错误日志-error-log" aria-hidden="true">#</a> <strong>3.错误日志(error log)</strong></h3><h4 id="_3-1-启动日志" tabindex="-1"><a class="header-anchor" href="#_3-1-启动日志" aria-hidden="true">#</a> <strong>3.1</strong> <strong>启动日志</strong></h4><p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">log-error</span><span class="token punctuation">=</span><span class="token value attr-value">[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span>
</code></pre></div><h4 id="_3-2-查看日志" tabindex="-1"><a class="header-anchor" href="#_3-2-查看日志" aria-hidden="true">#</a> <strong>3.2</strong> <strong>查看日志</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; SHOW VARIABLES LIKE &#39;log_err%&#39;;
</code></pre></div><h4 id="_3-3-删除-刷新日志" tabindex="-1"><a class="header-anchor" href="#_3-3-删除-刷新日志" aria-hidden="true">#</a> <strong>3.3</strong> <strong>删除\刷新日志</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">install</span> -omysql -gmysql -m0644 /dev/null /var/log/mysqld.log
mysqladmin -uroot -p flush-logs
</code></pre></div><h3 id="_4-二进制日志-bin-log" tabindex="-1"><a class="header-anchor" href="#_4-二进制日志-bin-log" aria-hidden="true">#</a> <strong>4.</strong> <strong>二进制日志(bin log)</strong></h3><h4 id="_4-1-查看默认情况" tabindex="-1"><a class="header-anchor" href="#_4-1-查看默认情况" aria-hidden="true">#</a> <strong>4.1</strong> <strong>查看默认情况</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; show variables like &#39;%log_bin%&#39;;
</code></pre></div><h4 id="_4-2-日志参数设置" tabindex="-1"><a class="header-anchor" href="#_4-2-日志参数设置" aria-hidden="true">#</a> <strong>4.2</strong> <strong>日志参数设置</strong></h4><p><strong>方式1：永久性方式</strong></p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token comment">#启用二进制日志 </span>
<span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">atguigu-bin</span> 
<span class="token key attr-name">binlog_expire_logs_seconds</span><span class="token punctuation">=</span><span class="token value attr-value">600 max_binlog_size=100M</span>
</code></pre></div><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><div class="language-ini ext-ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span> 
<span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">&quot;<span class="token inner-value">/var/lib/mysql/binlog/atguigu-bin</span>&quot;</span>
</code></pre></div><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">chown</span> -R -v mysql:mysql binlog
</code></pre></div><p><strong>方式2：临时性方式</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># global 级别 
mysql&gt; set global sql_log_bin=0; 
ERROR 1228 (HY000): Variable &#39;sql_log_bin&#39; is a SESSION variable and can`t be used with SET GLOBAL 

# session级别 
mysql&gt; SET sql_log_bin=0; 
Query OK, 0 rows affected (0.01 秒)
</code></pre></div><h4 id="_4-3-查看日志" tabindex="-1"><a class="header-anchor" href="#_4-3-查看日志" aria-hidden="true">#</a> <strong>4.3</strong> <strong>查看日志</strong></h4><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysqlbinlog -v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;
# 不显示binlog格式的语句
mysqlbinlog -v --base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;
</code></pre></div><div class="language-mysql ext-mysql"><pre class="language-mysql"><code># 可查看参数帮助 
mysqlbinlog --no-defaults --help 

# 查看最后100行 
mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100 

# 根据position查找 
mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A20 &#39;4939002&#39;
</code></pre></div><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; show binlog events [IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count];
</code></pre></div><ul><li><code>IN &#39;log_name&#39;</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）</li><li><code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>：偏移量(不指定就是0)</li><li><code>row_count</code>:查询总条数（不指定就是所有行）</li></ul><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>mysql&gt; show binlog events in &#39;atguigu-bin.000002&#39;;
</code></pre></div><h4 id="_4-4-使用日志恢复数据" tabindex="-1"><a class="header-anchor" href="#_4-4-使用日志恢复数据" aria-hidden="true">#</a> <strong>4.4</strong> <strong>使用日志恢复数据</strong></h4><p>mysqlbinlog恢复数据的语法如下：</p><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqlbinlog <span class="token punctuation">[</span>option<span class="token punctuation">]</span> filename<span class="token operator">|</span>mysql –uuser -ppass<span class="token punctuation">;</span>
</code></pre></div><ul><li><code>filename</code>：是日志文件名。</li><li><code>option</code>：可选项，比较重要的两对option参数是--start-date、--stop-date 和 --start-position、-- stop-position。 <ul><li><code>--start-date 和 --stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position和--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><h4 id="_4-5-删除二进制日志" tabindex="-1"><a class="header-anchor" href="#_4-5-删除二进制日志" aria-hidden="true">#</a> <strong>4.5</strong> <strong>删除二进制日志</strong></h4><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>PURGE {MASTER | BINARY} LOGS TO ‘指定日志文件名’ 
PURGE {MASTER | BINARY} LOGS BEFORE ‘指定日期’
</code></pre></div><h3 id="_5-再谈二进制日志-binlog" tabindex="-1"><a class="header-anchor" href="#_5-再谈二进制日志-binlog" aria-hidden="true">#</a> <strong>5.</strong> <strong>再谈二进制日志(binlog)</strong></h3><h4 id="_5-1-写入机制" tabindex="-1"><a class="header-anchor" href="#_5-1-写入机制" aria-hidden="true">#</a> <strong>5.1</strong> <strong>写入机制</strong></h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051630535.png" alt="image-20220405163025361"></p><p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是 <code>0</code>。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051631346.png" alt="image-20220405163125180"></p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同<strong>redo log</strong> <strong>刷盘流程</strong>一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051632526.png" alt="image-20220405163205364"></p><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h4 id="_5-2-binlog与redolog对比" tabindex="-1"><a class="header-anchor" href="#_5-2-binlog与redolog对比" aria-hidden="true">#</a> <strong>5.2 binlog与redolog对比</strong></h4><ul><li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。 <ul><li>redo log 让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性</li></ul></li></ul><h4 id="_5-3-两阶段提交" tabindex="-1"><a class="header-anchor" href="#_5-3-两阶段提交" aria-hidden="true">#</a> <strong>5.3</strong> <strong>两阶段提交</strong></h4><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051637390.png" alt="image-20220405163716222"></p><p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639192.png" alt="image-20220405163902977"></p><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051639403.png" alt="image-20220405163927129"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h3 id="_6-中继日志-relay-log" tabindex="-1"><a class="header-anchor" href="#_6-中继日志-relay-log" aria-hidden="true">#</a> <strong>6.</strong> <strong>中继日志(relay log)</strong></h3><h4 id="_6-1-介绍" tabindex="-1"><a class="header-anchor" href="#_6-1-介绍" aria-hidden="true">#</a> <strong>6.1</strong> <strong>介绍</strong></h4><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p><h4 id="_6-2-恢复的典型错误" tabindex="-1"><a class="header-anchor" href="#_6-2-恢复的典型错误" aria-hidden="true">#</a> <strong>6.2</strong> <strong>恢复的典型错误</strong></h4><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p><h2 id="第18章-主从复制" tabindex="-1"><a class="header-anchor" href="#第18章-主从复制" aria-hidden="true">#</a> 第18章 主从复制</h2><h3 id="_1-主从复制概述" tabindex="-1"><a class="header-anchor" href="#_1-主从复制概述" aria-hidden="true">#</a> <strong>1.</strong> <strong>主从复制概述</strong></h3><h4 id="_1-1-如何提升数据库并发能力" tabindex="-1"><a class="header-anchor" href="#_1-1-如何提升数据库并发能力" aria-hidden="true">#</a> <strong>1.1</strong> <strong>如何提升数据库并发能力</strong></h4><p>一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h4 id="_1-2-主从复制的作用" tabindex="-1"><a class="header-anchor" href="#_1-2-主从复制的作用" aria-hidden="true">#</a> <strong>1.2</strong> <strong>主从复制的作用</strong></h4><p><strong>第1个作用：读写分离。</strong></p><p><strong>第2个作用就是数据备份。</strong></p><p><strong>第3个作用是具有高可用性。</strong></p><h3 id="_2-主从复制的原理" tabindex="-1"><a class="header-anchor" href="#_2-主从复制的原理" aria-hidden="true">#</a> <strong>2.</strong> <strong>主从复制的原理</strong></h3><h4 id="_2-1-原理剖析" tabindex="-1"><a class="header-anchor" href="#_2-1-原理剖析" aria-hidden="true">#</a> <strong>2.1</strong> <strong>原理剖析</strong></h4><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3 个线程</code>来操作，一个主库线程，两个从库线程。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051646097.png" alt="image-20220405164559961"></p><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051647759.png" alt="image-20220405164718627"></p><p><strong>复制三步骤</strong></p><p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h4 id="_2-2-复制的基本原则" tabindex="-1"><a class="header-anchor" href="#_2-2-复制的基本原则" aria-hidden="true">#</a> <strong>2.2</strong> <strong>复制的基本原则</strong></h4><ul><li><p>每个<code>Slave</code>只有一个<code>Master</code></p></li><li><p>每个<code>Slave</code>只能有一个唯一的服务器ID</p></li><li><p>每个<code>Master</code>可以有多个<code>Slave</code></p></li></ul><h3 id="_3-同步数据一致性问题" tabindex="-1"><a class="header-anchor" href="#_3-同步数据一致性问题" aria-hidden="true">#</a> <strong>3.</strong> <strong>同步数据一致性问题</strong></h3><p><strong>主从同步的要求：</strong></p><ul><li><p>读库和写库的数据一致(最终一致)；</p></li><li><p>写数据必须写到写库；</p></li><li><p>读数据必须到读库(不一定)；</p></li></ul><h4 id="_3-1-理解主从延迟问题" tabindex="-1"><a class="header-anchor" href="#_3-1-理解主从延迟问题" aria-hidden="true">#</a> <strong>3.1</strong> <strong>理解主从延迟问题</strong></h4><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><h4 id="_3-2-主从延迟问题原因" tabindex="-1"><a class="header-anchor" href="#_3-2-主从延迟问题原因" aria-hidden="true">#</a> <strong>3.2</strong> <strong>主从延迟问题原因</strong></h4><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p>**主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。**造成原因：</p><p>1、从库的机器性能比主库要差</p><p>2、从库的压力大</p><p>3、大事务的执行</p><h4 id="_3-3-如何减少主从延迟" tabindex="-1"><a class="header-anchor" href="#_3-3-如何减少主从延迟" aria-hidden="true">#</a> <strong>3.3</strong> <strong>如何减少主从延迟</strong></h4><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p></li><li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p></li><li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p></li><li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p></li></ol><h4 id="_3-4-如何解决一致性问题" tabindex="-1"><a class="header-anchor" href="#_3-4-如何解决一致性问题" aria-hidden="true">#</a> <strong>3.4</strong> <strong>如何解决一致性问题</strong></h4><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题，如果按照数据一致性 从弱到强 来进行划分，有以下 3 种复制方式。</p><p><strong>方法</strong> <strong>1：异步复制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051654133.png" alt="image-20220405165455998"></p><p><strong>方法</strong> <strong>2：半同步复制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051655175.png" alt="image-20220405165513025"></p><p><strong>方法</strong> <strong>3：组复制</strong></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204051656560.png" alt="image-20220405165650425"></p><h2 id="第19章-数据库备份与恢复" tabindex="-1"><a class="header-anchor" href="#第19章-数据库备份与恢复" aria-hidden="true">#</a> 第19章 数据库备份与恢复</h2><h3 id="_1-物理备份与逻辑备份" tabindex="-1"><a class="header-anchor" href="#_1-物理备份与逻辑备份" aria-hidden="true">#</a> <strong>1.</strong> <strong>物理备份与逻辑备份</strong></h3><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p><p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><h3 id="_2-mysqldump实现逻辑备份" tabindex="-1"><a class="header-anchor" href="#_2-mysqldump实现逻辑备份" aria-hidden="true">#</a> <strong>2. mysqldump实现逻辑备份</strong></h3><h4 id="_2-1-备份一个数据库" tabindex="-1"><a class="header-anchor" href="#_2-1-备份一个数据库" aria-hidden="true">#</a> <strong>2.1</strong> <strong>备份一个数据库</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称<span class="token punctuation">[</span>tbname, <span class="token punctuation">[</span>tbname<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> 备份文件名 称.sql
</code></pre></div><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p atguigu<span class="token operator">&gt;</span>atguigu.sql <span class="token comment">#备份文件存储在当前目录下</span>
mysqldump -uroot -p atguigudb1 <span class="token operator">&gt;</span> /var/lib/mysql/atguigu.sql
</code></pre></div><h4 id="_2-2-备份全部数据库" tabindex="-1"><a class="header-anchor" href="#_2-2-备份全部数据库" aria-hidden="true">#</a> <strong>2.2</strong> <strong>备份全部数据库</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -pxxxxxx --all-databases <span class="token operator">&gt;</span> all_database.sql 
mysqldump -uroot -pxxxxxx -A <span class="token operator">&gt;</span> all_database.sql
</code></pre></div><h4 id="_2-3-备份部分数据库" tabindex="-1"><a class="header-anchor" href="#_2-3-备份部分数据库" aria-hidden="true">#</a> <strong>2.3</strong> <strong>备份部分数据库</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump –u user –h <span class="token function">host</span> –p --databases <span class="token punctuation">[</span>数据库的名称1 <span class="token punctuation">[</span>数据库的名称2<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> 备份文件名 称.sql
</code></pre></div><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p --databases atguigu atguigu12 <span class="token operator">&gt;</span>two_database.sql
mysqldump -uroot -p -B atguigu atguigu12 <span class="token operator">&gt;</span> two_database.sql
</code></pre></div><h4 id="_2-4-备份部分表" tabindex="-1"><a class="header-anchor" href="#_2-4-备份部分表" aria-hidden="true">#</a> <strong>2.4</strong> <strong>备份部分表</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump –u user –h <span class="token function">host</span> –p 数据库的名称 <span class="token punctuation">[</span>表名1 <span class="token punctuation">[</span>表名2<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> 备份文件名称.sql
</code></pre></div><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p atguigu book<span class="token operator">&gt;</span> book.sql
<span class="token comment">#备份多张表 </span>
mysqldump -uroot -p atguigu book account <span class="token operator">&gt;</span> 2_tables_bak.sql
</code></pre></div><h4 id="_2-5-备份单表的部分数据" tabindex="-1"><a class="header-anchor" href="#_2-5-备份单表的部分数据" aria-hidden="true">#</a> <strong>2.5</strong> <strong>备份单表的部分数据</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p atguigu student --where<span class="token operator">=</span><span class="token string">&quot;id &lt; 10 &quot;</span> <span class="token operator">&gt;</span> student_part_id10_low_bak.sql
</code></pre></div><h4 id="_2-6-排除某些表的备份" tabindex="-1"><a class="header-anchor" href="#_2-6-排除某些表的备份" aria-hidden="true">#</a> <strong>2.6</strong> <strong>排除某些表的备份</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p atguigu --ignore-table<span class="token operator">=</span>atguigu.student <span class="token operator">&gt;</span> no_stu_bak.sql
</code></pre></div><h4 id="_2-7-只备份结构或只备份数据" tabindex="-1"><a class="header-anchor" href="#_2-7-只备份结构或只备份数据" aria-hidden="true">#</a> <strong>2.7</strong> <strong>只备份结构或只备份数据</strong></h4><ul><li>只备份结构</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p atguigu --no-data <span class="token operator">&gt;</span> atguigu_no_data_bak.sql
</code></pre></div><ul><li>只备份数据</li></ul><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p atguigu --no-create-info <span class="token operator">&gt;</span> atguigu_no_create_info_bak.sql
</code></pre></div><h4 id="_2-8-备份中包含存储过程、函数、事件" tabindex="-1"><a class="header-anchor" href="#_2-8-备份中包含存储过程、函数、事件" aria-hidden="true">#</a> <strong>2.8</strong> <strong>备份中包含存储过程、函数、事件</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p -R -E --databases atguigu <span class="token operator">&gt;</span> fun_atguigu_bak.sql
</code></pre></div><h3 id="_3-mysql命令恢复数据" tabindex="-1"><a class="header-anchor" href="#_3-mysql命令恢复数据" aria-hidden="true">#</a> <strong>3. mysql命令恢复数据</strong></h3><div class="language-bash ext-sh"><pre class="language-bash"><code>mysql –u root –p <span class="token punctuation">[</span>dbname<span class="token punctuation">]</span> <span class="token operator">&lt;</span> backup.sql
</code></pre></div><h4 id="_3-1-单库备份中恢复单库" tabindex="-1"><a class="header-anchor" href="#_3-1-单库备份中恢复单库" aria-hidden="true">#</a> <strong>3.1</strong> <strong>单库备份中恢复单库</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token comment">#备份文件中包含了创建数据库的语句</span>
mysql -uroot -p <span class="token operator">&lt;</span> atguigu.sql
<span class="token comment">#备份文件中不包含了创建数据库的语句</span>
mysql -uroot -p atguigu<span class="token operator"><span class="token file-descriptor important">4</span>&lt;</span> atguigu.sql
</code></pre></div><h4 id="_3-2-全量备份恢复" tabindex="-1"><a class="header-anchor" href="#_3-2-全量备份恢复" aria-hidden="true">#</a> <strong>3.2</strong> <strong>全量备份恢复</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code>mysql –u root –p <span class="token operator">&lt;</span> all.sql
</code></pre></div><h4 id="_3-3-从全量备份中恢复单库" tabindex="-1"><a class="header-anchor" href="#_3-3-从全量备份中恢复单库" aria-hidden="true">#</a> <strong>3.3</strong> <strong>从全量备份中恢复单库</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">sed</span> -n <span class="token string">&#39;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#39;</span> all_database.sql <span class="token operator">&gt;</span> atguigu.sql 
<span class="token comment">#分离完成后我们再导入atguigu.sql即可恢复单个库</span>
</code></pre></div><h4 id="_3-4-从单库备份中恢复单表" tabindex="-1"><a class="header-anchor" href="#_3-4-从单库备份中恢复单表" aria-hidden="true">#</a> <strong>3.4</strong> <strong>从单库备份中恢复单表</strong></h4><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token function">cat</span> atguigu.sql <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">&#39;/./{H;$!d;}&#39;</span> -e <span class="token string">&#39;x;/CREATE TABLE `class`/!d;q&#39;</span> <span class="token operator">&gt;</span> class_structure.sql 
<span class="token function">cat</span> atguigu.sql <span class="token operator">|</span> <span class="token function">grep</span> --ignore-case <span class="token string">&#39;insert into `class`&#39;</span> <span class="token operator">&gt;</span> class_data.sql 
<span class="token comment">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 </span>

use atguigu<span class="token punctuation">;</span> 
mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> class_structure.sql<span class="token punctuation">;</span> 
Query OK, <span class="token number">0</span> rows affected, <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span> 

mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> class_data.sql<span class="token punctuation">;</span> 
Query OK, <span class="token number">1</span> row affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre></div><h3 id="_4-表的导出与导入" tabindex="-1"><a class="header-anchor" href="#_4-表的导出与导入" aria-hidden="true">#</a> <strong>4.</strong> <strong>表的导出与导入</strong></h3><h4 id="_4-1-表的导出" tabindex="-1"><a class="header-anchor" href="#_4-1-表的导出" aria-hidden="true">#</a> <strong>4.1</strong> <strong>表的导出</strong></h4><p><strong>1.</strong> <strong>使用SELECT…INTO OUTFILE导出文本文件</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>SHOW GLOBAL VARIABLES LIKE &#39;%secure%&#39;;
SELECT * FROM account INTO OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;
</code></pre></div><p><strong>2.</strong> <strong>使用mysqldump命令导出文本文件</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqldump -uroot -p -T <span class="token string">&quot;/var/lib/mysql-files/&quot;</span> atguigu account
<span class="token comment"># 或</span>
mysqldump -uroot -p -T <span class="token string">&quot;/var/lib/mysql-files/&quot;</span> atguigu account --fields-terminated- <span class="token assign-left variable">by</span><span class="token operator">=</span><span class="token string">&#39;,&#39;</span> --fields-optionally-enclosed-by<span class="token operator">=</span><span class="token string">&#39;\&quot;&#39;</span>
</code></pre></div><p><strong>3.</strong> <strong>使用mysql命令导出文本文件</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>mysql -uroot -p --execute<span class="token operator">=</span><span class="token string">&quot;SELECT * FROM account;&quot;</span> atguigu<span class="token operator">&gt;</span> <span class="token string">&quot;/var/lib/mysql-files/account.txt&quot;</span>
</code></pre></div><h4 id="_4-2-表的导入" tabindex="-1"><a class="header-anchor" href="#_4-2-表的导入" aria-hidden="true">#</a> <strong>4.2</strong> <strong>表的导入</strong></h4><p><strong>1.</strong> <strong>使用LOAD DATA INFILE方式导入文本文件</strong></p><div class="language-mysql ext-mysql"><pre class="language-mysql"><code>LOAD DATA INFILE &#39;/var/lib/mysql-files/account_0.txt&#39; INTO TABLE atguigu.account;
# 或
LOAD DATA INFILE &#39;/var/lib/mysql-files/account_1.txt&#39; INTO TABLE atguigu.account FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;\&quot;&#39;;
</code></pre></div><p><strong>2.</strong> <strong>使用mysqlimport方式导入文本文件</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>mysqlimport -uroot -p atguigu <span class="token string">&#39;/var/lib/mysql-files/account.txt&#39;</span> --fields-terminated- <span class="token assign-left variable">by</span><span class="token operator">=</span><span class="token string">&#39;,&#39;</span> --fields-optionally-enclosed-by<span class="token operator">=</span><span class="token string">&#39;\&quot;&#39;</span>
</code></pre></div><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.8ebcd65c.js" defer></script>
  </body>
</html>
