<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>zookeeper | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.17f51219.js"><link rel="modulepreload" href="/study/assets/zookeeper.html.64e2f181.js"><link rel="modulepreload" href="/study/assets/zookeeper.html.57a9597b.js"><link rel="prefetch" href="/study/assets/index.html.7094c45c.js"><link rel="prefetch" href="/study/assets/index.html.61cb6c19.js"><link rel="prefetch" href="/study/assets/index.html.3c7243bc.js"><link rel="prefetch" href="/study/assets/index.html.050d8c05.js"><link rel="prefetch" href="/study/assets/gin.html.ce8b9cb0.js"><link rel="prefetch" href="/study/assets/golang.html.2e0960ba.js"><link rel="prefetch" href="/study/assets/gorm.html.9690975a.js"><link rel="prefetch" href="/study/assets/Javaweb.html.40d70c72.js"><link rel="prefetch" href="/study/assets/ES.html.15e7f7c1.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.4fd87a2e.js"><link rel="prefetch" href="/study/assets/Java笔记.html.3ec4dd56.js"><link rel="prefetch" href="/study/assets/dubbo.html.077cbdf4.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.c58b5def.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.f2684b9e.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.72ab22c5.js"><link rel="prefetch" href="/study/assets/并发编程.html.16e4831d.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.dc615084.js"><link rel="prefetch" href="/study/assets/redis.html.61e537d1.js"><link rel="prefetch" href="/study/assets/Mybatis.html.681214f0.js"><link rel="prefetch" href="/study/assets/spring.html.7cf8b063.js"><link rel="prefetch" href="/study/assets/springboot.html.25132801.js"><link rel="prefetch" href="/study/assets/springboot.html.eed1f32d.js"><link rel="prefetch" href="/study/assets/springMVC.html.4cd763ba.js"><link rel="prefetch" href="/study/assets/kafka.html.f1ffb266.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.741346b1.js"><link rel="prefetch" href="/study/assets/操作系统.html.89f60c90.js"><link rel="prefetch" href="/study/assets/flink基本篇1.html.b0f3f3d1.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.d3b7d85b.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.7d7ad439.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.fdfa202f.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.6727da28.js"><link rel="prefetch" href="/study/assets/index.html.0d1424dc.js"><link rel="prefetch" href="/study/assets/index.html.6936ac1a.js"><link rel="prefetch" href="/study/assets/index.html.9ad957d4.js"><link rel="prefetch" href="/study/assets/gin.html.de4e5833.js"><link rel="prefetch" href="/study/assets/golang.html.b78cb06f.js"><link rel="prefetch" href="/study/assets/gorm.html.eaf3a27e.js"><link rel="prefetch" href="/study/assets/Javaweb.html.f9525393.js"><link rel="prefetch" href="/study/assets/ES.html.47d235e4.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.5e0983ae.js"><link rel="prefetch" href="/study/assets/Java笔记.html.3364e488.js"><link rel="prefetch" href="/study/assets/dubbo.html.f85fe99c.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.adede30c.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.0bc4e951.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.e0032175.js"><link rel="prefetch" href="/study/assets/并发编程.html.ae07ae2a.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.ea458ef8.js"><link rel="prefetch" href="/study/assets/redis.html.0938dc5b.js"><link rel="prefetch" href="/study/assets/Mybatis.html.54d81768.js"><link rel="prefetch" href="/study/assets/spring.html.407aff27.js"><link rel="prefetch" href="/study/assets/springboot.html.31ff7dc6.js"><link rel="prefetch" href="/study/assets/springboot.html.b2f5b51b.js"><link rel="prefetch" href="/study/assets/springMVC.html.2d41a631.js"><link rel="prefetch" href="/study/assets/kafka.html.30bbe596.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.2e19fbc1.js"><link rel="prefetch" href="/study/assets/操作系统.html.32bd7638.js"><link rel="prefetch" href="/study/assets/flink基本篇1.html.880935d7.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.be1a6f30.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.7e7ddd6f.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.1f84cd58.js"><link rel="prefetch" href="/study/assets/404.html.42eb3e10.js"><link rel="prefetch" href="/study/assets/404.2eb860ca.js"><link rel="prefetch" href="/study/assets/Layout.60d926fc.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">zookeeper <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#分布式理论" class="router-link-active router-link-exact-active sidebar-item" aria-label="分布式理论"><!--[--><!--]--> 分布式理论 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#cap" class="router-link-active router-link-exact-active sidebar-item" aria-label="CAP"><!--[--><!--]--> CAP <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#base理论" class="router-link-active router-link-exact-active sidebar-item" aria-label="BASE理论"><!--[--><!--]--> BASE理论 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#zookeeper入门" class="router-link-active router-link-exact-active sidebar-item" aria-label="Zookeeper入门"><!--[--><!--]--> Zookeeper入门 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#概述-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#zookeeper配置" class="router-link-active router-link-exact-active sidebar-item" aria-label="zookeeper配置"><!--[--><!--]--> zookeeper配置 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#zookeeper选举机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="zookeeper选举机制"><!--[--><!--]--> zookeeper选举机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#zookeeper节点类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="zookeeper节点类型"><!--[--><!--]--> zookeeper节点类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#zookeeper监听器原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="zookeeper监听器原理"><!--[--><!--]--> zookeeper监听器原理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#客户端向服务器端写数据流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="客户端向服务器端写数据流程"><!--[--><!--]--> 客户端向服务器端写数据流程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#服务器动态上下线监听" class="router-link-active router-link-exact-active sidebar-item" aria-label="服务器动态上下线监听"><!--[--><!--]--> 服务器动态上下线监听 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#分布式锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="分布式锁"><!--[--><!--]--> 分布式锁 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#原生zookeeper实现分布式锁方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="原生zookeeper实现分布式锁方法"><!--[--><!--]--> 原生zookeeper实现分布式锁方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper.html#成熟的curator框架实现分布式锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="成熟的Curator框架实现分布式锁"><!--[--><!--]--> 成熟的Curator框架实现分布式锁 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="zookeeper" tabindex="-1"><a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a> zookeeper</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><ol><li><p>分布式：由多台服务器共同完成一件比较复杂的事，可以理解为分布式</p><p>具体说：设计网站可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性。</p><p>所谓分布式业务系统，就是把原来一个大块系统，根据功能，拆分成多个独立的子系统，<strong>这些独立的子系统（模块）部署在独立的服务器（集群上）</strong>，从物理上解耦合这些模块之间的关系，降低模块之间的耦合度，提高模块的复用性。</p><p>这些子模块或者说子系统通过消息传递以及依赖调用的方式聚合成一个完整的系统。</p></li><li><p>什么是集群</p><p>集群（cluster）是**一组（即多个）**计算机、服务器，他们作为一个整体向用户提供一组网络资源，这些单个的计算机或者服务器就是集群的节点。</p></li><li><p>分布式和集群的区别是什么？</p><p>集群是个物理形态，分布式是个工作方式，也可以理解为一种思想。</p><p>分布式：将一个业务拆分成多个子业务，每个业务部署在不同的服务器上</p><p>集群：多个不同的服务器合起来构成一个cluster，并作为一个整体完成业务。</p></li></ol><h2 id="分布式理论" tabindex="-1"><a class="header-anchor" href="#分布式理论" aria-hidden="true">#</a> 分布式理论</h2><h3 id="cap" tabindex="-1"><a class="header-anchor" href="#cap" aria-hidden="true">#</a> CAP</h3><ol><li><p>概述</p><p>当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区是指物理分区，分区之后可能不同的库就处于不同的服务器上了，也可以理解成分库，分库分区是一个意思，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种集群环境下，再想保证进群的ACID几乎是很难达到，或者即使能达到，那么性能和效率也会大幅度下降，这个时候如果再追求集群的ACID会导致我们的系统变得很差，此时我们就需要引入一个新的理论原则来适应这种集群的情况，就是CAP原理</p></li><li><p>CAP原理又被称作布鲁尔定理，它指出<strong>对于一个分布式系统</strong>来说，不能同时满足以下三点：（CAP原理针对的是分布式系统，而ACID针对的是持久化数据库）</p><ul><li><p>一致性（Consistence）</p><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态</p></li><li><p>可用性（Availability）</p><p><strong>可用性指的是分布式系统在面对各种异常时可以提供正常服务的能力</strong></p><p><strong>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</strong></p></li><li><p>分区容错性（Partition tolerance）</p><p>网络分区是指分布式系统中的节点，被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p></li></ul></li><li><p>CAP仅适用于原子读写的NOSQL场景中，并不适用于数据库系统，现在的分布式系统具有更多特性，比如<strong>扩展性</strong>、可用性等等，在进行分布式系统搭建或者开发的时候，我们不应该仅仅局限于CAP特性上。</p><p><strong>分区容错性（Partition tolerance）我们是必须要实现的。</strong></p></li></ol><h3 id="base理论" tabindex="-1"><a class="header-anchor" href="#base理论" aria-hidden="true">#</a> BASE理论</h3><ol><li><p>在分布式系统中，我们往往追求的是可用性。Redis是CP,也就是一致性和分区容错性</p></li><li><p>BASE理论是对CAP理论的进一步扩充</p><p><strong>BA：是指基本可用，Basically Available（基本可用）</strong></p><p><strong>S：Soft-state（软状态）</strong></p><p><strong>E：Eventually Consistent（最终一致性）</strong></p></li><li><p>BASE理论的核心思想：</p><p>（Redis是CP，是一致性和分区容错性），而我们在设计分布式系统中，往往更加追求一些其他的特性，比如说扩展性，可用性，不应该只是局限于CAP，所以BASE理论作为CAP理论的扩展，来满足我们对分布式系统的设计理论</p><p>核心思想：</p><p><strong>牺牲数据的一致性来满足系统的高可用性</strong>，系统中一部分数据不可用或不一致时，仍需要保持系统整体是主要可用的。</p><p>从这里也可以看出这种场景，<strong>对于数据来说，不是强一致性的（因为我们追求高可用，而可用性和一致性在CAP原理下无法并存，那么在追求可用性的同时，就牺牲掉一致性）</strong>，体现在软状态。</p><p>针对数据库领域，BASE思想的主要实现是对业务数据进行拆分，不同数据分布在不同的机器上，以提升系统的可用性。（可以通过按照业务功能划分、也可以通过分片的形式，让数据散布在不同的服务器上。）</p></li><li><p>BASE理论三要素</p><ul><li><p>BA：基本可用</p><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><ul><li><strong>响应时间上的损失</strong>:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</li><li><strong>系统功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</li></ul></li><li><p>S：软状态</p><p>软状态指<strong>允许系统中的数据存在中间状态</strong>，<strong>并认为该中间状态的存在不会影响系统的整体可用性</strong>，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p>牺牲掉数据的一致性，来追求可用性</p></li><li><p>E：最终一致性</p><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。<strong>因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</strong></p></li></ul></li></ol><h2 id="zookeeper入门" tabindex="-1"><a class="header-anchor" href="#zookeeper入门" aria-hidden="true">#</a> Zookeeper入门</h2><h3 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h3><ol><li><p>zookeeper是一个开源的分布式的，为分布式框架提供协调服务的apache项目</p></li><li><p>zookeeper从设计模式的角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据（比如服务器信息），然后接受观察者（客户端）的注册，一旦这些数据（服务器的信息）的状态发生变化，zookeeper就将负责通知已经在zookeeper上注册的那些观察者（客户端）做出相应的反应。</p><p>zookeeper相当于是一个文件系统，加通知机制。</p></li><li><p>zookeeper本身是一个集群，有多台服务器</p><p><img src="/study/assets/image-20211003203400587.b108c9ef.png" alt="image-20211003203400587"></p></li><li><p>zookeeper：多台服务器，有一个领导者Leader，多个跟随着Follower组成的集群。</p></li><li><p>特点：</p><ul><li><p>集群中只要有<strong>半数以上</strong>节点存活，zookeeper集群就能正常服务，所以zookeeper适合安装奇数台服务器</p></li><li><p><strong>全局数据一致，每个server保存一份相同的数据副本，Client无论连接到哪个server，数据都是一致的。</strong></p></li><li><p>更新请求顺序执行，来自同一个client的更新请求按其发送顺序依次执行。</p></li><li><p>数据更新原子性，一次数据更新要么成功，要么失败。</p></li><li><p>实时性：在一定时间范围内，client能读到最新数据，有一个同步数据的过程</p></li></ul></li><li><p>zookeeper的数据结构</p><p>zookeeper的数据模型的结构与unix文件系统很类似，整体上可以看作是一棵树，每个节点称作一个ZNode，每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识</p></li><li><p>zookeeper应用场景</p><ul><li><p>统一命名服务</p><p><strong>在分布式环境下，经常需要对应用（服务）进行统一命名，便于识别</strong></p><p>例如：IP不容易记住，而域名容易记住。</p><p><img src="/study/assets/image-20211003204538685.9d62abb7.png" alt="image-20211003204538685"></p><p>我们访问哪台服务器，zookeeper会根据负载情况进行一个分配</p></li><li><p>统一配置管理</p><p>分布式环境下，配置文件同步非常常见，一般要求一个集群中，所有节点的配置信息是一致的，比如<strong>kafka集群</strong></p><p>对配置文件修改后，希望能够快速同步到节点上。</p><p>配置管理可交由zookeeper实现</p><ul><li>可将配置信息写入zookeeper上的一个znode</li><li>各个客户端服务器监听这个znode</li></ul></li><li><p>统一集群管理</p><p>分布式环境中，实时掌握每个节点的状态是必要的</p><p>可根据节点实时状态做出一些调整</p><ul><li>可将节点信息写入zookeeper的一个znode</li><li>监听这个znode可获取它的实时状态变化</li></ul></li><li><p>服务器节点动态上下线</p></li><li><p>软负载均衡</p><p><img src="/study/assets/image-20211003205325088.0fd3638c.png" alt="image-20211003205325088"></p></li></ul></li></ol><h3 id="zookeeper配置" tabindex="-1"><a class="header-anchor" href="#zookeeper配置" aria-hidden="true">#</a> zookeeper配置</h3><ol><li><p><img src="/study/assets/image-20211006145100475.5bea220f.png" alt="image-20211006145100475"></p><ul><li><p>tickTime = 2000，通信心跳时间，zookeeper服务器与客户端心跳时间，单位毫秒</p><p>服务器与服务器之间也可以进行心跳通讯，互相发送信号。</p><p><img src="/study/assets/image-20211006145844714.a6afcaf6.png" alt="image-20211006145844714"></p></li><li><p>initLimit = 10， LF初始通信时限</p><p>Leader和Follower初始连接时能容忍的最多心跳数</p><p>如果超过 initLimit*tickTime还没有连接成功的话就认为连接失败</p></li><li><p>syncLimit = 5 LF同步通信时限</p><p>Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follower死</p><p>从服务器列表中删除Follower</p></li><li><p>dataDir：保存zookeeper中的数据</p><p>注意:默认的tmp目录，容易被linux系统定期删除，所以一般不使用默认的tmp目录</p></li><li><p>clientPort=2181：客户端连接端口，通常不做修改</p></li></ul></li><li><p>zookeeper集群最少是三台</p></li></ol><h3 id="zookeeper选举机制" tabindex="-1"><a class="header-anchor" href="#zookeeper选举机制" aria-hidden="true">#</a> zookeeper选举机制</h3><ol><li><p>第一次启动</p><p><img src="/study/assets/image-20211006152112242.ddc9635a.png" alt="image-20211006152112242"></p><p>只要集群中已经有了Leader，后面启动的服务器不会因为myid大而当选Leader，因为如果集群中已经有了Leader，<strong>那么前面的服务器都不是LOOKING状态，所以不会更改选票信息</strong>，新启动的服务器仍然会将票投给自己，此时新启动的服务器就会少数服从多数，更改选票信息会之前的Leader服务器</p></li><li><p>相关概念：</p><p><img src="/study/assets/image-20211006152451588.72a8b6d1.png" alt="image-20211006152451588"></p></li><li><p>非第一次启动</p><p><img src="/study/assets/image-20211006153042844.9cc3144b.png" alt="image-20211006153042844"></p></li></ol><h3 id="zookeeper节点类型" tabindex="-1"><a class="header-anchor" href="#zookeeper节点类型" aria-hidden="true">#</a> zookeeper节点类型</h3><ol><li><p>持久：客户端和服务器端断开连接后，创建的节点不删除</p><p>短暂：客户端和服务器端断开连接后，创建的节点自己删除</p></li><li><p>带序号：创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护</p><p>注意：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</p></li></ol><h3 id="zookeeper监听器原理" tabindex="-1"><a class="header-anchor" href="#zookeeper监听器原理" aria-hidden="true">#</a> zookeeper监听器原理</h3><ol><li><p>将zookeeper客户端去服务器端进行注册，注册说要<strong>监听哪一个节点数据的变化</strong>，zookeeper服务器端的<strong>对应节点数据如果发生变化了，就会通知客户端</strong>，这就是这个过程。</p></li><li><p>监听器原理</p><ul><li>首先要有一个main()线程</li><li>在main线程中<strong>创建zookeeper客户端</strong>，这时就会创建两个线程，一个负责网络通信（connect），一个负责监听（listener）</li><li>通过connect线程将注册的监听事件发送给zookeeper服务器</li><li>在zookeeper服务器的注册监听器列表中<strong>将注册的监听事件添加到列表中</strong></li><li>zookeeper服务器监听到有数据或路径变化，就会将这个消息发送给listener线程</li></ul></li><li><p>常见的监听</p><ul><li><p>监听节点数据的变化</p><p>get path [watch]</p><p>注册一次，只能监听一次，想再次监听，需要再次注册</p></li><li><p>监听子节点增减的变化</p><p>ls path [watch]</p><p>注册一次，只能监听一次，想再次监听，需要再次注册</p></li></ul></li></ol><h3 id="客户端向服务器端写数据流程" tabindex="-1"><a class="header-anchor" href="#客户端向服务器端写数据流程" aria-hidden="true">#</a> 客户端向服务器端写数据流程</h3><ol><li><p>如果客户端直接访问Leader</p><p><img src="/study/assets/image-20211006171214463.6906b50c.png" alt="image-20211006171214463"></p><p>只要有半数的节点认为已经写完了，那么Leader就会告诉客户端即发送给客户端确认ack，说已经写完了。</p></li><li><p>如果客户端的写入请求发送给follower节点</p><p>被访问的follower会把写请求发送给leader，leader来处理并写数据，自己先写一份，并且发写命令给follower节点，<strong>follower需要写并且再发送ack给leader</strong>，超过半数以上节点认为写完，那么leader会再发ack给客户端访问的follower节点，被访问的follower节点给客户端发ack</p><p><img src="/study/assets/image-20211006171630741.ad2d506e.png" alt="image-20211006171630741"></p></li></ol><h2 id="服务器动态上下线监听" tabindex="-1"><a class="header-anchor" href="#服务器动态上下线监听" aria-hidden="true">#</a> 服务器动态上下线监听</h2><ol><li><p><strong>服务器</strong>启动时去<strong>注册信息</strong>（创建都是临时），<strong>在zookeeper上创建对应的节点</strong></p></li><li><p>客户端获取到当前在线服务器列表，并且注册监听，就是监听器原理</p></li></ol><p>这里说的服务器和客户端对于zookeeper集群来说都是客户端，只不过服务器去调的zookeeper的创建节点方法，客户端去监听</p><h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h2><h3 id="原生zookeeper实现分布式锁方法" tabindex="-1"><a class="header-anchor" href="#原生zookeeper实现分布式锁方法" aria-hidden="true">#</a> 原生zookeeper实现分布式锁方法</h3><ol><li><p>什么叫分布式锁</p><p>比如说进程1在使用该资源的适合，会先去获得锁，进程1获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，进程1用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就保证了分布式系统中多个进程能够有序地访问该临界资源，我们把这个<strong>分布式环境下的锁</strong>叫做分布式锁。</p></li><li><p>步骤：</p><ul><li><p><strong>在/lock目录下，创建临时顺序节点，序号最小的节点可以获得锁，处理业务</strong></p></li><li><p>节点需要判断自己是不是当前节点下序号最小的节点，如果是，获取到锁，如果不是，<strong>对前一个节点进行监听，监听这一步很重要，因为就是要监听到前一个节点的释放也就是删除，我们自己写的上锁这个过程才能完成！否则前一个节点没有释放，即没有删除，当前节点永远不可能完成上锁，这里要通过代码实现，可以通过CountDownLatch实现，当没有监听到前一个结点删除的适合，一直锁住，监听到前一个节点删除了，通过CountDownLatch释放锁，我们自己上锁的代码才完成。</strong></p><p><strong>我们自己写的上锁这个方法， 可以通过CountDownLatch来控制流程，通过CountDownLatch的释放锁来使我们的方法执行完成。两者不要搞混。</strong></p></li><li><p>获取到锁，处理完业务后，delete节点释放锁，然后下面的节点将接收到通知，重复第二步判断。</p></li></ul><p><img src="/study/assets/image-20211006180545474.37480f29.png" alt="image-20211006180545474"></p></li></ol><h3 id="成熟的curator框架实现分布式锁" tabindex="-1"><a class="header-anchor" href="#成熟的curator框架实现分布式锁" aria-hidden="true">#</a> 成熟的Curator框架实现分布式锁</h3><ol><li>原生地通过zookeeper和JavaAPI实现分布式锁存在的问题 <ul><li>会话连接是异步的，需要自己去处理，比如使用CountDownLatch</li><li>watch需要重复注册，不然就不能生效</li><li>不支持多节点的创建和删除，需要自己去递归</li></ul></li><li>Curator是一个专门解决分布式锁的框架，解决了原生JavaAPI开发分布式遇到的问题</li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.17f51219.js" defer></script>
  </body>
</html>
