<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>第2章 Java并发机制的底层实现原理 | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.7133dda2.js"><link rel="modulepreload" href="/study/assets/《并发编程的艺术》笔记.html.1601a07f.js"><link rel="modulepreload" href="/study/assets/《并发编程的艺术》笔记.html.d590a45a.js"><link rel="prefetch" href="/study/assets/index.html.8a6a8f27.js"><link rel="prefetch" href="/study/assets/index.html.4b0e143e.js"><link rel="prefetch" href="/study/assets/index.html.22434034.js"><link rel="prefetch" href="/study/assets/index.html.3558d7db.js"><link rel="prefetch" href="/study/assets/index.html.4d90e2fa.js"><link rel="prefetch" href="/study/assets/设计模式1.html.7a0a6100.js"><link rel="prefetch" href="/study/assets/设计模式2.html.f10bfa3c.js"><link rel="prefetch" href="/study/assets/gin.html.54988594.js"><link rel="prefetch" href="/study/assets/golang.html.66d5d4a2.js"><link rel="prefetch" href="/study/assets/gorm.html.97381111.js"><link rel="prefetch" href="/study/assets/Javaweb.html.daec9491.js"><link rel="prefetch" href="/study/assets/ES.html.d3e3332e.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.aa3ac208.js"><link rel="prefetch" href="/study/assets/Java笔记.html.36f8b9f8.js"><link rel="prefetch" href="/study/assets/dubbo.html.ba5c5e6a.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.165e9790.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.cadc104d.js"><link rel="prefetch" href="/study/assets/zookeeper.html.6044a915.js"><link rel="prefetch" href="/study/assets/并发编程.html.f9cf3b7e.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.e862e8d7.js"><link rel="prefetch" href="/study/assets/redis.html.0eaa8316.js"><link rel="prefetch" href="/study/assets/Mybatis.html.7a5d4ced.js"><link rel="prefetch" href="/study/assets/spring.html.7bbd4d12.js"><link rel="prefetch" href="/study/assets/springboot.html.158430fc.js"><link rel="prefetch" href="/study/assets/springboot.html.748cd115.js"><link rel="prefetch" href="/study/assets/springMVC.html.d373b7fd.js"><link rel="prefetch" href="/study/assets/kafka.html.49250d10.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.18cf0619.js"><link rel="prefetch" href="/study/assets/操作系统.html.23b0bd23.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.93ff74cf.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.305f8a25.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.b42b4d9c.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.fcffdc19.js"><link rel="prefetch" href="/study/assets/index.html.bb9f5deb.js"><link rel="prefetch" href="/study/assets/index.html.2f7e3fbc.js"><link rel="prefetch" href="/study/assets/index.html.a7c5a66d.js"><link rel="prefetch" href="/study/assets/index.html.6d828eb6.js"><link rel="prefetch" href="/study/assets/设计模式1.html.63ac97ff.js"><link rel="prefetch" href="/study/assets/设计模式2.html.3ace381f.js"><link rel="prefetch" href="/study/assets/gin.html.f3ff1a98.js"><link rel="prefetch" href="/study/assets/golang.html.515d85a8.js"><link rel="prefetch" href="/study/assets/gorm.html.300ac849.js"><link rel="prefetch" href="/study/assets/Javaweb.html.21276db6.js"><link rel="prefetch" href="/study/assets/ES.html.7b40cb20.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.01dc28c5.js"><link rel="prefetch" href="/study/assets/Java笔记.html.edda9b92.js"><link rel="prefetch" href="/study/assets/dubbo.html.52ad9946.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.e6137346.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.02ae08a3.js"><link rel="prefetch" href="/study/assets/zookeeper.html.baadde97.js"><link rel="prefetch" href="/study/assets/并发编程.html.c2e0ed7d.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.d579d80a.js"><link rel="prefetch" href="/study/assets/redis.html.97cae882.js"><link rel="prefetch" href="/study/assets/Mybatis.html.624db4fe.js"><link rel="prefetch" href="/study/assets/spring.html.4fccb3d7.js"><link rel="prefetch" href="/study/assets/springboot.html.3976ac1c.js"><link rel="prefetch" href="/study/assets/springboot.html.31b15183.js"><link rel="prefetch" href="/study/assets/springMVC.html.c3ec0bf2.js"><link rel="prefetch" href="/study/assets/kafka.html.76dff80b.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.91c37a3d.js"><link rel="prefetch" href="/study/assets/操作系统.html.b7a60937.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.42f54809.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.6dcf9485.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.fdca5964.js"><link rel="prefetch" href="/study/assets/404.html.8ed20733.js"><link rel="prefetch" href="/study/assets/404.e38c84ba.js"><link rel="prefetch" href="/study/assets/Layout.a5f449d7.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">第2章 Java并发机制的底层实现原理 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#锁的升级和对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="锁的升级和对比"><!--[--><!--]--> 锁的升级和对比 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#偏向锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="偏向锁"><!--[--><!--]--> 偏向锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#轻量级锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="轻量级锁"><!--[--><!--]--> 轻量级锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#volatile实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="volatile实现原理"><!--[--><!--]--> volatile实现原理 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#原子操作的实现原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="原子操作的实现原理"><!--[--><!--]--> 原子操作的实现原理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#总线锁和缓存锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="总线锁和缓存锁"><!--[--><!--]--> 总线锁和缓存锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#java如何实现原子操作" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java如何实现原子操作"><!--[--><!--]--> Java如何实现原子操作 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#java内存模型的基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java内存模型的基础"><!--[--><!--]--> Java内存模型的基础 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#通信和同步" class="router-link-active router-link-exact-active sidebar-item" aria-label="通信和同步"><!--[--><!--]--> 通信和同步 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#java内存模型的抽象结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java内存模型的抽象结构"><!--[--><!--]--> Java内存模型的抽象结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#指令重排序" class="router-link-active router-link-exact-active sidebar-item" aria-label="指令重排序"><!--[--><!--]--> 指令重排序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#happens-before" class="router-link-active router-link-exact-active sidebar-item" aria-label="happens-before"><!--[--><!--]--> happens-before <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#as-if-serial" class="router-link-active router-link-exact-active sidebar-item" aria-label="as-if-serial"><!--[--><!--]--> as-if-serial <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#顺序一致性" class="router-link-active router-link-exact-active sidebar-item" aria-label="顺序一致性"><!--[--><!--]--> 顺序一致性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0.html#顺序一致性内存模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="顺序一致性内存模型"><!--[--><!--]--> 顺序一致性内存模型 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="第2章-java并发机制的底层实现原理" tabindex="-1"><a class="header-anchor" href="#第2章-java并发机制的底层实现原理" aria-hidden="true">#</a> 第2章 Java并发机制的底层实现原理</h1><h2 id="锁的升级和对比" tabindex="-1"><a class="header-anchor" href="#锁的升级和对比" aria-hidden="true">#</a> 锁的升级和对比</h2><h3 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁" aria-hidden="true">#</a> 偏向锁</h3><ol><li><p>偏向锁</p><p>偏向锁的本质上是只有一个线程，这个线程在重复获得这个锁对象时（可重入），如果根据锁对象的对象头的运行时元数据mark word里记录的线程ID，发现锁对象已经记录了当前线程的线程ID，那么不会再通过CAS来操作加锁和解锁，减少了开销！</p><p>如果有多个线程来竞争锁，那么会进行锁的升级，由偏向锁升级为轻量级锁。</p></li><li><p>偏向锁的撤销</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当有其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，将对象头的锁标志位设置成无锁状态。</p></li></ol><h3 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁" aria-hidden="true">#</a> 轻量级锁</h3><ol><li><p>轻量级锁膨胀，升级成重量级锁，是在轻量级锁解锁阶段</p><p>轻量级锁解锁时，会使用原子的CAS操作（这里是描述CAS这个操作是原子的，而Java原子类atom类的实现原理便是通过CAS），将因为轻量级锁而存储在栈帧的锁记录里的锁地址和标志位部分的mark word交换回去，即替换回对象头，如果成功，则表示没有竞争发生，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p></li><li><p>Java原子类的原子操作是通过CAS实现的。</p></li></ol><h3 id="volatile实现原理" tabindex="-1"><a class="header-anchor" href="#volatile实现原理" aria-hidden="true">#</a> volatile实现原理</h3><ol><li><p><strong>Lock前缀指令会引起处理器缓存回写到内存</strong></p></li><li><p><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存行的数据无效</strong></p><p>处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</p><p>以上两条就是说的缓存锁。</p></li><li><p>缓存一致性协议：</p><p>系统阻止同时修改由两个或以上处理器缓存的内存区域数据</p></li></ol><h2 id="原子操作的实现原理" tabindex="-1"><a class="header-anchor" href="#原子操作的实现原理" aria-hidden="true">#</a> 原子操作的实现原理</h2><h3 id="总线锁和缓存锁" tabindex="-1"><a class="header-anchor" href="#总线锁和缓存锁" aria-hidden="true">#</a> 总线锁和缓存锁</h3><ol><li><p>总线锁定</p><p>所谓总线锁就是使用处理器提供的一个LOCK #信号，当该处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，不能和内存进行通信，那么该处理器可以独占共享内存。</p><p>在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁把处理器和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存的数据！！所以总线锁的开销很大，目前处理器在某些场景下使用缓存锁定代替总线锁定来进行优化。</p><p>目前处理器都是锁缓存而不是锁总线。</p></li><li><p>缓存锁定</p><p>所谓缓存锁定是指内存区域如果被缓存在处理器的缓存行（CPU高速缓存）中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，不在总线上声言（输出）LOCK # 信号，即不执行总线锁定，而是修改内部的内存地址，当其他处理器回写已被锁定的缓存行数据时，会使缓存行无效，因为其他处理器经过嗅探在总线上传输的数据，发现自己缓存行里的数据在内存的地址已改变，说明数据已失效，就会将当前处理器的缓存行设置为无效状态。</p><p>有两种情况下处理器不支持缓存锁定：</p><ul><li>处理器本身不支持。</li><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。</li></ul></li></ol><h3 id="java如何实现原子操作" tabindex="-1"><a class="header-anchor" href="#java如何实现原子操作" aria-hidden="true">#</a> Java如何实现原子操作</h3><ol><li><p>使用CAS，不断自旋比较，直到成功为止。</p><p>问题：</p><ul><li><p>ABA问题---通过原子引用类的版本号机制来解决，在变量前面追加上版本号。</p><p>AtomicStampedReference解决</p></li><li><p>循环时间长，开销大</p></li><li><p>只能保证一个共享变量的原子操作。</p><p>当对一个共享变量执行操作时，我们可以通过自旋CAS来保证原子操作，但是对多个共享变量操作时，循环CAS无法保证原子性，这个时候可以用锁</p><p><strong>从JDK1.5开始，JDK提供了AtomicReference类来保证引用类型变量即对象的操作的原子性，我们就可以把多个变量放在一个对象里，然后进行CAS操作</strong></p></li></ul></li><li><p>使用锁。</p><p>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候，使用循环CAS来释放锁。比如轻量级锁就通过CAS的方式去将对象的mark word交换到锁记录的锁地址部分，将锁记录的锁地址部分移到锁对象的mark word</p></li></ol><h1 id="第3章-java内存模型" tabindex="-1"><a class="header-anchor" href="#第3章-java内存模型" aria-hidden="true">#</a> 第3章 Java内存模型</h1><h2 id="java内存模型的基础" tabindex="-1"><a class="header-anchor" href="#java内存模型的基础" aria-hidden="true">#</a> Java内存模型的基础</h2><h3 id="通信和同步" tabindex="-1"><a class="header-anchor" href="#通信和同步" aria-hidden="true">#</a> 通信和同步</h3><ol><li><p>线程之间的通信和线程之间的同步是两个问题。</p><p>通信是指线程之间以何种机制来交换信息。</p><p>同步是指程序中用于控制不同线程之间操作发生相对顺序的机制。</p><p><strong>通信强调线程间交换信息，同步强调线程间的操作执行顺序。</strong></p></li><li><p>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p></li><li><p>在共享内存的并发模型里，线程间的通信是隐式的，线程间的同步是显式的。</p><p>在消息传递的并发模型里，线程间的通信是显式的，线程间的同步是隐式的。</p><p>Java的并发采用的是共享内存的模型，Java线程之间的通信总是隐式进行的，整个通信过程对程序员完全透明。</p></li></ol><h3 id="java内存模型的抽象结构" tabindex="-1"><a class="header-anchor" href="#java内存模型的抽象结构" aria-hidden="true">#</a> Java内存模型的抽象结构</h3><ol><li><p>Java线程之间的通信由Java内存模型JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p><p>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，也叫工作内存，是线程私有的，并且本地内存是抽象的概念，并不真实存在。</p><p>JVM中的运行时数据区的堆空间就是共享内存，是线程间共享的，所以说Java的并发模型是共享内存模型。所以主存不能说是抽象的。</p><p><strong>JMM通过控制主内存与每个线程的本地内存之间的交互，来提供各线程对于共享变量的可见性。</strong></p></li></ol><h3 id="指令重排序" tabindex="-1"><a class="header-anchor" href="#指令重排序" aria-hidden="true">#</a> 指令重排序</h3><ol><li><p>在执行程序时，为了提高性能，<strong>编译器和处理器常常会对指令做重排序。</strong></p><p>重排序分3种类型：</p><ul><li><p>编译器优化的重排序</p></li><li><p>指令级并行的重排序</p><p>现代处理器采用了指令级并行技术，来讲多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</p></li><li><p>内存系统的重排序</p></li></ul><p>上述的第一种属于编译器重排序，第二种和第三种属于处理器重排序。</p></li><li><p>这些重排序可能导致多线程程序出现内存可见性问题。</p><p>对于处理器重排序，JMM的处理器重排序规则要求Java编译器在生成指令序列的时候，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p><p><strong>插入内存屏障的目的是禁止指令重排序，来解决共享变量内存可见性的问题。</strong></p></li><li><p>写缓冲区就是线程的本地内存或者说工作内存</p></li><li><p>指令重排序可能会改变多线程环境下的程序的执行结果。</p><p>由于指令重排序，会出现多个线程对共享变量的可见性问题。</p></li></ol><h3 id="happens-before" tabindex="-1"><a class="header-anchor" href="#happens-before" aria-hidden="true">#</a> happens-before</h3><ol><li><p>JMM使用happens-before的概念，<strong>来阐述操作之间的内存可见性</strong>。</p><p>JMM中，如果一个操作执行的结果要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作，可以是同一个线程内的操作，也可以是两个线程之间的。</p><p>happens-before解决的是操作执行的结果可见性的问题！！</p></li><li><p><strong>两个操作之间具有happens-before关系，并不意味着前一个操作的执行必须在后一个操作之前，happens-before仅仅要求钱一个操作执行的结果对后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</strong></p></li><li><p>happens-before规则：</p><ul><li><p>程序顺序规则</p><p>一个线程中的每个操作（这里说的是单线程，并且说的是字节码指令层面的），happens-before这个线程中的任意后续操作</p></li><li><p>监视器锁规则</p><p>对一个锁的解锁，happens-before随后对这个锁的上锁</p></li><li><p>volatile规则</p><p>对一个volatile变量的写，happens-before任意后续对这个volatile变量的读。这里涉及到前面说的内存屏障，作用是禁止指令重排序，保证共享变量对于各个线程的可见性！！重点在于通过内存屏障，将线程本地内存的数据同步到主内存即共享内存。</p></li><li><p>传递规则</p></li></ul></li></ol><h3 id="as-if-serial" tabindex="-1"><a class="header-anchor" href="#as-if-serial" aria-hidden="true">#</a> as-if-serial</h3><ol><li>意思是不管怎么执行指令重排序，单线程的执行结果不能被改变。</li></ol><h2 id="顺序一致性" tabindex="-1"><a class="header-anchor" href="#顺序一致性" aria-hidden="true">#</a> 顺序一致性</h2><h3 id="顺序一致性内存模型" tabindex="-1"><a class="header-anchor" href="#顺序一致性内存模型" aria-hidden="true">#</a> 顺序一致性内存模型</h3><ol><li><p>这是一个理想化的理论参考模型，有以下两点特征</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。</li></ul></li><li><p>在JMM中，没有以上两点保证，对于未同步程序来说，不仅整体执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。</p></li><li><p>若是未同步程序：</p><ul><li>对于单线程，在顺序一致性模型中，可以确定程序执行顺序，在JMM中，可能出现指令重排序。</li><li>顺序一致性模型能保证所有线程看到一致的程序执行顺序，尽管他们未同步，而JMM不行。</li></ul></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.7133dda2.js" defer></script>
  </body>
</html>
