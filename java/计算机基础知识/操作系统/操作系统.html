<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>操作系统 | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.c3238cbb.js"><link rel="modulepreload" href="/study/assets/操作系统.html.20afc324.js"><link rel="modulepreload" href="/study/assets/操作系统.html.c2b62ac8.js"><link rel="prefetch" href="/study/assets/index.html.61599dd2.js"><link rel="prefetch" href="/study/assets/index.html.2fe73774.js"><link rel="prefetch" href="/study/assets/index.html.6efa8406.js"><link rel="prefetch" href="/study/assets/index.html.962aa4d3.js"><link rel="prefetch" href="/study/assets/index.html.68af62d5.js"><link rel="prefetch" href="/study/assets/设计模式1.html.ef4ed161.js"><link rel="prefetch" href="/study/assets/设计模式2.html.ccff403b.js"><link rel="prefetch" href="/study/assets/gin.html.768045c2.js"><link rel="prefetch" href="/study/assets/golang.html.98af325f.js"><link rel="prefetch" href="/study/assets/gorm.html.685f74df.js"><link rel="prefetch" href="/study/assets/Javaweb.html.3ec97e01.js"><link rel="prefetch" href="/study/assets/ES.html.5f7ca047.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.10ab3854.js"><link rel="prefetch" href="/study/assets/Java笔记.html.c043850b.js"><link rel="prefetch" href="/study/assets/dubbo.html.5c2e97e3.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.758e43e2.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.59c5bf81.js"><link rel="prefetch" href="/study/assets/zookeeper.html.d2f4c69d.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.f2186823.js"><link rel="prefetch" href="/study/assets/并发编程.html.3867e8ce.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.7f64a148.js"><link rel="prefetch" href="/study/assets/redis.html.c1ee072e.js"><link rel="prefetch" href="/study/assets/Mybatis.html.aae9194c.js"><link rel="prefetch" href="/study/assets/spring.html.fecf1764.js"><link rel="prefetch" href="/study/assets/springboot.html.2e63d10c.js"><link rel="prefetch" href="/study/assets/springboot.html.1930d9c4.js"><link rel="prefetch" href="/study/assets/springMVC.html.7ff21274.js"><link rel="prefetch" href="/study/assets/kafka.html.e7b2243e.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.eeded9bc.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.9daf565f.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.c84ad3f5.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.54e4dc8c.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.76b5ba4b.js"><link rel="prefetch" href="/study/assets/index.html.5eb7822b.js"><link rel="prefetch" href="/study/assets/index.html.3a8a41bd.js"><link rel="prefetch" href="/study/assets/index.html.100dc7ae.js"><link rel="prefetch" href="/study/assets/index.html.0d45c0c5.js"><link rel="prefetch" href="/study/assets/设计模式1.html.169173e7.js"><link rel="prefetch" href="/study/assets/设计模式2.html.fbcfaaec.js"><link rel="prefetch" href="/study/assets/gin.html.ba853477.js"><link rel="prefetch" href="/study/assets/golang.html.823fa8ac.js"><link rel="prefetch" href="/study/assets/gorm.html.80770bf0.js"><link rel="prefetch" href="/study/assets/Javaweb.html.fda6f624.js"><link rel="prefetch" href="/study/assets/ES.html.e7a850a7.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.38608317.js"><link rel="prefetch" href="/study/assets/Java笔记.html.0c2c2fa1.js"><link rel="prefetch" href="/study/assets/dubbo.html.5442f2cb.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.acdb32ad.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.6420e61f.js"><link rel="prefetch" href="/study/assets/zookeeper.html.f806f303.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.fea1e3ef.js"><link rel="prefetch" href="/study/assets/并发编程.html.b211330e.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.828a42ea.js"><link rel="prefetch" href="/study/assets/redis.html.b6990dfd.js"><link rel="prefetch" href="/study/assets/Mybatis.html.54c9cbdb.js"><link rel="prefetch" href="/study/assets/spring.html.4d1c80d9.js"><link rel="prefetch" href="/study/assets/springboot.html.6848ef75.js"><link rel="prefetch" href="/study/assets/springboot.html.548faae6.js"><link rel="prefetch" href="/study/assets/springMVC.html.3ef2320d.js"><link rel="prefetch" href="/study/assets/kafka.html.d522c391.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.f259d4ac.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.356a0fb2.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.14dc9ec5.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.c4d8dabf.js"><link rel="prefetch" href="/study/assets/404.html.8d0c0409.js"><link rel="prefetch" href="/study/assets/404.897b7b41.js"><link rel="prefetch" href="/study/assets/Layout.464dac6c.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/java/" class="router-link-active" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">操作系统 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#第一章" class="router-link-active router-link-exact-active sidebar-item" aria-label="第一章"><!--[--><!--]--> 第一章 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统的概念、功能和目标" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统的概念、功能和目标"><!--[--><!--]--> 操作系统的概念、功能和目标 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统的四个特征" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统的四个特征"><!--[--><!--]--> 操作系统的四个特征 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#并发" class="router-link-active router-link-exact-active sidebar-item" aria-label="并发"><!--[--><!--]--> 并发 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#共享" class="router-link-active router-link-exact-active sidebar-item" aria-label="共享"><!--[--><!--]--> 共享 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#虚拟" class="router-link-active router-link-exact-active sidebar-item" aria-label="虚拟"><!--[--><!--]--> 虚拟 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#异步" class="router-link-active router-link-exact-active sidebar-item" aria-label="异步"><!--[--><!--]--> 异步 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统的发展和分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统的发展和分类"><!--[--><!--]--> 操作系统的发展和分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统的运行机制和体系结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统的运行机制和体系结构"><!--[--><!--]--> 操作系统的运行机制和体系结构 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#运行机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="运行机制"><!--[--><!--]--> 运行机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统内核" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统内核"><!--[--><!--]--> 操作系统内核 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统体系结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统体系结构"><!--[--><!--]--> 操作系统体系结构 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#中断和异常" class="router-link-active router-link-exact-active sidebar-item" aria-label="中断和异常"><!--[--><!--]--> 中断和异常 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#中断机制的诞生" class="router-link-active router-link-exact-active sidebar-item" aria-label="中断机制的诞生"><!--[--><!--]--> 中断机制的诞生 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#中断的概念和作用" class="router-link-active router-link-exact-active sidebar-item" aria-label="中断的概念和作用"><!--[--><!--]--> 中断的概念和作用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#中断的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="中断的分类"><!--[--><!--]--> 中断的分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#外中断的处理过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="外中断的处理过程"><!--[--><!--]--> 外中断的处理过程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#系统调用" class="router-link-active router-link-exact-active sidebar-item" aria-label="系统调用"><!--[--><!--]--> 系统调用 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#系统调用分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="系统调用分类"><!--[--><!--]--> 系统调用分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#系统调用与库函数的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="系统调用与库函数的区别"><!--[--><!--]--> 系统调用与库函数的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#系统调用背后的过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="系统调用背后的过程"><!--[--><!--]--> 系统调用背后的过程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#第二章" class="router-link-active router-link-exact-active sidebar-item" aria-label="第二章"><!--[--><!--]--> 第二章 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程"><!--[--><!--]--> 进程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的定义" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的定义"><!--[--><!--]--> 进程的定义 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的组成" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的组成"><!--[--><!--]--> 进程的组成 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的组织方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的组织方式"><!--[--><!--]--> 进程的组织方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的特征" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的特征"><!--[--><!--]--> 进程的特征 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的状态和转换" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的状态和转换"><!--[--><!--]--> 进程的状态和转换 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程控制"><!--[--><!--]--> 进程控制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#基本概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本概念"><!--[--><!--]--> 基本概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程控制相关的原语" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程控制相关的原语"><!--[--><!--]--> 进程控制相关的原语 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程通信"><!--[--><!--]--> 进程通信 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#共享存储" class="router-link-active router-link-exact-active sidebar-item" aria-label="共享存储"><!--[--><!--]--> 共享存储 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#消息传递" class="router-link-active router-link-exact-active sidebar-item" aria-label="消息传递"><!--[--><!--]--> 消息传递 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#管道通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="管道通信"><!--[--><!--]--> 管道通信 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#线程和多线程模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程和多线程模型"><!--[--><!--]--> 线程和多线程模型 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#引入线程机制后的变化" class="router-link-active router-link-exact-active sidebar-item" aria-label="引入线程机制后的变化"><!--[--><!--]--> 引入线程机制后的变化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#线程有哪些属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程有哪些属性"><!--[--><!--]--> 线程有哪些属性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#线程的实现方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程的实现方式"><!--[--><!--]--> 线程的实现方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#多线程模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="多线程模型"><!--[--><!--]--> 多线程模型 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#处理机调度" class="router-link-active router-link-exact-active sidebar-item" aria-label="处理机调度"><!--[--><!--]--> 处理机调度 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#基本概念-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本概念"><!--[--><!--]--> 基本概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#三个层次" class="router-link-active router-link-exact-active sidebar-item" aria-label="三个层次"><!--[--><!--]--> 三个层次 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#联系" class="router-link-active router-link-exact-active sidebar-item" aria-label="联系"><!--[--><!--]--> 联系 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程调度" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程调度"><!--[--><!--]--> 进程调度 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程调度的时机" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程调度的时机"><!--[--><!--]--> 进程调度的时机 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程调度的方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程调度的方式"><!--[--><!--]--> 进程调度的方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的切换和过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的切换和过程"><!--[--><!--]--> 进程的切换和过程 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程同步、互斥" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程同步、互斥"><!--[--><!--]--> 进程同步、互斥 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#信号量机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="信号量机制"><!--[--><!--]--> 信号量机制 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#管程" class="router-link-active router-link-exact-active sidebar-item" aria-label="管程"><!--[--><!--]--> 管程 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-3" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#死锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="死锁"><!--[--><!--]--> 死锁 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-4" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程死锁、饥饿、死循环的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程死锁、饥饿、死循环的区别"><!--[--><!--]--> 进程死锁、饥饿、死循环的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#死锁产生的必要条件" class="router-link-active router-link-exact-active sidebar-item" aria-label="死锁产生的必要条件"><!--[--><!--]--> 死锁产生的必要条件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#什么时候会发生死锁" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么时候会发生死锁"><!--[--><!--]--> 什么时候会发生死锁 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#死锁的处理策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="死锁的处理策略"><!--[--><!--]--> 死锁的处理策略 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#死锁的处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="死锁的处理"><!--[--><!--]--> 死锁的处理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#不允许死锁发生" class="router-link-active router-link-exact-active sidebar-item" aria-label="不允许死锁发生"><!--[--><!--]--> 不允许死锁发生 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#允许死锁发生" class="router-link-active router-link-exact-active sidebar-item" aria-label="允许死锁发生"><!--[--><!--]--> 允许死锁发生 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#第三章" class="router-link-active router-link-exact-active sidebar-item" aria-label="第三章"><!--[--><!--]--> 第三章 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="内存"><!--[--><!--]--> 内存 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-5" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程的运行原理-指令" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程的运行原理---指令"><!--[--><!--]--> 进程的运行原理---指令 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#内存管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="内存管理"><!--[--><!--]--> 内存管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-6" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#覆盖和交换" class="router-link-active router-link-exact-active sidebar-item" aria-label="覆盖和交换"><!--[--><!--]--> 覆盖和交换 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#连续分配管理方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="连续分配管理方式"><!--[--><!--]--> 连续分配管理方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#动态分区分配算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="动态分区分配算法"><!--[--><!--]--> 动态分区分配算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#基本分页存储管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本分页存储管理"><!--[--><!--]--> 基本分页存储管理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#基本分段存储管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本分段存储管理"><!--[--><!--]--> 基本分段存储管理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#段页式管理方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="段页式管理方式"><!--[--><!--]--> 段页式管理方式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#虚拟内存" class="router-link-active router-link-exact-active sidebar-item" aria-label="虚拟内存"><!--[--><!--]--> 虚拟内存 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概念-7" class="router-link-active router-link-exact-active sidebar-item" aria-label="概念"><!--[--><!--]--> 概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#请求分页存储管理方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="请求分页存储管理方式"><!--[--><!--]--> 请求分页存储管理方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#页面置换算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="页面置换算法"><!--[--><!--]--> 页面置换算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/java/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#页面分配策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="页面分配策略"><!--[--><!--]--> 页面分配策略 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h1><h2 id="第一章" tabindex="-1"><a class="header-anchor" href="#第一章" aria-hidden="true">#</a> 第一章</h2><h3 id="操作系统的概念、功能和目标" tabindex="-1"><a class="header-anchor" href="#操作系统的概念、功能和目标" aria-hidden="true">#</a> 操作系统的概念、功能和目标</h3><ol><li><p>操作系统的概念：</p><p><img src="/study/assets/image-20211014183700023.4efb13a6.png" alt="image-20211014183700023"></p><p>操作系统是指<strong>控制和管理整个计算机系统的硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配。（要注意操作系统也要管理硬件资源，不只是管理软件资源，比如操作系统要管理软件即应用程序占用CPU等，相当于是要管理CPU，操作系统能够管理硬件，能够管理应用程序这种软件！！）</p><p><img src="/study/assets/image-20211215161802637.7b5bc03c.png" alt="image-20211215161802637"></p><p>并且操作系统给上层用户和其他应用软件提供方便的接口和环境，操作系统是计算机系统中最基本的系统软件。</p><p>操作系统负责管理和协调硬件软件资源。</p></li><li><p><strong>进程是一个程序的执行过程</strong>，<strong>执行前需要将该程序放到内存中</strong>，才能被CPU处理</p><p>放到内存中的程序，可以理解为进程。程序是静态的，就是存放在硬盘上的静态代码，就叫做程序，要让程序跑起来，需要通过CPU，或者说，需要CPU来对这个程序进行处理，即通过CPU让这段程序跑起来，那么这个程序会放到内存中，才能被CPU进行处理，也就是“跑起来”。</p></li><li><p>操作系统的功能和目标：</p><ul><li><p>操作系统作为**系统资源（硬件资源和软件资源）**的管理者：</p><ul><li><p>处理机管理</p><p>进程需要等待CPU资源的分配</p></li><li><p>文件管理</p></li><li><p>设备管理</p></li><li><p>存储器管理</p></li></ul></li><li><p>操作系统作为用户和计算机<strong>硬件</strong>之间的接口：</p><ul><li><p>命令接口</p><p>允许用户直接使用</p><ul><li>联机命令接口</li><li>脱机命令接口</li></ul></li><li><p>程序接口</p><p>允许用户通过程序间接使用</p><p><strong>系统调用</strong></p></li><li><p>GUI---图形用户界面</p><p>现代操作系统中最流行的图形系统。</p></li></ul></li><li><p>操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能：</p><p>实现对硬件机器的拓展</p><p>操作系统是软件，是系统软件。</p></li></ul></li><li><p>操作系统作为用户和计算机硬件之间的接口</p><p>用户接口</p><ul><li><p>命令接口</p><ul><li><p>联机命令接口</p><p>用户说一句，系统做一句</p><p>联机命令接口 = 交互式命令接口，例如windows系统中的命令行。</p></li><li><p>脱机命令接口</p><p>用户说一堆，系统做一堆</p><p>相当于是<strong>批处理命令接口</strong>。</p></li></ul></li><li><p>程序接口</p><p>由<strong>一组系统调用</strong>组成，<strong>只能通过用户程序间接使用。</strong></p><p>在大多数情况下，程序接口和系统调用两个名词是相等的。</p></li></ul></li></ol><h3 id="操作系统的四个特征" tabindex="-1"><a class="header-anchor" href="#操作系统的四个特征" aria-hidden="true">#</a> 操作系统的四个特征</h3><ol><li><p>操作系统有并发、共享、虚拟、异步这四个特征。</p><p>其中并发和共享是两个最基本的特征，二者互为存在条件。</p></li></ol><h4 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h4><ol><li><p>指两个或多个事件在<strong>同一时间间隔内</strong>发生，这些事件宏观上是同时发生的，但微观上是交替发生的</p><p>并行：</p><p>指两个或多个事件在同一时刻同时发生。</p></li><li><p>一个单核处理器（CPU）在同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行，这些程序微观上是交替执行的，但是在宏观上看起来像是同时执行（并行）。</p><p>这就是并发，微观上是交替执行，宏观上是并行执行，并行即同时。</p><p>所以并不是采用多线程的方式就一定执行效率更高，执行更快，<strong>因为如果是单核CPU，那么在微观上仍然是并发执行，交替执行的，并不是真正意义上的并行执行</strong>，如果单核CPU采用多线程执行任务的方式，还存在线程的上下文切换，系统的资源限制和死锁等问题，造成多线程反而比单线程更慢。</p><p>如果是多核CPU那么， 多线程在微观上才是真正意义上的并行执行。</p><p>CPU密集型，那么并不是线程越多越好，因为相当于并不存在CPU会空闲的状况，所以线程数等于CPU核心数就可以，如果是IO密集型，那么就会出现大量CPU空闲的时间，为了提高CPU的执行效率，可以采用更多的线程数（CPU核心数的两倍）。</p></li><li><p>即使有多核CPU，但是操作系统的并发性依然必不可少！！除非有多少核心，就只有多少任务数，那么就只需要多少个线程就能处理了，达到真正的并行，但是任务数或者线程数比核心多是很常见的情况。（在这种场景下，将线程和任务认为是一个东西是没有问题的，在Java线程池的部分，线程和任务不要认为是一个东西，任务本质是实现了Runnable或者说Callable接口的实现类对象，任务是要交给线程来执行的，如果线程达到核心线程数量的最大值，那么会去检查任务阻塞队列是否满，如果未满，则新任务会添加进阻塞队列，如果已满，再检查此线程池的最大线程数，如果未达到最大线程数，将此任务交给非核心线程执行，非核心线程是有存活时间的，如果已达到最大线程数，说明没有多的线程能够执行此任务，那么会执行拒绝策略。）</p></li><li><p>CPU有4个核心，意味着可以并行地执行4个任务，但是计算机同时运行超过4个任务的情况是存在的。所以并发必不可少，也就是微观上的并发执行，任务并发地占用CPU资源这种情况必不可少。</p></li></ol><h4 id="共享" tabindex="-1"><a class="header-anchor" href="#共享" aria-hidden="true">#</a> 共享</h4><ol><li><p>共享即资源共享，分为同时共享和互斥共享。</p><p>共享是指系统中的资源可供内存中多个并发执行的进程共同使用。</p></li><li><p>互斥共享：</p><p>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>使用QQ和微信视频，同一时间段内摄像头只能分配给其中一个进程。</p><p>同时共享：</p><p>系统中的某些资源，允许一个时间段内多个进程“同时”对他们进行访问（宏观上是同时的）</p><p>所谓的同时往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的。微观上交替就是并发。（同时共享，微观上多个进程可能是真的同时访问资源）</p></li><li><p>并发性是指计算机系统中同时存在着多个运行着的程序，这些程序在微观上是由CPU交替执行的（比如单核cpu，但是采用多线程的方式执行任务，那么就会出现微观上并发，宏观上并行）</p><p><strong>共享性是指进程可以同时访问系统资源</strong>，可以是一段时间段内只有一个进程能够访问，这叫互斥共享，可以是一段时间端内多个进程同时访问，这是同时共享。</p><p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</p><p>如果失去共享性，则多个进程不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。</p><p>所以共享性和并发性是相互依存的。</p></li></ol><h4 id="虚拟" tabindex="-1"><a class="header-anchor" href="#虚拟" aria-hidden="true">#</a> 虚拟</h4><ol><li><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的。</p><p>虚拟技术中的空分复用技术---虚拟存储器技术</p><p><img src="/study/assets/image-20211029171246758.f68d1488.png" alt="image-20211029171246758"></p></li><li><p>虚拟技术的时分复用技术---虚拟处理器技术</p><p><img src="/study/assets/image-20211029171359873.9494cbf9.png" alt="image-20211029171359873"></p><p>处理器把大的时间段分为各个很小的时间片，通过时间片轮转的机制，交替为各个进程服务，这是时分复用技术，也就是虚拟处理器技术，而空分复用技术是虚拟存储器技术。</p></li><li><p>显然，如果失去了并发性，则一个时间段内系统只需运行一道程序，那么就失去了实现虚拟性的意义了，<strong>因此没有并发性就谈不上虚拟性。</strong></p></li></ol><h4 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> 异步</h4><ol><li><p>异步是指，在多道程序环境下，允许多个程序<strong>并发</strong>执行，但由于系统资源有限，进程的执行不是一贯到底的，而是走走停停，以<strong>不可预知</strong>的速度向前推进，这就是进程的异步性。</p><p>因为并发，因为共享，多个进程同时访问某个系统资源，所以异步，不可预知的速度推进，如果同步，那么一个进程访问完此系统资源之后，才能另一个进程访问这个系统资源，接着下一个进程，这就是同步，速度是可预知的，没有共享性，没有并发，一个执行完之后下一个才执行。（这里的系统资源可以理解为CPU时间片。）</p><p><strong>显然，如果失去了并发性，那么系统只能串行地处理各个进程，虽然因为并发，进程在微观上仍然是被CPU串行处理的，但是有上下文切换，有程序计数器保存下一条字节码指令的执行地址，并不是一个进程完全执行完之后才会执行另一个进程，这涉及到CPU对多线程的执行策略，比如时间片轮转机制。但是串行就指的是一个进程执行完之后再执行另一个进程。</strong></p><p>只有系统拥有并发性，那么虚拟，共享，异步才有意义。因为正是因为并发性，使得共享性有意义，对系统资源的共享（比如CPU时间片），同时由于系统资源的限制，导致多个进程是走走停停（微观上仍是串行，但是是通过上下文切换），以不可预知的速度向前推进，导致了异步性。</p><p>如果没有并发性，那么就是某个进程完全执行完之后（因为没有并发性！！），执行下一个进程，这就是同步的，不可能会导致异步性。一个进程的执行必须完全等上一个进程完全执行完之后才可以执行，因为没有并发，意味着没有<strong>宏观上的并行执行</strong>，必须一个接一个。</p></li><li><p>如果进程由于没有获得某个需要的系统资源，导致进程无法执行，则进程会阻塞，直到获得系统资源，进程被唤醒，<strong>进入就绪状态</strong>，获得CPU时间片之后，进程继续执行。</p></li><li><p>没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统两个最基本的特征。</p></li></ol><h3 id="操作系统的发展和分类" tabindex="-1"><a class="header-anchor" href="#操作系统的发展和分类" aria-hidden="true">#</a> 操作系统的发展和分类</h3><ol><li><p>计算机可以识别的是二进制的机器码，计算机只能之别0和1二进制数。</p></li><li><p>OS的发展和分类</p><p><img src="/study/assets/image-20211215180652752.65913121.png" alt="image-20211215180652752"></p></li><li><p>手工操作阶段</p><p>主要缺点：用户独占全机，人机速度矛盾导致资源利用率低。</p></li><li><p>单道批处理系统</p><p>引入脱机输入、输出技术（用磁带完成），并监督程序负责控制作业的输入、输出。</p><p>主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后，才能调入下一道程序，CPU有大量的时间是在空闲等待IO完成，资源利用率依旧很低。从这里可以看出，单道批处理系统的缺点就是不采用多线程的缺点或者说是系统不能并发执行进程，只能串行执行进程的缺点，导致CPU大量时间处于空闲状态，因为线程或者说进程正在执行IO操作，那么会阻塞，此时CPU处于空闲状态，因为进程或者线程阻塞了，CPU不能去执行别的线程或者进程或者任务，因为，串行执行！！所以要采用多线程，或者说要多线程的好处、并发执行程序的好处，就是让提高CPU的利用率，以免当某个进程IO阻塞的时候，CPU能够执行另一个进程或线程而不是处于空闲状态，提高了利用率，提高了系统的吞吐量。</p></li><li><p>多道批处理系统</p><p>主要优点：多道程序并发执行，共享计算机资源，资源利用率大幅提升，<strong>CPU和其他资源保持忙碌状态</strong>，提高了CPU执行效率，系统吞吐量增大。<strong>这就和前面说的单线程的缺点相对应，如果是单线程执行任务，如果执行了IO并阻塞，那么线程阻塞，CPU也只有跟着等待，如果是多线程，CPU可以把时间片分给别的线程，去执行别的任务，提高CPU的执行效率，不让CPU空闲等待，增大了系统吞吐量</strong>。</p><p>Redis是采用单线程，就是因为redis所有操作都在内存范围内，不涉及内存和磁盘之间的IO，所以不存在线程会由于IO而阻塞的情况，CPU也不会因为线程阻塞而等待，也不需要多线程来提高系统的吞吐量。</p></li><li><p>单道批处理技术</p><p><img src="/study/assets/image-20211029181727331.9869c6f9.png" alt="image-20211029181727331"></p><p>多个程序串行执行，串行工作。</p><p>多道批处理技术是多道程序<strong>并发执行</strong>。（但是并不是时间片轮转，而是一个进程的某项任务执行完之后，CPU再去执行另一个进程。）</p><p><img src="/study/assets/image-20211029181850429.314094bd.png" alt="image-20211029181850429"></p><p>使系统资源利用率大幅度提升</p><p>不同进程在各自的某些阶段，能够进行并行的工作，所以提高了系统资源利用率。</p></li><li><p>分时（时间片）操作系统：</p><p><strong>计算机以时间片为单位轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互</p><p>主要缺点：</p><p>不能优先处理一些紧急任务，操作系统对各个用户/作业是完全公平的，循环地位每个用户/作业服务一个时间片，不区分任务的紧急性。（在这种场景下，任务和线程可以理解为同样的。）</p></li><li><p>实时操作系统：</p><p>优点：能够优先响应一些紧急任务，<strong>某些紧急任务不需时间片排队。</strong></p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p><p>硬实时系统：必须在绝对严格的规定时间内完成处理</p><p>软实时系统：能接收偶尔违反时间规定。</p></li><li><p><img src="/study/assets/image-20211029182506414.7323c9a9.png" alt="image-20211029182506414"></p></li></ol><h3 id="操作系统的运行机制和体系结构" tabindex="-1"><a class="header-anchor" href="#操作系统的运行机制和体系结构" aria-hidden="true">#</a> 操作系统的运行机制和体系结构</h3><h4 id="运行机制" tabindex="-1"><a class="header-anchor" href="#运行机制" aria-hidden="true">#</a> 运行机制</h4><ol><li><p>指令：</p><p>特权指令：如内存清零指令，不允许用户程序使用</p><p>非特权指令：如加减乘除指令</p><blockquote><p>问题：CPU如何判断当前是否是可以执行特权指令？</p><p>就是通过CPU的状态，CPU有两种状态，用户态和核心态。</p></blockquote></li><li><p>高级语言代码需要经过“翻译”得到机器语言指令或者说机器码，这是计算机能够识别的二进制码。这个过程在Java中是编译，但是不完全等同，因为Java是在JVM基础上运行，Java这种高级语言首先需要经过编译得到字节码文件，字节码也是二进制码，但是不等同于机器码。</p><p>字节码虽然是二进制的，字节码文件是二进制文件，但是字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于能够被CPU所识别的机器指令（机器码），字节码文件内部包含的仅仅是一些能够被JVM识别的字节码指令、符号表，以及其他辅助信息</p><p><strong>那么，想让一个Java程序运行起来，JVM中执行引擎的任务就是将字节码指令解释、编译成为对应平台上的本地机器指令才可以，简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者</strong></p><p>执行引擎部分有JIT即时编译器，还有解释器，还有垃圾回收器，其中解释器就是解释字节码指令并执行，JIT即时编译器就是将字节码指令再翻译成机器指令或者说机器码，这个机器指令是能够被计算机、CPU、或者说操作系统识别的二进制码（虽然字节码是二进制码，但是不能被操作系统识别，是能够被JVM识别，这是Java编程语言的特性），JIT即时编译器的作用就是将字节码翻译成机器码，这是一个二次编译的过程，也就是说第一次编译是从Java高级语言到字节码文件，第二次编译是在JVM的执行引擎，将字节码翻译成机器码。</p></li><li><p>一条高级语言的代码翻译过来可能回对应多条指令</p><p><img src="/study/assets/image-20211215204419631.e91c517f.png" alt="image-20211215204419631"></p><p>简单来说，“指令”就是处理器（CPU）或者广义上说操作系统能识别、执行的最基本指令。</p><p>比如：加法指令就是让CPU进行加法运算</p></li><li><p><strong>两种处理器状态：</strong></p><p><strong>用户态（目态）：此时CPU只能执行非特权指令</strong></p><p><strong>核心态（管态）：此时CPU可以执行特权指令和非特权指令</strong></p><p>用程序状态字寄存器PSW中某标志位来标识当前处理器处于什么状态，如0为用户态，1为核心态。</p><p>有的程序需要使用特权指令，有的程序只能使用非特权指令。</p></li><li><p>两种程序：</p><p>内核程序：<strong>操作系统的内核程序是系统的管理者</strong>，既可以执行特权指令，也可以执行非特权指令，<strong>运行在核心态。</strong></p><p>应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。</p></li></ol><h4 id="操作系统内核" tabindex="-1"><a class="header-anchor" href="#操作系统内核" aria-hidden="true">#</a> 操作系统内核</h4><ol><li><p><img src="/study/assets/image-20211031173518958.988c29b3.png" alt="image-20211031173518958"></p><p>特权指令需要在核心态执行</p><p>非特权指令既可以在核心态执行，也可以在用户态执行</p><p>需要使用特权指令的程序称为内核程序</p><p>只能使用非特权指令的程序称为应用程序</p></li><li><p>操作系统最接近硬件的层次是操作系统内核</p><p>另一部分是非内核功能，所以可以把操作系统分为<strong>内核功能和非内核功能</strong></p><p><img src="/study/assets/image-20211215205340442.ef194827.png" alt="image-20211215205340442"></p><p>原语是一种特殊的程序，是最接近硬件的部分，这种程序的运行具有原子性。</p></li><li><p>内核是计算机上配置的底层软件（操作系统本身是系统软件，又分为内核和非内核两部分），是操作系统最基本最核心的部分，而<strong>实现操作系统内核功能的程序就是内核程序。</strong></p><p><img src="/study/assets/image-20211031180947464.888e2f2b.png" alt="image-20211031180947464"></p></li></ol><h4 id="操作系统体系结构" tabindex="-1"><a class="header-anchor" href="#操作系统体系结构" aria-hidden="true">#</a> 操作系统体系结构</h4><ol><li><p>有的操作系统并不把对系统资源进行管理的功能划分为内核功能</p><p>如果把对系统资源进行管理（处理器管理、存储器管理、设备管理、文件管理）的功能也划分为内核功能，则称这个内核是大内核</p><p>如果不把系统资源管理功能划分为内核功能，则称内核是微内核。</p></li><li><p><img src="/study/assets/image-20211031181418067.5a481bec.png" alt="image-20211031181418067"></p><p><strong>大内核的优点就是性能高，主要功能模块都运行在核心态，减少了处理器在核心态和用户态之间的切换！</strong></p><p><strong>微内核：核心态只负责最核心的一些工作，优点是组织结构清晰，方便维护，缺点是效率低，因为微内核，并不是许多主要功能模块都在核心态，所以需要经常进行核心态和用户态之间的切换，导致效率低。</strong></p></li><li><p>操作系统内核功能或者说内核程序一定是运行在核心态。</p></li><li><p>特权指令只能在核心态下执行</p><p>内核程序只能在核心态下执行</p></li></ol><h3 id="中断和异常" tabindex="-1"><a class="header-anchor" href="#中断和异常" aria-hidden="true">#</a> 中断和异常</h3><h4 id="中断机制的诞生" tabindex="-1"><a class="header-anchor" href="#中断机制的诞生" aria-hidden="true">#</a> 中断机制的诞生</h4><ol><li><p>早期的计算机中，各个程序只能串行执行，就是单道批处理系统，同一时刻，处理器只能处理一道程序，系统资源利用率低</p><p>引入中断机制，实现了<strong>多道程序并发执行</strong></p><p><strong>本质：发生中断就意味着需要操作系统介入，开展管理工作</strong></p></li><li><p>CPU切换为核心态，对中断信号进行处理</p><p>处理完后，再切换为用户态，执行进程</p></li><li><p>CPU可能会收到计时部件发送的中断信号，通知CPU现在已经过了一个时间片了，当CPU收到中断信号，那么CPU会立即切换到核心态（用户态和核心态是说的CPU状态），<strong>然后把CPU的使用权限交给操作系统</strong>，操作系统的内核就会开始对中断信号进行处理，操作系统内核发现刚才的中断信号是告诉CPU时间片已到，那么操作系统会进行进程1和进程2之间的切换，进程1的时间片用完，换进程2执行，在完成这一系列的管理工作后，操作系统会把CPU的使用权交给用户进程，接下来进程2就会获得CPU时间片，CPU也由核心态切换回了用户态，进程2在用户态下进行执行。</p><p><img src="/study/assets/image-20211215211612977.f3cb5031.png" alt="image-20211215211612977"></p><p><img src="/study/assets/image-20211215211627172.d00c80da.png" alt="image-20211215211627172"></p><p><img src="/study/assets/image-20211215211657088.0409777d.png" alt="image-20211215211657088"></p><p><img src="/study/assets/image-20211215211713943.33acc316.png" alt="image-20211215211713943"></p><p><img src="/study/assets/image-20211215211752899.4cbb24af.png" alt="image-20211215211752899"></p><p>​ 进程2在用户态下执行</p></li></ol><h4 id="中断的概念和作用" tabindex="-1"><a class="header-anchor" href="#中断的概念和作用" aria-hidden="true">#</a> 中断的概念和作用</h4><ol><li><p><strong>当中断发生时，CPU会立即进入核心态</strong></p><p>当中断发生后，<strong>当前运行的进程暂停运行</strong>，<strong>并由操作系统的内核对中断信号进行处理</strong></p><p>对于不同的中断信号，会进行不同的处理</p><p>发生中断，由于操作系统的管理工作（比如进程切换、分配IO设备等）需要使用特权指令，因此CPU要从用户态转为核心态。</p><p>中断可以使CPU从用户态切换为核心态，<strong>使操作系统获取计算机的控制权</strong>，有了中断，才能实现多道程序并发执行。</p></li><li><p><strong>CPU用户态--核心态是通过中断实现的， 并且中断是唯一途径</strong></p><p>核心态到用户态的切换，是通过执行一个特权指令（因为核心态下本来就可以执行特权指令），将程序状态字的标志位设置为用户态</p></li></ol><h4 id="中断的分类" tabindex="-1"><a class="header-anchor" href="#中断的分类" aria-hidden="true">#</a> 中断的分类</h4><ol><li><p>内中断（异常、例外、陷入）</p></li><li><p>外中断，也可以简单地称之为中断</p></li><li><p>内中断和外中断的本质区别在于中断信号的来源是CPU的内部还是外部</p><p><strong>内中断的发生和当前CPU执行指令是有关系的，外中断的发生和当前CPU执行指令是没有关系的（比如说打印机在完成输出工作之后，向CPU发送的外部中断信号）。</strong></p></li><li><p><img src="/study/assets/image-20211031192224702.3b36d805.png" alt="image-20211031192224702"></p></li><li><p>另一种分类方式</p><p><img src="/study/assets/image-20211031192325361.53fd4544.png" alt="image-20211031192325361"></p></li></ol><h4 id="外中断的处理过程" tabindex="-1"><a class="header-anchor" href="#外中断的处理过程" aria-hidden="true">#</a> 外中断的处理过程</h4><ol><li>执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li><li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器），可以大致理解为要保存进程当前的一些中间结果，以便恢复之后，还可以从当前状态继续往下执行，可以理解为多线程环境下线程之间的上下文切换，程序计数器的作用就是保存下一条要执行的字节码指令的地址，<strong>所以程序计数器需要保存这个地址，用于上下文切换。</strong></li><li>根据中断信号类型转入相应的中断处理程序（内核程序，运行在CPU核心态，这是肯定的，因为中断发生时，CPU会立即进入核心态）</li><li>恢复原进程的CPU环境并<strong>执行特权指令退出中断（设置程序状态字PSW的标志位）</strong>，返回原进程继续往下执行。</li></ol><h3 id="系统调用" tabindex="-1"><a class="header-anchor" href="#系统调用" aria-hidden="true">#</a> 系统调用</h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h4><ol><li><p>操作系统作为系统软件，管理系统资源，面向上层，对用户提供命令接口，对程序提供程序接口（其实也可以理解为对用户），<strong>程序接口就是一组系统调用组成</strong></p><p>可以把系统调用理解为操作系统提供给应用程序（程序员或编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来<strong>获得操作系统的服务</strong>。</p></li><li><p>操作系统为什么要提供系统调用功能？</p><p><strong>如果用户进程想要使用系统资源，那么通过操作系统提供的系统调用，比如用户继承想要使用打印机这种共享资源，只能通过系统调用对操作系统发出请求，操作系统会对各个请求进行协调管理</strong></p><p><strong>系统调用就是程序接口，用户进程通过一组系统调用即程序接口，使用某个系统资源，因为是系统资源，所以系统调用后，CPU进入核心态，把控制权交给操作系统，操作系统对请求进行协调管理</strong></p><p>系统调用后，CPU会进入核心态，这是自愿中断，也就是内中断，与CPU当前执行的指令有关，是系统调用使用的访管指令或者陷入指令。</p></li><li><p>什么是系统调用？</p><p>应用程序通过系统调用请求操作系统的服务，系统中的各种共享资源都由操作系统同一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、IO、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成（系统调用后，CPU会进入核心态，系统调用会使用访管指令或者说陷入指令），因为操作系统就是管理系统资源的，包括硬件资源和软件资源，这样可以保证系统的稳定性和安全性。</p></li></ol><h4 id="系统调用分类" tabindex="-1"><a class="header-anchor" href="#系统调用分类" aria-hidden="true">#</a> 系统调用分类</h4><ol><li><p><img src="/study/assets/image-20211031215805004.8d0b092e.png" alt="image-20211031215805004"></p><p><strong>系统调用相关处理涉及到对系统资源的管理，对进程的控制，这些功能需要执行一些特权指令，因此系统调用相关处理需要在核心态下进行。</strong></p></li></ol><h4 id="系统调用与库函数的区别" tabindex="-1"><a class="header-anchor" href="#系统调用与库函数的区别" aria-hidden="true">#</a> 系统调用与库函数的区别</h4><ol><li><p>库函数的底层封装一些系统调用功能</p><p><img src="/study/assets/image-20211215214453318.6e3e232d.png" alt="image-20211215214453318"></p><p><img src="/study/assets/image-20211031220400682.266353ab.png" alt="image-20211031220400682"></p><p><img src="/study/assets/image-20211031220438631.62f1566d.png" alt="image-20211031220438631"></p></li></ol><h4 id="系统调用背后的过程" tabindex="-1"><a class="header-anchor" href="#系统调用背后的过程" aria-hidden="true">#</a> 系统调用背后的过程</h4><ol><li><p><img src="/study/assets/image-20211031220738705.bd7c0b7f.png" alt="image-20211031220738705"></p><p>write这个库函数，就涉及到了系统调用。</p><p>当执行陷入指令之后，CPU的控制权会交给操作系统，陷入指令就是访管指令，核心态就是管态。这属于系统调用，执行陷入指令，是内中断。</p><p>很好理解，系统调用，就是会通过操作系统来执行一些功能，必定会进入核心态，而用户态到核心态只有一种方式，就是中断，系统调用会通过访管指令，实现内中断。</p><p>内中断分为自愿中断（也叫做指令中断，也就是系统调用时使用的访管指令）、硬件故障（缺页）、软件中断</p><p>内终端又分为陷入、故障和终止。</p><p>自愿中断（访管指令引起的指令中断）属于陷入，缺页属于故障，软件中断比如整数除0属于终止。</p></li><li><p>int指令的参数x指明了系统的调用号，此处的int不是整数的意思，其实是interrupt的缩写</p><p><img src="/study/assets/image-20211215215539484.38057c74.png" alt="image-20211215215539484"></p><blockquote><p>传递系统调用参数 ----&gt; 执行陷入指令（用户态）------&gt; 执行系统调用相应服务程序（核心态）-----&gt; 返回用户程序</p></blockquote><p><strong>系统调用会使用访管指令（陷入指令），从而使CPU切换到核心态</strong></p></li><li><p>注意：</p><ul><li>陷入指令是在用户态执行的，执行陷入指令之后，立即引发一个内中断，这属于自愿中断，从而CPU进入核心态</li><li><strong>发出系统调用请求是在用户态，而对系统调用的相应处理，是在核心态下进行。</strong></li><li>陷入指令是唯一一个只能在用户态执行，而不可再核心态执行的指令。因为陷入指令即访管指令的目的就是进入核心态。</li><li>凡是与资源（系统资源、共享资源）有关的操作、会直接影响到其他进程的操作，一定需要操作系统介入（需要操作系统来调度，来对请求协调管理），即需要通过系统调用来实现。</li></ul></li></ol><h2 id="第二章" tabindex="-1"><a class="header-anchor" href="#第二章" aria-hidden="true">#</a> 第二章</h2><h3 id="进程" tabindex="-1"><a class="header-anchor" href="#进程" aria-hidden="true">#</a> 进程</h3><h4 id="进程的定义" tabindex="-1"><a class="header-anchor" href="#进程的定义" aria-hidden="true">#</a> 进程的定义</h4><ol><li><p>程序：就是一个指令序列</p><p>早期的计算机（只支持单道程序），因此在计算机中，同一时间段内只能有一道程序，在这段时间段内，CPU只为这道程序服务</p><p>内存中同一个时间段内只存在一个程序相关的数据，包括程序段和数据段两个部分，程序段保存的是代码本身，数据段存放的是程序运行过程中的中间数据</p><p><img src="/study/assets/image-20211215221112255.a5b6c596.png" alt="image-20211215221112255"></p></li><li><p>引入多道程序技术之后</p><p><img src="/study/assets/image-20211215221415179.b796c345.png" alt="image-20211215221415179"></p><p>为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念</p><p><strong>操作系统为每个运行的程序（进程）配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息（如程序代码存放位置、进程的状态）</strong></p><p><strong>PCB、程序段、数据段三部分构成了进程实体（进程映像）</strong></p></li><li><p>一般情况下，我们把进程实体就简称为进程，<strong>例如，所谓创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB</strong></p><p>注意：PCB是进程存在的唯一标志。</p></li><li><p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有：</p><ul><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理器上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ul><p>所有的定义都强调进程是一个动态的过程</p></li><li><p>引入进程实体的概念后，可把进程定义为：</p><p>进程是进程实体（或者说静态程序）的运行过程，是系统进行资源分配和调度的一个独立单位。</p><p>注意：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的</p></li></ol><h4 id="进程的组成" tabindex="-1"><a class="header-anchor" href="#进程的组成" aria-hidden="true">#</a> 进程的组成</h4><ol><li><p><strong>进程（进程实体）由程序段、数据段、PCB三部分组成</strong></p><p><img src="/study/assets/image-20211215222440380.2496d5e4.png" alt="image-20211215222440380"></p></li><li><p>PCB的组成</p><p><img src="/study/assets/image-20211215222506062.02ebf46b.png" alt="image-20211215222506062"></p><p>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程。</p><p>当进程切换时，需要把进程当前的运行情况记录下来，保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句。（在jvm中，程序计数器保存了下一条需要执行的字节码指令对应的地址！！）</p><p><strong>进程的管理者（操作系统）所需的数据都在PCB中！！</strong></p><p>程序段和数据段存放的是程序本身的运行所需的数据</p></li></ol><h4 id="进程的组织方式" tabindex="-1"><a class="header-anchor" href="#进程的组织方式" aria-hidden="true">#</a> 进程的组织方式</h4><ol><li><p>在一个系统中，通常有数十、数百乃至数千个PCB（进程控制块，描述进程的各种信息），为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来</p><p>进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式的问题。</p></li><li><p><img src="/study/assets/image-20211216150358099.5ddfed10.png" alt="image-20211216150358099"></p></li><li><p>进程的组织---链接方式（操作系统持有指针，指向不同队列）</p><p>执行指针指向当前处于运行态（执行态）的进程</p><p>就绪队列指针，指向当前处于就绪态的进程</p><p>阻塞队列指针，指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列</p><p><img src="/study/assets/image-20211216150733591.04d9ba5c.png" alt="image-20211216150733591"></p></li><li><p>进程的组织---索引方式（操作系统持有指针，指向索引表，而不是队列）</p><p><img src="/study/assets/image-20211216150812905.81a73c96.png" alt="image-20211216150812905"></p><p>注意：链接方式，是指针指向队列，索引方式，是指针指向索引表</p></li></ol><h4 id="进程的特征" tabindex="-1"><a class="header-anchor" href="#进程的特征" aria-hidden="true">#</a> 进程的特征</h4><ol><li><p>进程和程序是两个截然不同的概念，相比于程序，进程拥有以下特征：</p><ul><li><p>动态性：进程是程序的一次执行过程，是<strong>动态</strong>地产生、变化、消亡的。（动态性也是进程最基本的特征）</p></li><li><p>并发性：内存中有多个进程实体（映像），各进程可并发执行（并发就是宏观上并行，微观上串行，轮流被CPU执行，但是在宏观上，各进程好像是并行执行的。 ）</p></li><li><p>独立性：进程是能独立运行、独立获得资源，独立接受调度的基本单位</p></li><li><p>异步性：各进程按各自独立的、不可预知的速度向前推进（因为并发性，不是被CPU完全串行执行的，所以推进的速度是未知的），操作系统要提供“进程同步机制”来解决异步问题。</p><p>异步性有可能导致运算结果的不确定性，所以需要依靠同步机制。</p></li><li><p>结构型：每个进程（进程实体）会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成</p></li></ul></li><li><p>在Java中，进程是作为资源分配的最小单位，线程才是接受调度的最小单位。</p><p>对于操作系统来说，进程是资源分配和操作系统调度的一个独立单位</p></li><li><p>PCB是操作系统为了管理进程所创建的数据结构，PCB存放的数据是对进程的管理数据</p></li></ol><h4 id="进程的状态和转换" tabindex="-1"><a class="header-anchor" href="#进程的状态和转换" aria-hidden="true">#</a> 进程的状态和转换</h4><h5 id="进程的状态" tabindex="-1"><a class="header-anchor" href="#进程的状态" aria-hidden="true">#</a> 进程的状态</h5><ol><li><p>进程是程序的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化，为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p></li><li><p>三种基本状态</p><ul><li><p>运行态---占有CPU，并在CPU上运行。注意：单核处理机环境下，每一个时刻最多只有一个进程处于运行态（双核环境下，可以同时有两个进程处于运行态<strong>即在微观上也是并行的</strong>，单核的话，如果有多个进程，那么在微观上就是串行执行的，在宏观上是并行的。）</p></li><li><p>就绪态---<strong>已经具备运行条件，但是由于没有空闲CPU，而暂时不能运行</strong>。<strong>处于就绪态的进程，已经拥有了除处理器之外所有需要的资源，一旦获得处理器，即可立即进入运行态开始运行，即万事具备，只欠CPU</strong></p></li><li><p>阻塞态---因等待某一事件，而暂时不能运行（不是在等待CPU，而是等待除了CPU之外的其他事件，如果只是等待CPU，那么是就绪态）。如等待操作系统分配打印机、等待读磁盘操作的结果等，这些IO操作使得此进程阻塞，此进程必须等待IO操作完成，此时CPU处于空闲状态（这也是多线程或者说多任务的意义，在某个线程因为IO操作而阻塞的适合，不至于让CPU处于空闲状态而导致CPU利用率很低和系统吞吐量很低，如果采用多线程，这种情况下，CPU可以在某个线程因为IO操作而阻塞的时候，不处于空闲状态，而去执行其他线程，提高系统吞吐量）。</p><p>CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将进程需要的其他资源分配到位，才能得到CPU的服务，也就是说，处于阻塞态的进程，是还没有获得除了CPU之外的其他资源。如果获得了除了CPU以外的其他资源，只差CPU，那么这个进程会处于就绪态。</p><p>获得了CPU以外的其他所有需要的资源，会从阻塞态到就绪态，相当于Java中被唤醒！！</p></li></ul></li><li><p>进程的另外两种状态</p><ul><li>创建态（NEW，新建态）：进程正在被创建，操作系统为进程分配内存空间等系统资源，初始化PCB</li><li>终止态（TERMINATED）：进程正在从系统中撤销，操作系统会回收进程所拥有的资源、撤销PCB</li></ul></li></ol><h5 id="进程状态的转换" tabindex="-1"><a class="header-anchor" href="#进程状态的转换" aria-hidden="true">#</a> 进程状态的转换</h5><ol><li><p><img src="/study/assets/image-20211216153719194.83e97c30.png" alt="image-20211216153719194"></p><p>注意：不能由阻塞态直接转换为运行态（必须先转换为就绪态），也不能由就绪态直接转换为阻塞态（因为进程进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。）</p></li><li><p><img src="/study/assets/image-20211216154057426.f1008fb7.png" alt="image-20211216154057426"></p></li></ol><h3 id="进程控制" tabindex="-1"><a class="header-anchor" href="#进程控制" aria-hidden="true">#</a> 进程控制</h3><h4 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h4><ol><li><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换比如阻塞、唤醒等功能。</p><p>简化理解：<strong>反正进程控制就是要实现进程状态转换</strong></p><p><img src="/study/assets/image-20211216155307167.8c37033c.png" alt="image-20211216155307167"></p></li><li><p>如何实现进程控制？</p><p><img src="/study/assets/image-20211216155950660.ac79009c.png" alt="image-20211216155950660"></p></li><li><p>PCB所处的队列和PCB里的状态标志一定要是对应的，一致的，不然会产生系统错误，于是采用原语来实现进程控制，实现进程状态的转换，原语可以理解为一气呵成。</p></li></ol><h4 id="进程控制相关的原语" tabindex="-1"><a class="header-anchor" href="#进程控制相关的原语" aria-hidden="true">#</a> 进程控制相关的原语</h4><ol><li><p>用原语实现进程控制，原语的特点是执行期间不允许中断，只能一气呵成</p><p>这种不可被中断的操作即原子操作</p><p>原语采用“关中断指令”和“开中断指令”实现</p><p><img src="/study/assets/image-20211216160414267.51749244.png" alt="image-20211216160414267"></p><p><strong>显然，关、开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p><p><strong>原语也是只能运行在核心态的。</strong></p></li><li><p>进程控制会导致进程状态的转换</p><p>无论哪个原语，要做的无非是三类事情：</p><ul><li>更新PCB中的信息（如修改PCB中的进程状态标志，将运行环境保存到PCB，从PCB恢复进程运行环境） <ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必须需要保存其运行环境，以进行上下文切换</li><li>某进程开始运行前必然要恢复其运行环境即上下文切换</li></ul></li><li><strong>将PCB插入合适的队列</strong>，所插入的队列要与PCB里的信息保持一致，所以要通过原语来实现进程控制</li><li>分配、回收资源，比如进程TERMINATED之后，需要回收内存这种系统资源！！ 当然可能还有这个进程执行所需要的其他资源</li></ul></li><li><p><img src="/study/assets/image-20211216161206697.38f8245b.png" alt="image-20211216161206697"></p><p><img src="/study/assets/image-20211216161225780.0fa92fb5.png" alt="image-20211216161225780"></p><p><img src="/study/assets/image-20211216161549508.a5e9150e.png" alt="image-20211216161549508"></p><p><img src="/study/assets/image-20211216161628062.00af5f0e.png" alt="image-20211216161628062"></p><p>注意：一定要注意，进程转换到运行态，一定要恢复进程运行环境，如果进程从运行态转换到阻塞态，那么要保护进程运行环境，进程运行环境保存到PCB。</p><p>进程转换到阻塞态，是主动动作，所以一定是运行态---阻塞态，因为是进程主动申请的，从阻塞态是转换到就绪态，这个过程无需恢复进程运行环境，当进程从就绪态转换到运行态时，需从PCB恢复进程运行环境。</p></li></ol><h3 id="进程通信" tabindex="-1"><a class="header-anchor" href="#进程通信" aria-hidden="true">#</a> 进程通信</h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h4><ol><li><p><strong>进程通信指的就是进程之间的信息交换</strong></p><p>进程是资源分配的基本单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间</p><p>但是进程之间的信息交换又是必须实现的，比如说使用应用程序的时候的分享功能，将一个进程的数据信息和另一个进程进行通信，所以需要进程之间的通信</p><p>为了保证进程间的安全通信，操作系统提供了一些方法---共享存储、消息传递和管道通信</p></li></ol><h4 id="共享存储" tabindex="-1"><a class="header-anchor" href="#共享存储" aria-hidden="true">#</a> 共享存储</h4><ol><li><p><strong>两个进程不能直接访问对方的地址空间，所以操作系统会为两个进程分配一个共享空间，两个进程之间的通信就通过这个共享空间来完成。</strong></p><p><strong>但是这两个进程对共享空间的访问必须是互斥的</strong>，这就是前面提到的互斥共享</p><p>互斥共享就是系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p></li><li><p>互斥访问，一般是通过操作系统提供的工具实现的，操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p></li><li><p>共享存储（共享空间）分为两种</p><ul><li><p>基于数据结构的共享</p><p>共享空间中只能存放一种固定的数据结构，比如共享空间里只能放一个长度为10的数组，那么两个进程之间的通信，每一次只能通过这个长度为10的数组，这种共享方式速度慢、限制多，是一种低级通信方式。</p></li><li><p>基于存储区的共享</p><p>操作系统只负责为通信的进程提供存储空间，在内存中画出一块共享存储区，但是在这个共享空间中，<strong>两个进程交换的数据是什么形式，存放的位置都是由进程控制，而不是操作系统</strong>，相比之下，这种共享方式速度更快，是一种高级通信方式（相当于是说不会收到那么多限制）。</p></li></ul></li></ol><h4 id="消息传递" tabindex="-1"><a class="header-anchor" href="#消息传递" aria-hidden="true">#</a> 消息传递</h4><ol><li><p>进程间的数据交换以格式化的消息为单位，进程通过操作系统提供的“发送消息/接收消息”<strong>两个原语</strong>进行数据交换。</p><p>一个格式化的消息会包含消息头和消息体两个部分</p><p>消息头包括：发送进程ID，接收进程ID，消息类型，消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p><p><img src="/study/assets/image-20211216171359712.f4475b6b.png" alt="image-20211216171359712"></p></li><li><p>消息传递分为两种</p><ul><li><p>直接通信方式</p><p><strong>把消息直接挂到接收进程的消息缓冲队列上，每一个进程会有一个消息缓冲队列，如果有另外一个进程想给这个进程发送消息的时候，发送进程首先会创建好消息头和消息体，通过发送原语发送给目标进程，消息就会挂到目标进程的消息缓冲队列的队尾。</strong></p><p><strong>目标进程通过接收原语，依次把消息缓冲队列的消息取走</strong></p></li><li><p>间接通信方式</p><p>消息要先发送到中间实体（信箱）中，因此也称为“信箱通信方式”</p><p><img src="/study/assets/image-20211216171817705.36ecf8c4.png" alt="image-20211216171817705"></p><p>信箱中的消息由哪个进程发送的，由哪个进程接收，都在消息头中</p><p><strong>通过发送原语，发送进程发送消息到信箱中</strong></p><p><strong>同样，接收进程通过接收原语，从信箱中取消息</strong></p></li></ul></li></ol><h4 id="管道通信" tabindex="-1"><a class="header-anchor" href="#管道通信" aria-hidden="true">#</a> 管道通信</h4><ol><li><p>所谓的管道其实是一种特殊的共享文件。</p><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件</p><p><strong>其实就是在内存中开辟一个大小固定的缓冲区</strong></p><p>这个缓冲区的大小一般和内存页面是一样的</p><p><img src="/study/assets/image-20211216170454485.9480dd2f.png" alt="image-20211216170454485"></p></li><li><p>一个管道只能采用<strong>半双工通信</strong>，<strong>某一时间段只能实现单向的传输</strong>，如果要实现双向同时通信，则需要设置两个管道。</p><p><img src="/study/assets/image-20211216170707557.ccfb73d8.png" alt="image-20211216170707557"></p></li><li><p><strong>各个进程对管道的访问，需要互斥的进行，也是前面提到的互斥共享。</strong></p></li><li><p>数据以字符流的形式写入管道，<strong>当管道写满时，写进程的write()系统调用将导致写进程被阻塞</strong>，等待读进程将数据取走。</p><p><strong>当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将导致读进程阻塞</strong></p></li><li><p><strong>如果没写满，就不允许读，如果没读空，就不允许写。</strong></p></li><li><p>数据一旦被读出，就从管道中抛弃，<strong>这就意味着读进程最多只能有一个</strong>，否则可能会有读错数据的情况</p></li></ol><p><img src="/study/assets/image-20211216172035502.96a88e5b.png" alt="image-20211216172035502"></p><h3 id="线程和多线程模型" tabindex="-1"><a class="header-anchor" href="#线程和多线程模型" aria-hidden="true">#</a> 线程和多线程模型</h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1" aria-hidden="true">#</a> 概念</h4><ol><li><p>在没有引入进程之前，系统中各个程序只能串行执行。</p></li><li><p>有的进程，可能需要同时做很多事，而传统的进程只能串行地执行一系列程序（多个进程之间是并发的，但是一个进程内部的程序是串行执行的。），为此，引入了“线程”，来增加并发度。</p><p><img src="/study/assets/image-20211216191425419.73b3b749.png" alt="image-20211216191425419"></p><p>同一个进程中被分为了多个线程。</p><p>多个线程之间，可以并发地执行！！之前一直说的都是进程之间的并发，但是引入了线程之后，多个线程之间，能够并发执行，也就是在宏观上多个线程是并行执行的，在微观上，是CPU交替执行这多个线程，也就是微观上是并发的，但是如果CPU是多核的，微观上也能够实现真正意义上的并行。</p></li><li><p>引入了线程之后，<strong>线程成为了程序执行流的最小单位</strong>。进程是资源分配的最小单位，多个线程会共用进程的资源，<strong>但是线程是调度的最小单位。</strong></p><p><strong>引入了线程之后，是多个线程并发地被CPU处理。</strong></p></li><li><p>线程可以理解为是轻量级的进程。</p><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，<strong>进程内</strong>的各线程之间也可以并发，从而进一步提升了系统的并发度，<strong>使得一个进程内也可以并发处理各种任务</strong>。</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的，进程是资源分配的最小单位）</p><p>CPU也算是系统资源，分配的最小单位是线程！！线程也需要得到CPU服务之后，才能执行。线程之间也存在上下文切换，线程的状态转换是由于CPU的轮转机制或者其他机制而导致CPU不继续服务当前线程，于是出现线程的状态转换，也存在要保存线程的运行环境，恢复运行环境这种上下文切换，和前面说的进程很类似。</p></li></ol><h4 id="引入线程机制后的变化" tabindex="-1"><a class="header-anchor" href="#引入线程机制后的变化" aria-hidden="true">#</a> 引入线程机制后的变化</h4><ol><li><img src="/study/assets/image-20211216193636875.1164bc66.png" alt="image-20211216193636875"></li></ol><h4 id="线程有哪些属性" tabindex="-1"><a class="header-anchor" href="#线程有哪些属性" aria-hidden="true">#</a> 线程有哪些属性</h4><ol><li>线程是处理器调度的单位</li><li>多核CPU环境下，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID，线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li><strong>同一进程的不同线程间共享进程的资源</strong></li><li>由于共享内存地址空间，同一进程的线程间通信甚至无需操作系统干扰（因为同一进程中的线程共享内存地址空间）</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大。（因为切换进程还要切换页表，页表是虚拟地址到物理地址的映射，线程不涉及到页表的切换）</li></ol><h4 id="线程的实现方式" tabindex="-1"><a class="header-anchor" href="#线程的实现方式" aria-hidden="true">#</a> 线程的实现方式</h4><ol><li><p>用户级线程</p><p>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</p><p><strong>用户级线程中，线程切换可以在用户态下进行，无需操作系统干预</strong></p><p>在用户看来，是有多个线程，但是在操作系统内核看来，意识不到线程的存在，用户级线程对用户不透明，对操作系统透明。</p><p>用户级线程就是从用户的视角可以看到的线程</p></li><li><p>内核级线程</p><p>内核级线程的管理工作是由<strong>操作系统内核完成</strong>，线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下完成。</p><p>内核级线程就是从操作系统内核视角能够看到的线程</p></li><li><p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式，将n个用户级线程，映射到m个内核级线程上</p><p>重点：操作系统只看得见内核级线程，因此只有内核级线程才是处理器分配的单位。</p><p><img src="/study/assets/image-20211216203142509.a3a0c411.png" alt="image-20211216203142509"></p></li></ol><h4 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型" aria-hidden="true">#</a> 多线程模型</h4><ol><li><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题</p></li><li><p>多对一模型</p><p><img src="/study/assets/image-20211216210038328.0df66e98.png" alt="image-20211216210038328"></p><p>多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程，内核级线程才是作为调度的基本单位</p><p>优点：<strong>用户级线程的切换在用户空间即可完成，不需要切换到核心态</strong>，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，会导致内核级线程阻塞，其他用户级线程也不能执行了， 整个进程会被阻塞，并发度不高。多个线程不可以在多核处理器上并行运行。因为内核级线程才是处理器调度的基本单位。（操作系统只看得见内核级线程）</p></li><li><p>一对一模型</p><p><img src="/study/assets/image-20211216210353349.2d9091c6.png" alt="image-20211216210353349"></p><p>一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程</p><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可以在多核处理器上并行执行。</p><p>缺点：<strong>一个用户进程会占用多个内核级线程</strong>，线程切换是由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p></li><li><p>多对多模型</p><p><img src="/study/assets/image-20211216210743381.1bf8043b.png" alt="image-20211216210743381"></p><p>n个用户级线程映射到m个内核级线程，每个用户进程对应m个内核级线程</p><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p></li></ol><h3 id="处理机调度" tabindex="-1"><a class="header-anchor" href="#处理机调度" aria-hidden="true">#</a> 处理机调度</h3><h4 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1" aria-hidden="true">#</a> 基本概念</h4><ol><li><p>线程是调度的最小单位（内核级线程）</p></li><li><p>调度：</p><p><strong>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理，这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题</strong></p><p>这种说法下的任务也可以理解为线程。</p></li><li><p><strong>在多道程序系统中，进程的数量（线程的数量）往往是多于处理器的核心个数的，这样不可能同时并行地处理各个进程</strong>，如果线程数量和处理器核心数相同，那么在微观上是能做到真正的并行处理线程的。</p><p>在这句话中，就是用进程或线程的描述来作为处理器处理的对象。</p><p>在第二点，是说的任务作为处理器处理的对象，所以，可以将进程和任务理解为相同的事物。</p></li><li><p>处理机调度，就是从就绪进程队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行（微观上串行，宏观上并行，就是并发）。</p></li></ol><h4 id="三个层次" tabindex="-1"><a class="header-anchor" href="#三个层次" aria-hidden="true">#</a> 三个层次</h4><h5 id="高级调度" tabindex="-1"><a class="header-anchor" href="#高级调度" aria-hidden="true">#</a> 高级调度</h5><ol><li><p>高级调度（<strong>作业</strong>调度），按一定的原则从外存上处于后备队列的<strong>作业</strong>中挑选一个或多个作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB（进程控制块），PCB、数据段、程序段组成一个进程实体），以使它（们）获得竞争处理机的权利。能够竞争CPU，说明处于就绪队列，说明已经获得了除CPU以外其他需要的资源，当然包括内存。</p></li><li><p><strong>高级调度是外存和内存之间的调度。</strong></p><p>作业调入时会建立相应的PCB，作业调出时才撤销PCB，高级调度主要是指调入的问题。因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p></li></ol><h5 id="中级调度" tabindex="-1"><a class="header-anchor" href="#中级调度" aria-hidden="true">#</a> 中级调度</h5><ol><li><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p><p>这么做的目的时为了提高内存利用率和系统吞吐量。</p><p><strong>暂时调到外存等待的进程称为挂起状态</strong>，值得注意的是，进程控制块PCB不会一起调到外存，而是会常驻内存，PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到<strong>挂起队列</strong>中（操作系统会为处于挂起态的进程建立一个挂起队列，把这些进程的PCB用一个队列的方式组织起来）。</p><blockquote><p>在内存中才叫进程，因为这里说的内存是运行时内存，而外存是磁盘，可以理解为静态的，但是为什么又能存放到外存呢，就是虚拟存储技术，也就是虚拟技术中的空分复用技术</p></blockquote><blockquote><p>就绪队列、阻塞队列存放的也是PCB</p></blockquote></li><li><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存</strong></p><p>一个进程可能会被多次调出、调入内存，因此中级调度的发生频率要比高级调度更高。</p></li><li><p>暂时调到外存等待的进程状态为挂起状态</p><p>挂起态又可以分为就绪挂起、阻塞挂起两种状态</p><p>就绪态的进程可能会由于内存空间不足，而被移到外存挂起，这叫就绪挂起</p><p>阻塞态的进程同样可能会由于内存空间不足，被移到外存挂起，叫阻塞挂起</p><p><img src="/study/assets/image-20211216222006381.3a92ee1b.png" alt="image-20211216222006381"></p></li><li><p>注意：</p><p>挂起和阻塞的区别，两种状态都是暂时不能获得CPU的服务，但是挂起态是将进程实体（映像）调到外存中去了，而阻塞态下的进程映像还在内存中。</p><p>有的操作系统会把就绪挂起，阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p></li></ol><h5 id="低级调度" tabindex="-1"><a class="header-anchor" href="#低级调度" aria-hidden="true">#</a> 低级调度</h5><ol><li><p>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理器分配给它</strong></p></li><li><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p><p>进程调度的频率很高，一般几十毫秒一次，只有这样，才能在宏观上看起来是并行执行的，实际上微观上是这些进程之间交替执行。</p></li></ol><h4 id="联系" tabindex="-1"><a class="header-anchor" href="#联系" aria-hidden="true">#</a> 联系</h4><ol><li><img src="/study/assets/image-20211216222809386.4cc064fa.png" alt="image-20211216222809386"></li></ol><h3 id="进程调度" tabindex="-1"><a class="header-anchor" href="#进程调度" aria-hidden="true">#</a> 进程调度</h3><h4 id="进程调度的时机" tabindex="-1"><a class="header-anchor" href="#进程调度的时机" aria-hidden="true">#</a> 进程调度的时机</h4><ol><li><p>进程调度就是低级调度，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p></li><li><p>什么时候需要进行进程调度和切换？</p><ul><li>当前运行的进程主动放弃处理机 <ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞，通过系统调用，系统调用时会执行陷入指令或者说访管指令，从而进入核心态，这是<strong>内中断中的自愿中断</strong>，进程由运行态到阻塞态是主动行为。</li></ul></li><li>当前运行的进程被动放弃处理机 <ul><li><strong>分给进程的时间片用完</strong></li><li>有更紧急的事需要处理（如IO中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><p>不能进行进程调度和切换的情况</p><ul><li>在处理中断的过程中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li><li>进程在操作系统<strong>内核</strong>程序临界区中（但是进程在普通临界区中是可以进行调度、切换的）</li><li>在原子操作过程中（原语），原子操作不可中断，要一气呵成（原子操作是通过中断来完成的，所以一定是在核心态进行。）</li></ul></li><li><p>临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源</p><p>临界区：访问临界资源那段代码</p></li><li><p>内核程序临界区访问的临界资源，如果不尽快释放的话，极有可能映像到操作系统内核的其他管理工作，因此在访问内核程序临界区期间不能进行调度与切换</p><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此在访问普通临界区时可以进行调度和切换，而且是很有必要进行进程的调度和切换来提高CPU的利用率和系统吞吐量。</p></li></ol><h4 id="进程调度的方式" tabindex="-1"><a class="header-anchor" href="#进程调度的方式" aria-hidden="true">#</a> 进程调度的方式</h4><ol><li>非剥夺调度方式，又称为非抢占方式，即只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li><li>剥夺调度方式，又称抢占方式，当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立刻暂停当前正在执行的进程，将处理机分配给更重要紧迫的进程。</li></ol><h4 id="进程的切换和过程" tabindex="-1"><a class="header-anchor" href="#进程的切换和过程" aria-hidden="true">#</a> 进程的切换和过程</h4><ol><li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</p><p>进程切换是指<strong>一个进程让出处理机，由另一个进程占用处理机</strong>的过程。</p><p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p></li><li><p>进程切换的过程主要完成了：</p><ul><li><p>对原来运行进程各种数据的保存，保存到PCB中</p></li><li><p>对新的进程的各种数据的恢复</p><p>这些进程的信息，运行环境的信息一般保存在进程控制块PCB中。</p></li></ul></li><li><p>不能简单地认为进程切换越频繁，并发度就越高</p><p>进程切换是有代价的，因此如果过于频繁地进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上。</p></li></ol><h3 id="进程同步、互斥" tabindex="-1"><a class="header-anchor" href="#进程同步、互斥" aria-hidden="true">#</a> 进程同步、互斥</h3><h4 id="概念-2" tabindex="-1"><a class="header-anchor" href="#概念-2" aria-hidden="true">#</a> 概念</h4><ol><li><p>进程具有异步性的特征，异步性是指，各并发执行的进程各自以独立的、不可预知的速度向前推进</p></li><li><p>进程同步：</p><p>并发性带来了异步性，有时需要通过进程同步解决这种异步问题</p><p>有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序，就是通过同步，同步锁的实现通过同步代码块和同步方法， 也正是这个意思。</p></li><li><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源，对临界资源的访问，必须互斥地进行。</p></li><li><p><img src="/study/assets/image-20211217163414696.8be533d0.png" alt="image-20211217163414696"></p><p>注意：</p><p>临界区是进程中访问临界资源的代码段</p><p>进入区和退出区是负责实现互斥的代码段</p></li><li><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待（保证不会饥饿）。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li><li>让权等待。当进程不能进入临界区时，<strong>应立即释放处理机</strong>，防止进程忙等待。</li></ul></li></ol><h4 id="信号量机制" tabindex="-1"><a class="header-anchor" href="#信号量机制" aria-hidden="true">#</a> 信号量机制</h4><ol><li><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），<strong>可以用一个信号量来表示系统中某种资源的数量。</strong></p><p><img src="/study/assets/image-20211217172238888.864894f2.png" alt="image-20211217172238888"></p></li><li><p>整型信号量</p><p>与普通整数变量的区别：对信号量的操作只有三种，即初始化，P操作、V操作</p><p><img src="/study/assets/image-20211217173250040.824b41f1.png" alt="image-20211217173250040"></p><p>也就是说，在进入区和退出区这两个代码区，分别使用P操作和V操作这两个原语操作来上锁和解锁。</p><p>检查和上锁一气呵成，避免了并发、异步导致的问题。</p><p>存在的问题：不满足让权等待的原则，会发生忙等。</p></li><li><p>记录型信号量</p><p><img src="/study/assets/image-20211217173913631.bd2f40b1.png" alt="image-20211217173913631"></p><p><strong>wait(S)和signal(S)可用于实现对系统资源的申请和释放</strong></p><p>S.value的初值表示系统中某种资源的数目</p><p>对信号量S的一次P操作意味着进程请求一个单位的该资源，因此需要执行S.value--，表示该资源数减1，当S.value&lt;0时，<strong>表示该类资源已分配完毕</strong>，因此进程应调用block原语进行自我阻塞，当前运行的进程从运行态到阻塞态，主动放弃处理机，并插入该类资源的等待队列，可见，该机制遵循了让权等待的原则，不会出现忙等现象，只要发现资源分配完毕，那么主动进入阻塞态，相当于是等待IO，进程进入阻塞态，都是主动的，是运行态主动到阻塞态，通过系统调用的访管指令或陷入指令，执行中断，于是阻塞，操作权限交给操作系统。</p><p>对信号量S的一次V操作，意味着进程释放一个单位的该类资源，因此需要执行S.value++，表示资源数+1，若加1后仍然是小于等于0，说明仍然有进程因为等待该资源而处于阻塞态，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态到就绪态，等待CPU时间片，即可被CPU执行。）</p></li><li><p>用信号量机制实现进程互斥</p><ul><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区，临界区是代码）</li><li><strong>设置互斥信号量mutex，初值为1</strong>，临界区可以理解为是一种特殊的系统资源，因为要实现互斥，所以设置这种“系统资源”的数量初值为1，相当于是上锁</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ul><p>注意：对不同的临界资源需要设置不同的互斥信号量，可以从Java多线程的角度来理解，同步锁对象一定要是同一个，多个线程要获得的是同一把锁，这样才有上锁的意义</p><p>PV操作必须成对出现（上锁和解锁必须成对出现），缺少P就不能保证临界资源的互斥访问，因为P操作相当于是上锁，缺少V会导致资源永不被释放，V操作相当于是解锁</p></li><li><p>用信号量实现进程同步：</p><ul><li>分析什么地方需要实现同步关系，找到需要执行同步关系的代码</li><li>设置同步信号量S，初始值设置为0</li><li>在“前操作”之后执行V（S）</li><li>在“后操作”之前执行P（S）</li></ul><p><img src="/study/assets/image-20211217182011808.4a522b35.png" alt="image-20211217182011808"></p></li></ol><h3 id="管程" tabindex="-1"><a class="header-anchor" href="#管程" aria-hidden="true">#</a> 管程</h3><h4 id="概念-3" tabindex="-1"><a class="header-anchor" href="#概念-3" aria-hidden="true">#</a> 概念</h4><ol><li><strong>管程是一种高级同步机制，和之前学过的PV操作一样，也是用来实现进程的互斥和同步的</strong></li><li>引入管程的目的是为了更方便地实现进程互斥和同步</li></ol><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h3><h4 id="概念-4" tabindex="-1"><a class="header-anchor" href="#概念-4" aria-hidden="true">#</a> 概念</h4><ol><li>死锁：在并发环境下，**各进程（发生死锁一定是两个或以上）**因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。</li></ol><h4 id="进程死锁、饥饿、死循环的区别" tabindex="-1"><a class="header-anchor" href="#进程死锁、饥饿、死循环的区别" aria-hidden="true">#</a> 进程死锁、饥饿、死循环的区别</h4><ol><li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象，比如：在短进程优先算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程饥饿现象</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。</li></ol><p><img src="/study/assets/image-20211217200059209.637fece5.png" alt="image-20211217200059209"></p><h4 id="死锁产生的必要条件" tabindex="-1"><a class="header-anchor" href="#死锁产生的必要条件" aria-hidden="true">#</a> 死锁产生的必要条件</h4><ol><li><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（比如IO设备），像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</p></li><li><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p></li><li><p>请求保持条件：<strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</strong></p></li><li><p>循环等待条件：<strong>存在一种进程资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>注意：发生死锁时，一定有循环等待，但是发生循环等待时未必死锁</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁，但如果系统中每类资源都只有1个，那循环等待就是死锁的充分必要条件了。</p></li></ol><h4 id="什么时候会发生死锁" tabindex="-1"><a class="header-anchor" href="#什么时候会发生死锁" aria-hidden="true">#</a> 什么时候会发生死锁</h4><ol><li>对不可剥夺的资源的不合理分配，可能导致死锁。</li></ol><h4 id="死锁的处理策略" tabindex="-1"><a class="header-anchor" href="#死锁的处理策略" aria-hidden="true">#</a> 死锁的处理策略</h4><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><h3 id="死锁的处理" tabindex="-1"><a class="header-anchor" href="#死锁的处理" aria-hidden="true">#</a> 死锁的处理</h3><h4 id="不允许死锁发生" tabindex="-1"><a class="header-anchor" href="#不允许死锁发生" aria-hidden="true">#</a> 不允许死锁发生</h4><h5 id="静态策略-预防死锁" tabindex="-1"><a class="header-anchor" href="#静态策略-预防死锁" aria-hidden="true">#</a> 静态策略：预防死锁</h5><ol><li><p>死锁的产生必须满足四个必要条件，只要其中一个或几个条件不成立，死锁就不会发生</p></li><li><p>破坏互斥条件</p><p>互斥条件：只有对必须互斥使用的资源（互斥共享）的争抢，才会导致死锁</p><p>如果把只能互斥使用的资源改造为允许共享使用（同时共享，宏观上并行，微观上仍然是串行的，是并发。），则系统不会进入死锁状态，比如：SPOOLing技术。操作系统可以采用SPOOLing技术将独占设备在逻辑上改为共享设备。</p><p>缺点：并不是所有的资源都可以改造成可共享使用的资源，并且为了系统安全，很多地方必须保持这种互斥性。因此，很多时候都无法破坏互斥条件。</p></li><li><p>破坏不剥夺条件</p><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式一般考虑各进程的优先级（比如剥夺调度方式就是将处理机资源强行剥夺给优先级更高的进程使用）</p><p>一种是自愿放弃，导致不用剥夺，一种是强行剥夺。</p></li><li><p>破坏请求和保持条件</p><p>可以采用静态分配方法，即进程在运行前一次性申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的资源了。</p><p>缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p></li><li><p>破坏循环等待条件</p><p><img src="/study/assets/image-20211217204429202.bc807014.png" alt="image-20211217204429202"></p><p><img src="/study/assets/image-20211217204620460.9c5c1d50.png" alt="image-20211217204620460"></p></li><li><p><img src="/study/assets/image-20211217204757093.11d17e6c.png" alt="image-20211217204757093"></p></li></ol><h5 id="动态策略-避免死锁" tabindex="-1"><a class="header-anchor" href="#动态策略-避免死锁" aria-hidden="true">#</a> 动态策略：避免死锁</h5><ol><li><p>安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，<strong>只要能找出一个安全序列，系统就是安全状态</strong>，当然安全序列可能有多个。</p></li><li><p>如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必是发生了死锁，但发生死锁时，一定是在不安全状态）</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态（能否找到一个安全序列），以此决定是否答应资源分配请求。这是银行家算法的核心思想。</p></li></ol><h4 id="允许死锁发生" tabindex="-1"><a class="header-anchor" href="#允许死锁发生" aria-hidden="true">#</a> 允许死锁发生</h4><ol><li><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁，在这种情况下，系统应当提供两个算法：</p><ul><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li></ul></li><li><p>死锁的检测</p><p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p></li><li><p>死锁的解除</p><p>并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</p><p>解除死锁的主要方法有：</p><ul><li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（终止进程法）：<strong>强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。</strong></li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。</li></ul><p>如何决定对哪个进程进行资源剥夺或撤销或回退：</p><ul><li>进程优先级</li><li>已执行多长时间</li><li>还有多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ul></li><li><p><img src="/study/assets/image-20211217213054745.44b0afa6.png" alt="image-20211217213054745"></p></li></ol><h2 id="第三章" tabindex="-1"><a class="header-anchor" href="#第三章" aria-hidden="true">#</a> 第三章</h2><h3 id="内存" tabindex="-1"><a class="header-anchor" href="#内存" aria-hidden="true">#</a> 内存</h3><h4 id="概念-5" tabindex="-1"><a class="header-anchor" href="#概念-5" aria-hidden="true">#</a> 概念</h4><ol><li>内存是用于存放数据的硬件，<strong>程序执行前需要先放到内存中才能被CPU处理</strong></li><li>外存就是硬盘或者叫辅存</li><li>硬盘是慢速的设备，而CPU是超快速的设备，所以CPU要处理的数据直接从外存中读取，CPU需要大量时间都在等待，CPU直接和外存的数据进行交互，会产生速度上的矛盾</li><li>内存可以理解为是一种更快速地存放数据的硬件。</li><li>内存地址从0开始，每个地址对应一个存储单元。</li></ol><h4 id="进程的运行原理-指令" tabindex="-1"><a class="header-anchor" href="#进程的运行原理-指令" aria-hidden="true">#</a> 进程的运行原理---指令</h4><ol><li><p>我们写的代码要翻译成CPU能识别的指令，这些指令会告诉CPU应该去内存的哪个地址存、取数据，这个数据应该做什么样的处理。但是对于Java来说，我们写的Java代码会编译成字节码文件，字节码也是二进制码，但是却不是CPU能够直接识别的二进制机器码，字节码对应于字节码指令，所以在JVM中的执行引擎部分，解释器会解释字节码指令并执行，同时JIT即时编译器会将字节码再次编译成CPU能直接识别的机器码，这是二次编译，所以说Java是半解释半编译的语言，解释器存在的原因是为了保证响应速度，因为编译是需要时间的，在JIT即时编译器编译热点代码的时候，解释器就能够直接解释字节码指令并执行了，保证了响应速度。</p></li><li><p>实际上，编译时，指令中给出的地址参数都是逻辑地址，或者说相对地址。</p><p>绝对地址又称物理地址</p><p>编译：由编译程序将用户源代码编译成<strong>若干个目标模块</strong>（编译就是把高级语言翻译成机器语言）</p><p>链接：由<strong>链接程序</strong>将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p><p>装入：由装入程序将装入模块装入内存运行。</p></li><li><p>装入的三种方式</p><ul><li><p>绝对装入</p><p>在编译时，如果直到程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存</p><p>绝对装入只适用于单道程序环境</p></li><li><p>静态重定位</p><p>由装入程序把逻辑地址转换为物理地址。</p><p>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p></li><li><p>动态重定位</p><p>又称动态运行时装入。这种方式需要一个重定位寄存器支持</p><p>重定位寄存器：存放装入模块存放的起始位置。</p><p><strong>允许程序在内存中发生移动。</strong></p><p><strong>并且可将程序分配到不连续的存储区中：在程序运行前，只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</strong></p></li></ul></li><li><p>链接的三种方式</p><p><img src="/study/assets/image-20211217222113746.356787c2.png" alt="image-20211217222113746"></p></li></ol><h3 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h3><h4 id="概念-6" tabindex="-1"><a class="header-anchor" href="#概念-6" aria-hidden="true">#</a> 概念</h4><ol><li><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理</p></li><li><p>各种进程想要运行的时候，进程相关的数据都要放入内存当中，或者说进程实体要放入内存中，进程实体是由PCB、程序段和数据段组成。</p></li><li><p>操作系统在内存管理的作用：</p><ul><li><p>操作系统需要负责内存空间的分配和回收</p></li><li><p>操作系统需要提供某种技术（虚拟技术或者说空分复用技术）从逻辑上对内存空间进行扩充</p><p><img src="/study/assets/image-20211220143402386-16399820431281.bb8b8b5a.png" alt="image-20211220143402386"></p></li><li><p>操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换。</p></li><li><p><strong>操作系统需要提供内存保护功能，保证各进程在各自存储空间内的运行，互不干扰。</strong></p></li></ul></li><li><p>逻辑地址到物理地址的转换，就是前面提到的装入的三种方式。</p></li><li><p>内存保护可采取两种方法：</p><ul><li>在CPU中设置一对上下限寄存器，存放进程的上下限地址，进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查，<strong>重定位寄存器中存放的是进程的起始物理地址</strong>，界地址寄存器中存放的是进程的最大逻辑地址。进程的指令要访问某个地址时，CPU检查是否越界。</li></ul></li></ol><h4 id="覆盖和交换" tabindex="-1"><a class="header-anchor" href="#覆盖和交换" aria-hidden="true">#</a> 覆盖和交换</h4><ol><li><p>覆盖技术，用来解决“程序大小超过物理<strong>内存</strong>总和”的问题</p><p>覆盖技术的思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。</p></li><li><p>程序一定要调入内存才能够被运行，进程就是一个程序的运行期，程序可以理解为静态的，必须调入内存才能够被CPU所执行，因为CPU是高速计算设备，而硬盘的IO速度很慢，这中间存在矛盾，所以一个程序在运行前必须被调入内存才能够被CPU执行，调入内存的程序可以说是程序的运行态，也就是进程。</p></li><li><p>内存中分为一个固定区和若干个覆盖区</p><p>需要常驻内存的段放在固定区中，调入后就不再调出</p><p>不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存</p><p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区</p><p><img src="/study/assets/image-20211220145412455.980d1cf5.png" alt="image-20211220145412455"></p><p>覆盖技术只用于早期的操作系统中，现在已经成为历史！！！</p></li><li><p>交换技术</p><p>当内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度。）</p><p><strong>处理机调度中的中级调度就是为了实现交换技术的调度策略。</strong></p><p>进程的PCB会保留在内存中，插入到挂起队列</p><p>PCB一定是保留在内存中，因为挂起的进程在磁盘的什么位置在PCB有记录。</p></li><li><p>具有对换功能的操作系统中，通常把磁盘空间分为对换区和文件区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式</p><p>对换区空间只占磁盘的小部分，<strong>被换出的进程数据就存放在对换区</strong>，主要追求换入换出速度，采用连续分配方式。</p><p>对换区的IO速度比文件区的更快</p></li><li><p>什么时候应该交换内存中的进程到外存中，把外存中具备运行条件的进程交换进内存中？</p><p>交换通常在许多进程运行且内存吃紧时进行，例如：在发现许多进程运行时经常发生缺页时，说明内存紧张，此时可以换出一些进程，如果缺页率明显下降，就可以暂停换出。</p></li><li><p>可优先换出阻塞进程，可换出优先级低的进程，为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存中的驻留时间。</p><p><strong>PCB会常驻内存，不会被换出外存</strong></p></li><li><p>覆盖和交换的区别：</p><ul><li>覆盖是在同一个程序或进程中的</li><li>交换是在不同进程或作业之间的。</li></ul></li></ol><h4 id="连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#连续分配管理方式" aria-hidden="true">#</a> 连续分配管理方式</h4><ol><li><p>单一连续分配</p><p>在单一连续分配方式中，内存被分为系统区和用户区。</p><p><strong>系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。</strong></p><p><strong>用户区用于存放用户进程相关数据</strong></p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p>不支持多个进程并发运行。</p><p>没有外部碎片，有内部碎片</p></li><li><p>固定分区分配</p><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</p><p>没有外部碎片，有内部碎片</p><ul><li><p>分区大小相等</p><p><img src="/study/assets/image-20211220153145382.4cb9da0f.png" alt="image-20211220153145382"></p></li><li><p>分区大小不等</p><p><img src="/study/assets/image-20211220153203225.f9ff2a9a.png" alt="image-20211220153203225"></p></li></ul></li><li><p>动态分区分配</p><p>又称可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的</p><ul><li><p>系统用什么样的数据结构记录内存的使用情况</p><p><img src="/study/assets/image-20211220154132962.cf8693cb.png" alt="image-20211220154132962"></p></li><li><p>把一个新作业放入内存时，必须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业</p></li></ul></li><li><p>动态分区分配<strong>没有内部碎片，但是有外部碎片</strong></p><p>内部碎片，<strong>分配给某进程的内存区域中，如果有些部分没有用上</strong></p><p>外部碎片，是指内存中的某些空闲分区由于太小而<strong>难以利用</strong>，即没有分配给进程的内存空间</p><p>如果内存中空闲空间的综合本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些碎片不能满足进程的需求</p><p>可以通过紧凑技术来解决外部碎片</p></li></ol><h4 id="动态分区分配算法" tabindex="-1"><a class="header-anchor" href="#动态分区分配算法" aria-hidden="true">#</a> 动态分区分配算法</h4><ol><li><p>首次适应算法</p><p><strong>每次都从低地址开始查找</strong>，找到第一个能满足大小的空闲分区</p><p>如何实现：<strong>空闲分区以地址递增的次序排序</strong>，每次分配内存时从头（从低地址）顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p></li><li><p>最佳适应算法</p><p>为各进程分配的空间必须是连续的一整片区域，因此为了保证当大进程到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong></p><p>如何实现：空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>更小的空闲分区会移到链头的位置。</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，因此这种方法会产生很多的外部碎片</p></li><li><p>最坏适应算法</p><p>和最佳适应算法相反</p><p>算法思想：优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p><p>如何实现：空闲分区按容量递减次序链接，每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：这种方式会导致较大的连续空闲区被迅速用完，如果之后有大进程到达，就没有内存分区可用了。</p></li><li><p>邻近适应算法</p><p>算法思想：首次适应算法每次都从链头开始查找的，这可能会导致<strong>低地址部分出现很多小的空闲分区（难以利用的分区）</strong>，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销，如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p></li></ol><h4 id="基本分页存储管理" tabindex="-1"><a class="header-anchor" href="#基本分页存储管理" aria-hidden="true">#</a> 基本分页存储管理</h4><h5 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h5><ol><li><p>连续分配方式的缺点：</p><p>固定分区分配，会产生大量的内部碎片，内存的利用率很低</p><p>动态分区分配，会产生很多外部碎片</p><p>如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”（内存整理）</p></li><li><p>非连续分配管理方式</p><ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>段页式存储管理</li></ul></li><li><p>基本分页存储管理的思想：</p><p>把内存分为一个个相等的小分区，<strong>再按照分区大小把进程拆分成一个个小部分</strong></p></li><li><p>将内存空间分为一个个大小相等的分区，每个分区就是一个“页框”或页帧。</p><p>每个页框有一个编号，即页框号。页框号从0开始。</p><p><strong>把用户进程的地址空间也分为与页框大小相等的一个个区域，称为页或页面，每个页面也有一个编号，即“页号”，页号也是从0开始</strong></p><p><strong>也就是页或页面是进程分的，页框或者说页帧是内存分的。</strong></p><p>注：进程的最后一个页面可能没有一个页框那么大，因此，页框不能太大，否则可能产生过大的内部碎片</p><p>操作系统以页框为单位，为各个进程分配内存空间，进程的每个页面分别放入一个页框中，也就是说，进程的页面与内存的页框有一一对应的关系。</p><p>进程的各个页面不必连续存放，也不必按照先后顺序来，可以放到不相邻的各个页框中。</p></li><li><p>如何实现逻辑地址到物理地址的转换？</p><ul><li>要算出逻辑地址对应的页号----逻辑地址 / 页面大小</li><li>要知道该页号对应页面再内存中的起始地址----得到页号之后，根据页表的表项，找到块号，块号 * 内存块大小，得到对应页面在内存中的起始地址。</li><li>要算出逻辑地址在“页面内”的偏移量----逻辑地址 % 页面大小</li><li>物理地址 = 页面地址 + 页内偏移量</li></ul></li><li><p>为了能直到进程的每个页面在内存中存放的起始位置，操作系统要为每个进程建立一张页表。</p><p>页面内的地址是连续的，各页面之间是离散的。</p><p>一个进程对应一张页表</p><p>一个进程的每一个页面，对应一个页表项</p><p>每个页表项由页号和块号组成</p><p>页表记录进程页面和**实际存放的内存块（块号）**之间的对应关系！！</p><p><img src="/study/assets/image-20211220175427142.6fa88c90.png" alt="image-20211220175427142"></p><p>M号内存块的起始地址就是<strong>M * 内存块大小</strong></p><p>各块之间是离散的，但是每一块内是连续的。</p></li></ol><h5 id="基本地址变换机构" tabindex="-1"><a class="header-anchor" href="#基本地址变换机构" aria-hidden="true">#</a> 基本地址变换机构</h5><ol><li><p>基本地址变换机构---用于实现逻辑地址到物理地址转换的一组硬件机构。</p><p><strong>页表寄存器</strong>的作用：</p><ul><li>存放页表起始地址</li><li>存放页表长度</li></ul></li><li><p><img src="/study/assets/image-20211220183023318.d83c970e.png" alt="image-20211220183023318"></p></li></ol><h5 id="具有快表的地址变换机构" tabindex="-1"><a class="header-anchor" href="#具有快表的地址变换机构" aria-hidden="true">#</a> 具有快表的地址变换机构</h5><ol><li><p>时间局部性：</p><p>如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问</p><p>空间局部性：</p><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的。 ）</p></li><li><p>每次要访问一个逻辑地址，都需要查询内存中的页表（根据逻辑地址可以得到页号和页内偏移量，<strong>根据页号、页表起始地址和页表项长度</strong>，<strong>可以得到页号对应的页表项地址</strong>，得到页号对应的内存块号，根据内存块号和页面大小即每一个内存块的大小，可以得到该内存块在内存中的起始地址，根据起始地址和偏移量便可以得到物理地址）。</p><p>由于局部性原理，可能连续很多次查到的都是同一个页表项地址。既然如此，能否利用这个特性减少访问页表的次数呢？</p></li><li><p>快表，又称TLB即联想寄存器，是一种<strong>访问速度比内存快很多</strong>的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程，与此对应，内存中的页表常称为慢表。</p><p><strong>页号、页表起始地址和页表项大小可以得到页号P对应的页表项地址！</strong></p></li><li><p>在查询慢表即内存中的页表之前，会先查询快表，理解为<strong>缓存</strong></p><p><img src="/study/assets/image-20211220184619310.68faa667.png" alt="image-20211220184619310"></p><p>若快表命中，就不需要再访问内存了，查询快表比内存快</p></li><li><p>引入快表后，地址的变换过程</p><p><img src="/study/assets/image-20211220184944890.e5ca0876.png" alt="image-20211220184944890"></p></li><li><p>由于查询快表的速度比查询页表（慢表）的速度快很多，因此只要快表命中，就可以节省很多时间，由于局部性原理，一般来说快表的命中率可以达到90%以上。</p></li><li><p>对比</p><p><img src="/study/assets/image-20211220185327397.4b11e813.png" alt="image-20211220185327397"></p></li></ol><h5 id="两级页表" tabindex="-1"><a class="header-anchor" href="#两级页表" aria-hidden="true">#</a> 两级页表</h5><ol><li><p>单级页表存在的问题</p><ul><li>问题1：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框---采用两级页表解决</li><li>问题2：<strong>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需访问某几个特定的页面。</strong></li></ul><p>我们是如何解决进程在内存中必须连续存储的问题的？</p><p>将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存</p><p>同样，我们可以将很长的页表分组，使每一个内存块刚好可以放入一个分组，之前是将进程分成很多个页面，相当于将进程分组，现在页表太长了，那么就将页表分组。</p><p><strong>另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表。</strong></p><p>通过页目录表和页号，找到内存块号，通过此内存块号得到此内存块对应的二级页表的起始地址</p></li><li><p>慢表也就是内存中的页表，当然是存储在内存中的，页表起始地址和页表长度存在页表寄存器中，进程运行的时候存储在页表寄存器中，没有被CPU执行的时候，存储在PCB中，所以页表存储在内存中，当然涉及到起始地址，这个地址存储在页表寄存器。</p><p>快表不是存储在内存中的，访问快表的速度比内存快很多，是高速缓冲存储器。</p></li><li><p>问题2的解决：</p><p><strong>可以在需要访问页面时才把页面调入内存</strong>（虚拟存储技术，页面是由进程分割而来的，把进程分成很多个部分），相当于需要进程某个部分时，才把这部分调入内存，进程分的部分就叫页面，内存分的部分就叫页框，可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。</p><p><strong>若想访问的页面不在内存中，则产生缺页中断（内中断，内中断分为自愿中断、硬件故障、软件中断），然后将目标页面从外存调入内存。</strong></p></li><li><p>两级页表的访存次数分析：（假设没有快表机构）</p><ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li><li><p>如何实现地址变换</p><ul><li>按照地址结构将逻辑地址分为三部分</li><li>从PCB中读出页目录表起始地址（页目录表也是在内存中的，当然有起始地址），根据一级页号查找到块号，根据内存块号找到下一级页表在内存中的存放位置（起始地址）</li><li>根据二级页号查表，找到<strong>最终</strong>想访问的内存块号</li><li>结合页内偏移量得到物理地址。</li></ul></li></ol><h4 id="基本分段存储管理" tabindex="-1"><a class="header-anchor" href="#基本分段存储管理" aria-hidden="true">#</a> 基本分段存储管理</h4><h5 id="介绍-1" tabindex="-1"><a class="header-anchor" href="#介绍-1" aria-hidden="true">#</a> 介绍</h5><ol><li><p>分段：</p><p><strong>进程的地址空间</strong>，按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名</p></li><li><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p></li><li><p>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）组成</p><p>段号的位数决定了每个进程最多可以分为几个段</p><p>段内地址位数决定了每个段的最大长度是多少</p></li><li><p>操作系统需要为每个进程建立一张段映射表，简称段表</p></li><li><p>在分页存储管理当中，每个页面的长度都是一样的，但是分段存储管理中，每个段的长度是不一样的，所以段表项比页表项多了一个段长</p></li><li><p>每个段对应一个段表项，就像一个进程对应于一个页表，进程的每一页对应于一个页表项！！</p><p>一个段表项，记录了该段在内存中的起始位置（基址）和段的长度</p></li><li><p><strong>各个段表项和各个页表项的长度是相同的。</strong></p><p><strong>因此段号和页号可以是隐含的，不占存储空间。</strong></p></li><li><p>地址变换的过程：</p><p><img src="/study/assets/image-20211220210600944.fba9935f.png" alt="image-20211220210600944"></p></li><li><p>分页的主要目的是为了实现离散分配，提高内存利用率，分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>分段的主要目的是为了更好地满足用户需求，<strong>一个段通常包含着一组属于一个逻辑模块的信息</strong>，分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定，段的长度不固定，决定于用户编写的程序。</p></li><li><p>不能被修改的代码称为纯代码或可重入代码，不属于临界资源，这样的代码是可以共享的，相当于只读。</p><p>可修改的代码是不能共享的</p><p>分段比分页更容易实现信息的共享和保护。</p></li><li><p>与分页系统类似，分段系统中页可以引入快表机构，将近期访问过的段表项放到快表中</p></li></ol><h4 id="段页式管理方式" tabindex="-1"><a class="header-anchor" href="#段页式管理方式" aria-hidden="true">#</a> 段页式管理方式</h4><ol><li><p>分页、分段的优缺点分析</p><table><thead><tr><th></th><th style="text-align:left;">缺点</th><th style="text-align:center;">优点</th></tr></thead><tbody><tr><td>分页管理</td><td style="text-align:left;">不方便按照逻辑模块实现信息的共享和保护</td><td style="text-align:center;">内存空间利用率高，不会产生外部碎片，只有少量的内部碎片</td></tr><tr><td>分段管理</td><td style="text-align:left;">如果段长过大，为其分配很大的连续空间会很不方便，另外，段式管理会产生外部碎片</td><td style="text-align:center;">很方便按照逻辑模块实现信息的共享和保护</td></tr></tbody></table></li><li><p><img src="/study/assets/image-20211220212626340.372aa006.png" alt="image-20211220212626340"></p></li><li><p>分段系统的逻辑地址结构由段号和段内地址（段内偏移量）组成</p><p><img src="/study/assets/image-20211220212723931.388963a1.png" alt="image-20211220212723931"></p><p>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成</p><p><img src="/study/assets/image-20211220212746790.e9845ed3.png" alt="image-20211220212746790"></p><p>段号的位数决定了每个进程最多可以分几个段</p><p>页号位数决定了每个段最大有多少页</p></li><li><p>逻辑地址到物理地址的转换</p><p><img src="/study/assets/image-20211220213646069.ad87e728.png" alt="image-20211220213646069"></p></li></ol><h3 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h3><h4 id="概念-7" tabindex="-1"><a class="header-anchor" href="#概念-7" aria-hidden="true">#</a> 概念</h4><ol><li><p>内存空间的扩充：</p><ul><li><p>覆盖技术</p></li><li><p>交换技术（通过处理机调度的中级调度实现）</p></li><li><p>虚拟存储技术（用到进程的某一部分，才调入内存，按页调入内存）</p><p><strong>可以在需要访问页面时，才把页面调入内存。</strong></p></li></ul></li><li><p>传统存储管理方式</p><p><img src="/study/assets/image-20211221154032346.0422b5f4.png" alt="image-20211221154032346"></p><p>特征：</p><ul><li><p><strong>一次性：作业必须一次性全部装入内存后才能开始运行</strong></p><p>作业很大时，不能全部装入内存，导致大作业无法运行；</p><p>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</p></li><li><p>**驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。**事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据。</p></li></ul></li><li><p>高速缓冲技术的思想：</p><p><strong>将近期会频繁访问到的数据放到更高速的存储器中</strong>，暂时用不到的数据放在更低速存储器中</p><p><img src="/study/assets/image-20211221154907782.a8b09f6c.png" alt="image-20211221154907782"></p><p>快表机构就是将近期常访问的页表项副本放到更高速的高速缓冲寄存器中</p></li><li><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分<strong>装入内存</strong>，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的信息不在内存时，由<strong>操作系统负责</strong>将所需信息从外存调入内存，然后继续执行程序。（当所访问的信息不在内存时，说明缺页，就是缺少进程的某一部分，进程分割为页面，缺少就时缺页，那么会发生缺页中断，这是内中断，属于硬件中断，中断之后，会使CPU立即进入内核态，将执行权由用户进程交给操作系统，操作系统把需要的<strong>页面即进程的某一部分</strong>调入内存，这就是中断，中断就是将执行权交给操作系统，操作系统执行相应的过程来满足程序运行。像进程运行时执行陷入指令发生自愿中断，因为涉及到系统调用，需要操作系统来完成某些事情，也是同理。原语是通过关中断和开中断来完成，级别很高，必须在内核态进行。）</p><p><strong>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。就是挂起，之前讲的中级调度，就是完成交换。交换出的进程会放到磁盘的交换区而不是文件区。内存又分为系统区和用户区。但是交换技术，讲的是进程之间，交换的是进程，这里的讲内存中暂时用不到的信息换出，指的是进程内部的页面，是属于进程内而不是进程间。</strong></p><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</p><p>操作系统虚拟性，就是实际的物理内存大小没有变，只是在逻辑上进行了扩充。</p><p><strong>也就是内存中的进程只是这个进程的某一些页面，而不是一个完整的进程，通过调入调出页面来完成整个进程的执行。</strong></p></li><li><p><strong>虚拟内存的特征：</strong></p><ul><li><strong>多次性：无需在作业运行时，一次性全部装入内存，而是允许被分成多次调入内存</strong></li><li><strong>对换性：在作业运行时无需一直常驻内存，而是允许在作业（进程）运行过程中，将作业（进程的某些暂时用不到的页面）换入、换出。</strong></li><li><strong>虚拟性：从逻辑上扩充内存的容量，使用户看到的内存容量远大于实际的容量。</strong></li></ul></li><li><p>虚拟内存技术，允许一个作业分多次调入内存，如果采用连续分配方式，会不方便实现，因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p></li><li><p><strong>操作系统需要提供请求调页（请求调段）功能</strong></p><p><strong>操作系统需要提供页面置换（或段置换）功能</strong></p></li></ol><h4 id="请求分页存储管理方式" tabindex="-1"><a class="header-anchor" href="#请求分页存储管理方式" aria-hidden="true">#</a> 请求分页存储管理方式</h4><ol><li><p>请求分页存储管理与基本分页存储管理的主要区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息（进程的页面）从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p></li><li><p>页表机制：</p><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p><p>当内存空间不够时，要实现页面置换，操作系统要通过**某些指标（页面置换算法）**知道该换出哪个页面，有的页面没有被修改过，就不需要浪费时间再写回外存，有的页面修改过，就需要将外存中的旧数据覆盖，因此操作系统也需要记录各个页面是否被修改的信息。</p><p><img src="/study/assets/image-20211221163750995.10710194.png" alt="image-20211221163750995"></p><p>请求页表项增加了四个字段</p></li><li><p>缺页中断机构</p><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时是发生IO操作，因为要将页面从外存调入内存。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后，再将其唤醒，放回就绪队列。这里说的插入到队列里的都是PCB</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰（从内存调到外存），若该页面在内存期间被修改过，则要将其写回外存，在内存期间未修改过的页面不用写回外存。</p></li><li><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p><p>一条指令在执行期间，可能产生多次缺页中断。</p><p><img src="/study/assets/image-20211221173752429.5d7bd5d3.png" alt="image-20211221173752429"></p></li><li><p><img src="/study/assets/image-20211221174313529.de30f980.png" alt="image-20211221174313529"></p><ul><li>只有写指令才需要修改修改位，并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样可以减少访存次数</li><li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</li><li>需要用某种页面置换算法，来决定换出哪个页面</li><li>换出、换入都需要启动慢速的IO操作。</li><li><strong>页面调入内存后，需要修改慢表的相应页表项，同时，需要将表项复制到快表中。</strong></li></ul><p>请求调页时通过缺页中断进行！！缺页中断的目的就是请求操作系统调页。</p></li></ol><h4 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法" aria-hidden="true">#</a> 页面置换算法</h4><ol><li><p>用页面置换算法决定应该换出哪个页面</p></li><li><p>页面换入换出需要磁盘IO，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率</p></li><li><p>页面置换算法</p><ul><li>最佳置换算法</li><li>先进先出置换算法</li><li>最近最久未使用置换算法</li><li>时钟置换算法</li><li>改进型的时钟置换算法</li></ul></li><li><p>最佳置换算法OPT</p><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><p>注意：发生了缺页中断，未必会发生页面置换，若还有可用的空闲内存块，就不用进行页面置换。只有内存不够用了才需要进行页面置换</p><p>实际：操作系统无法提前预判页面访问序列，因此，最佳置换算法是无法实现的。 这是理想化的算法。</p></li><li><p>先进先出置换算法FIFO</p><p>每次选择淘汰的页面是最早进入内存的页面</p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时，选择对头的页面即可。</p><p><strong>贝拉迪异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</strong></p><p>只有FIFO算法会产生贝拉迪异常，另外，FIFO算法虽然实现简单，<strong>但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问，因此算法性能差。</strong></p></li><li><p>最近最久未使用置换算法LRU</p><p>每次淘汰的页面是最近最久未使用的页面</p><p>实现方法：此进程对应的页表的页表项中，用<strong>访问字段</strong>记录该页面自上次被访问以来所经历的时间t</p><p>当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><p><img src="/study/assets/image-20211221185055893.80412a2c.png" alt="image-20211221185055893"></p><p>此算法性能最接近最佳置换算法</p><p><strong>需要专门的硬件支持，算法开销大</strong></p></li><li><p>时钟置换算法CLOCK</p><p>LRU算法是最接近OPT算法性能的，但是需要专门的硬件支持，算法开销大</p><p>时钟置换算法是一种性能和开销比较均衡的算法</p><p><img src="/study/assets/image-20211221185458329.5423e18e.png" alt="image-20211221185458329"></p><p><img src="/study/assets/image-20211221185505869.43460ded.png" alt="image-20211221185505869"></p></li><li><p>改进型的时钟置换算法</p><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过，事实上，如果被淘汰的页面没有被修改过，就不需要执行IO操作写回外存，只有被淘汰的页面被修改过时，才需要写回外存。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过，在其他条件都相同时，应优先淘汰没有被修改过的页面，避免IO操作。这就是改进型的时钟置换算法的思想。</p><p><img src="/study/assets/image-20211221185940035.3f33933d.png" alt="image-20211221185940035"></p><p><img src="/study/assets/image-20211221190423652.4d2ccad0.png" alt="image-20211221190423652"></p><p>每一轮分别代表一个优先级</p><p>第一优先级：最近没访问，且没修改过的页面</p><p>第二优先级：最近没访问，但是修改过的页面</p><p>第三优先级：最近访问过，没修改过的页面</p><p>第四优先级：最近访问过，且修改过的页面。</p></li><li><p><img src="/study/assets/image-20211221190938925.1c163916.png" alt="image-20211221190938925"></p></li></ol><h4 id="页面分配策略" tabindex="-1"><a class="header-anchor" href="#页面分配策略" aria-hidden="true">#</a> 页面分配策略</h4><ol><li><p>驻留集：请求分页存储管理中，给进程分配的内存块（页框）的集合</p><p>在采用了虚拟存储技术的系统中，驻留集的大小一般小于进程的总大小。</p></li><li><p>驻留集大小</p><p><strong>固定分配：操作系统为每个进程分配一组固定数目的内存块，在进程运行期间不再改变</strong></p><p><strong>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。</strong></p></li><li><p>局部置换：发生缺页时只能选进程自己的物理块进程置换</p><p>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p><p><img src="/study/assets/image-20211221205210092.6800319f.png" alt="image-20211221205210092"></p></li><li><p>固定分配局部置换：</p><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变，若进程在运行中发生缺页，则只能从<strong>该进程</strong>在内存中的页面中选出一页换出，然后再调入需要的页面。</p><p>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理</p></li><li><p>可变分配全局置换：</p><p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出，再将该物理块分配给缺页的进程。</p><p>采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当物理块用完时，系统才选择一个未锁定的页面换出，被选择调出的页可能时系统中<strong>任何一个进程</strong>的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p></li><li><p>可变分配局部置换：</p><p>刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页的时候，只允许从<strong>该进程</strong>自己的物理块中选出一个进行换出。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋于适当程度，反之，如果该进程缺页率很低，则会减少分配给该进程的物理块。</p></li><li><p>何时调入页面</p><p><img src="/study/assets/image-20211221210739713.960e2f1b.png" alt="image-20211221210739713"></p></li><li><p>从何处调入页面</p><p><img src="/study/assets/image-20211221211043210.ebdfd355.png" alt="image-20211221211043210"></p></li><li><p>抖动现象：</p><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出内存，这种频繁的页面调度行为称为抖动。</p><p>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数。</p></li><li><p>工作集：</p><p>指在某段时间间隔内，进程实际访问页面的集合。</p><p>一般来说，驻留集的大小不能小于工作集的大小，否则进程运行过程中将频繁缺页（抖动）</p></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.c3238cbb.js" defer></script>
  </body>
</html>
