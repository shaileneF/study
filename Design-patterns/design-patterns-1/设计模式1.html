<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>设计模式 | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.94a866fe.js"><link rel="modulepreload" href="/study/assets/设计模式1.html.27c31a42.js"><link rel="modulepreload" href="/study/assets/设计模式1.html.76a5072f.js"><link rel="prefetch" href="/study/assets/index.html.ef0980d5.js"><link rel="prefetch" href="/study/assets/index.html.d704feb7.js"><link rel="prefetch" href="/study/assets/index.html.da12d241.js"><link rel="prefetch" href="/study/assets/index.html.1a8a14b2.js"><link rel="prefetch" href="/study/assets/index.html.88e150bc.js"><link rel="prefetch" href="/study/assets/index.html.21edb384.js"><link rel="prefetch" href="/study/assets/index.html.1823213a.js"><link rel="prefetch" href="/study/assets/设计模式2.html.9a102428.js"><link rel="prefetch" href="/study/assets/gin.html.a28c9677.js"><link rel="prefetch" href="/study/assets/golang.html.866069a4.js"><link rel="prefetch" href="/study/assets/gorm.html.cc13fae6.js"><link rel="prefetch" href="/study/assets/Javaweb.html.0eb3cf58.js"><link rel="prefetch" href="/study/assets/ES.html.8dc31c4d.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.fc1f32f4.js"><link rel="prefetch" href="/study/assets/Java笔记.html.714844a2.js"><link rel="prefetch" href="/study/assets/dubbo.html.d67bfb91.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.2eec6489.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.bf78953d.js"><link rel="prefetch" href="/study/assets/zookeeper.html.4a511f3f.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.f66ae0a7.js"><link rel="prefetch" href="/study/assets/并发编程.html.e1a0f9a3.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.895e395f.js"><link rel="prefetch" href="/study/assets/redis.html.d6e61909.js"><link rel="prefetch" href="/study/assets/Mybatis.html.e7a4d05c.js"><link rel="prefetch" href="/study/assets/spring.html.2a336ef5.js"><link rel="prefetch" href="/study/assets/springboot.html.54cbf687.js"><link rel="prefetch" href="/study/assets/springboot.html.8d15df3b.js"><link rel="prefetch" href="/study/assets/springMVC.html.942306dc.js"><link rel="prefetch" href="/study/assets/kafka.html.df0c4f6f.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.e1d9beb7.js"><link rel="prefetch" href="/study/assets/操作系统.html.f6ff6c21.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.d184c950.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.317fe877.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.95e3deb1.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.b207dbd3.js"><link rel="prefetch" href="/study/assets/index.html.19a48a8f.js"><link rel="prefetch" href="/study/assets/index.html.666bec8b.js"><link rel="prefetch" href="/study/assets/index.html.8b334d2d.js"><link rel="prefetch" href="/study/assets/index.html.210dd343.js"><link rel="prefetch" href="/study/assets/index.html.3d20be18.js"><link rel="prefetch" href="/study/assets/index.html.95636bb0.js"><link rel="prefetch" href="/study/assets/设计模式2.html.aac01d63.js"><link rel="prefetch" href="/study/assets/gin.html.b51d8ce8.js"><link rel="prefetch" href="/study/assets/golang.html.a5f911c8.js"><link rel="prefetch" href="/study/assets/gorm.html.da372b0a.js"><link rel="prefetch" href="/study/assets/Javaweb.html.bb6a380e.js"><link rel="prefetch" href="/study/assets/ES.html.8902c3ac.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.6c32f7c4.js"><link rel="prefetch" href="/study/assets/Java笔记.html.ecfed43f.js"><link rel="prefetch" href="/study/assets/dubbo.html.7f2f6cc6.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.98b23579.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.37d7c3e8.js"><link rel="prefetch" href="/study/assets/zookeeper.html.89f37fdf.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.da5bfa94.js"><link rel="prefetch" href="/study/assets/并发编程.html.f2dbba58.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.3e0c23ae.js"><link rel="prefetch" href="/study/assets/redis.html.dbc9d05a.js"><link rel="prefetch" href="/study/assets/Mybatis.html.f9b7ed04.js"><link rel="prefetch" href="/study/assets/spring.html.156858f3.js"><link rel="prefetch" href="/study/assets/springboot.html.a63aeaf6.js"><link rel="prefetch" href="/study/assets/springboot.html.171568dd.js"><link rel="prefetch" href="/study/assets/springMVC.html.baa7303d.js"><link rel="prefetch" href="/study/assets/kafka.html.2fc03ec1.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.2d371271.js"><link rel="prefetch" href="/study/assets/操作系统.html.640cfe14.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.5e745904.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.227a3b7d.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.4ae943da.js"><link rel="prefetch" href="/study/assets/404.html.b4ca64f8.js"><link rel="prefetch" href="/study/assets/404.cd518eca.js"><link rel="prefetch" href="/study/assets/Layout.49de8b5e.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="router-link-active" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="router-link-active" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">设计模式 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_1-概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 概述"><!--[--><!--]--> 1. 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_2-重构" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 重构"><!--[--><!--]--> 2. 重构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-面向对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. 面向对象"><!--[--><!--]--> 3. 面向对象 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-1封装" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1封装"><!--[--><!--]--> 3.1封装 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-1-1-封装的定义" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1.1 封装的定义"><!--[--><!--]--> 3.1.1 封装的定义 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-1-2-封装能解决的问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.1.2 封装能解决的问题"><!--[--><!--]--> 3.1.2 封装能解决的问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-2-抽象" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2 抽象"><!--[--><!--]--> 3.2 抽象 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-2-1-定义" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2.1 定义"><!--[--><!--]--> 3.2.1 定义 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-2-2-用途" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.2.2 用途"><!--[--><!--]--> 3.2.2 用途 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-3-继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.3 继承"><!--[--><!--]--> 3.3 继承 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-4-多态" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 多态"><!--[--><!--]--> 3.4 多态 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-4-1-用途" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4.1 用途"><!--[--><!--]--> 3.4.1 用途 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-4-面向过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.4 面向过程"><!--[--><!--]--> 3.4 面向过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-5-注意" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.5 注意"><!--[--><!--]--> 3.5 注意 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-6-接口和抽象类" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.6 接口和抽象类"><!--[--><!--]--> 3.6 接口和抽象类 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#抽象类" class="router-link-active router-link-exact-active sidebar-item" aria-label="抽象类"><!--[--><!--]--> 抽象类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#接口" class="router-link-active router-link-exact-active sidebar-item" aria-label="接口"><!--[--><!--]--> 接口 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#注意" class="router-link-active router-link-exact-active sidebar-item" aria-label="注意"><!--[--><!--]--> 注意 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-7-基于接口编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.7 基于接口编程"><!--[--><!--]--> 3.7 基于接口编程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-8-多用组合少用继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.8 多用组合少用继承"><!--[--><!--]--> 3.8 多用组合少用继承 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_3-9-mvc架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="3.9 MVC架构"><!--[--><!--]--> 3.9 MVC架构 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_4-设计原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. 设计原则"><!--[--><!--]--> 4. 设计原则 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_4-1-里氏替换原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.1 里氏替换原则"><!--[--><!--]--> 4.1 里氏替换原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_4-2-接口隔离原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.2 接口隔离原则"><!--[--><!--]--> 4.2 接口隔离原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_4-3-依赖注入" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.3 依赖注入"><!--[--><!--]--> 4.3 依赖注入 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_4-4-依赖反转原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.4 依赖反转原则"><!--[--><!--]--> 4.4 依赖反转原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/Design-patterns/design-patterns-1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.html#_4-5-高内聚低耦合" class="router-link-active router-link-exact-active sidebar-item" aria-label="4.5 高内聚低耦合"><!--[--><!--]--> 4.5 高内聚低耦合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h1><p><a href="https://time.geekbang.org/column/intro/250?tab=catalog" target="_blank" rel="noopener noreferrer">极客时间设计模式之美<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>笔记整理</p><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h2><p>重点记录23种经典的设计模式。</p><p>设计模式主要解决的是代码的可扩展性问题。</p><p>虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，降低代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。</p><p>他们可以分为三大类：</p><ul><li>创建型</li><li>结构性</li><li>行为型</li></ul><p>对于这23种设计模式的学习，要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于不常用的设计模式，稍微了解即可。</p><p>创建型：</p><ul><li>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</li><li>不常用的有：原型模式。</li></ul><p>结构型：</p><ul><li>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</li><li>不常用的有：门面模式、组合模式、享元模式。</li></ul><p>行为型：</p><ul><li>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</li><li>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li></ul><h2 id="_2-重构" tabindex="-1"><a class="header-anchor" href="#_2-重构" aria-hidden="true">#</a> 2. 重构</h2><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。<strong>重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段</strong>，能有效避免代码腐化到无可救药的地步。</p><p>把重构当作开发的一部分，融入到日常开发中。</p><p>面向对象、设计原则、设计模式、编程规范、重构五者的关系：</p><ul><li>面向对象编程因为其具有丰富的特性（封装、集成、多态、抽象等），可以实现很复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。</li><li>设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义，比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。</li><li>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。</li><li>编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。</li></ul><h2 id="_3-面向对象" tabindex="-1"><a class="header-anchor" href="#_3-面向对象" aria-hidden="true">#</a> 3. 面向对象</h2><p>面向对象编程是一种编程范式或者说编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p><ul><li><p>如何判定一个语言是面向对象编程语言</p><p>如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。</p></li></ul><p>理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、继承、多态、抽象。不过对于这四大特性，光知道他们的定义是不够的，我们还要知道每个特性的意义和目的，以及他们能解决哪些编程问题。</p><h3 id="_3-1封装" tabindex="-1"><a class="header-anchor" href="#_3-1封装" aria-hidden="true">#</a> 3.1封装</h3><h4 id="_3-1-1-封装的定义" tabindex="-1"><a class="header-anchor" href="#_3-1-1-封装的定义" aria-hidden="true">#</a> 3.1.1 封装的定义</h4><p>封装也叫做信息隐藏或数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。</p><p>类的属性通常被设计为私有的，通过固有的get方法进行访问，外部不能对这些私有属性进行直接访问和修改。</p><p>虚拟钱包类的代码示例：</p><div class="language-java ext-java"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wallet</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">long</span> createTime<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">BigDecimal</span> balance<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">long</span> balanceLastModifiedTime<span class="token punctuation">;</span>
  <span class="token comment">// ...省略其他属性...</span>

  <span class="token keyword">public</span> <span class="token class-name">Wallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>createTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">=</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">;</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>balanceLastModifiedTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getCreateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>createTime<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token class-name">BigDecimal</span> <span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getBalanceLastModifiedTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>balanceLastModifiedTime<span class="token punctuation">;</span>  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increaseBalance</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> increasedAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>increasedAmount<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidAmountException</span><span class="token punctuation">(</span><span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>increasedAmount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>balanceLastModifiedTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decreaseBalance</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> decreasedAmount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>decreasedAmount<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">BigDecimal</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidAmountException</span><span class="token punctuation">(</span><span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>decreasedAmount<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InsufficientAmountException</span><span class="token punctuation">(</span><span class="token string">&quot;...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>balance<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>decreasedAmount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>balanceLastModifiedTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在Wallet 类的构造函数内部<strong>将其初始化设置好</strong>，而不是通过构造函数的参数来外部赋值。</p><div class="language-java ext-java"><pre class="language-java"><code>   <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>createTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这就是在初始化，不需要外部创建对象的时候来初始化。直接通过该无参构造函数就初始化了。</p><p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持，这个语法机制就是访问权限控制。</p><p>例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被<strong>类之外的代码</strong>直接访问。</p><h4 id="_3-1-2-封装能解决的问题" tabindex="-1"><a class="header-anchor" href="#_3-1-2-封装能解决的问题" aria-hidden="true">#</a> 3.1.2 封装能解决的问题</h4><p>能提高类的安全性，虽然属性能够被灵活地修改，但是过度灵活意味着不可控，避免类的属性在代码的各个角落被别人以奇葩的方式修改。</p><p>能提高类的易用性，类仅仅通过暴露有限的方法从而暴露必要的操作。如果我们把类的属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解，而这对于调用者来说本身也是一种负担</p><p>通过封装性，能使类的用途更加清晰。</p><h3 id="_3-2-抽象" tabindex="-1"><a class="header-anchor" href="#_3-2-抽象" aria-hidden="true">#</a> 3.2 抽象</h3><h4 id="_3-2-1-定义" tabindex="-1"><a class="header-anchor" href="#_3-2-1-定义" aria-hidden="true">#</a> 3.2.1 定义</h4><p>封装主要讲的是如何<strong>隐藏信息，保护数据</strong>，使类变得更清晰，提高安全性和易用性，而抽象讲的是如何隐藏方法的具体实现，目的是让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p><p>在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。</p><h4 id="_3-2-2-用途" tabindex="-1"><a class="header-anchor" href="#_3-2-2-用途" aria-hidden="true">#</a> 3.2.2 用途</h4><p>抽象在代码设计中起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、代码解耦等。</p><p>实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。之所以这么说，那是因为，**类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。**调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。</p><p>我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。</p><p><strong>抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</strong></p><h3 id="_3-3-继承" tabindex="-1"><a class="header-anchor" href="#_3-3-继承" aria-hidden="true">#</a> 3.3 继承</h3><p>继承是用来表示类之间的 is-a 关系</p><p>继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。</p><h3 id="_3-4-多态" tabindex="-1"><a class="header-anchor" href="#_3-4-多态" aria-hidden="true">#</a> 3.4 多态</h3><p>我们先来看如何利用接口类来实现多态特性。</p><div class="language-java ext-java"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>
  <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">String</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">String</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Array</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token comment">//...省略其他方法...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">LinkedListNode</span> head<span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token comment">//...省略其他方法... </span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span> iterator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Iterator</span> arrayIterator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>arrayIterator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token class-name">Iterator</span> linkedListIterator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>linkedListIterator<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。</p><h4 id="_3-4-1-用途" tabindex="-1"><a class="header-anchor" href="#_3-4-1-用途" aria-hidden="true">#</a> 3.4.1 用途</h4><p>多态特性能提高代码的可扩展性和复用性。</p><p>我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p><h3 id="_3-4-面向过程" tabindex="-1"><a class="header-anchor" href="#_3-4-面向过程" aria-hidden="true">#</a> 3.4 面向过程</h3><p>面向过程强调的是功能行为，以函数为最小单位，强调怎么做。（要时刻注意自己别写成面向过程编程了）</p><p>面向对象，<strong>将功能封装进对象，强调具备了功能的对象</strong>，以类/对象为最小单位，考虑谁来做。功能在对象里</p><p>面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</p><p>对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。</p><p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p><p><strong>面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</strong></p><p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。</p><h3 id="_3-5-注意" tabindex="-1"><a class="header-anchor" href="#_3-5-注意" aria-hidden="true">#</a> 3.5 注意</h3><p>哪些代码设计看似是面向对象，实际是面向过程的？</p><ol><li><p>滥用 getter、setter 方法</p><p>它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。</p><p>如果说类中有一个属性类型是容器，外部要拿到这个容器对象，这样是不好的，因为丢失了面向对象编程的封装特性，因为外部拿到容器后是可以修改的，而非只读。</p><p>如果熟悉 Java 语言，那解决这个问题的方法还是挺简单的。我们可以通过 Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器。而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。</p><p><strong>总结：</strong></p><p><strong>在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。</strong></p></li><li><p>滥用全局变量和全局方法</p><p>全局方法有类的静态方法，全局变量有静态成员变量、常量</p><p>变量分为成员变量和局部变量</p><p>类的属性就是成员变量，类的方法就是成员方法。</p><p>类的方法里定义的变量是局部变量。</p><p>类的静态成员变量归属于类上的数据，可以被其他实例化的对象直接访问，也相当于一定程度上的全局变量。</p><p>常量属于全局变量。</p><p>常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。</p><p>刚刚介绍的这些全局变量和全局方法中，Constants 类和 Utils 类最常用到。</p><p>那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴。第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。</p><p>Utils类通常是工具类，实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。</p></li><li><p>定义数据和方法分离的类</p><p>传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。</p><p>并不是说就要完全排斥面向过程编程风格，像MVC模式进行web开发，就是后端经常使用的模式。</p></li></ol><h3 id="_3-6-接口和抽象类" tabindex="-1"><a class="header-anchor" href="#_3-6-接口和抽象类" aria-hidden="true">#</a> 3.6 接口和抽象类</h3><h4 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h4><div class="language-java ext-java"><pre class="language-java"><code>
<span class="token comment">// 抽象类</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span> <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>enabled <span class="token operator">=</span> enabled<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>minPermittedLevel <span class="token operator">=</span> minPermittedLevel<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> loggable <span class="token operator">=</span> enabled <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>minPermittedLevel<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> level<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loggable<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">doLog</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doLog</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 抽象类的子类：输出日志到文件</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token keyword">extends</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">Writer</span> fileWriter<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span>
    <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">,</span> <span class="token class-name">String</span> filepath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> enabled<span class="token punctuation">,</span> minPermittedLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>fileWriter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
  
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doLog</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> mesage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 格式化level和message,输出到日志文件</span>
    fileWriter<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageQueueLogger</span> <span class="token keyword">extends</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">MessageQueueClient</span> msgQueueClient<span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token class-name">MessageQueueLogger</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span>
    <span class="token class-name">Level</span> minPermittedLevel<span class="token punctuation">,</span> <span class="token class-name">MessageQueueClient</span> msgQueueClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> enabled<span class="token punctuation">,</span> minPermittedLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>msgQueueClient <span class="token operator">=</span> msgQueueClient<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doLog</span><span class="token punctuation">(</span><span class="token class-name">Level</span> level<span class="token punctuation">,</span> <span class="token class-name">String</span> mesage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 格式化level和message,输出到消息中间件</span>
    msgQueueClient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>抽象类不允许被实例化，只能被子类继承</strong>。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(...); 会报编译错误）。</p><p>抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作<strong>抽象方法</strong>。</p><p>子类继承抽象类，<strong>必须实现抽象类中的所有抽象方法</strong>。对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p><h4 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h4><p>接口不能包含属性（也就是成员变量）。</p><p>接口只能声明方法，方法不能包含代码实现。</p><p>类实现接口的时候，必须实现接口中声明的所有方法。</p><h4 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意</h4><p>抽象类是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。</p><p><strong>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</strong></p><p>实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象和代码解耦而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p><h3 id="_3-7-基于接口编程" tabindex="-1"><a class="header-anchor" href="#_3-7-基于接口编程" aria-hidden="true">#</a> 3.7 基于接口编程</h3><p>这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性（若需要扩展，可写实现类实现接口，写对应的具体的方法实现，而上游调用接口的代码不需要关心，也不需要改动）。</p><p>要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。</p><p>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</p><p>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</p><p>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。这样可以对修改关闭，对扩展开放，遵循开闭原则</p><p>是否需要为每个实现类定义接口？</p><p>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。</p><p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p><h3 id="_3-8-多用组合少用继承" tabindex="-1"><a class="header-anchor" href="#_3-8-多用组合少用继承" aria-hidden="true">#</a> 3.8 多用组合少用继承</h3><p>继承主要解决的是代码复用问题、is-a关系问题、使代码具备多态特性。</p><p>s-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p><p>组合和委托：</p><div class="language-java ext-java"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyAbility</span> <span class="token keyword">implements</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//... }</span>
<span class="token punctuation">}</span>
<span class="token comment">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">implements</span> <span class="token class-name">Tweetable</span><span class="token punctuation">,</span> <span class="token class-name">EggLayable</span> <span class="token punctuation">{</span><span class="token comment">//鸵鸟</span>
  <span class="token keyword">private</span> <span class="token class-name">TweetAbility</span> tweetAbility <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TweetAbility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//组合</span>
  <span class="token keyword">private</span> <span class="token class-name">EggLayAbility</span> eggLayAbility <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EggLayAbility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//组合</span>
  <span class="token comment">//... 省略其他属性和方法...</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tweetAbility<span class="token punctuation">.</span><span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 委托</span>
  <span class="token punctuation">}</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eggLayAbility<span class="token punctuation">.</span><span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 委托</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-9-mvc架构" tabindex="-1"><a class="header-anchor" href="#_3-9-mvc架构" aria-hidden="true">#</a> 3.9 MVC架构</h3><p>我们平时开发 Web 后端项目的时候，基本上都是这么组织代码的。其中，UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。</p><p>UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。</p><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><p><strong>实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。</strong></p><p><strong>在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。</strong></p><p>第一个要讨论的问题是：在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在我们的代码设计与实现中，并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？</p><p>区别于 Domain 的职责，Service 类主要有下面这样几个职责</p><ol><li><p>Service 类负责与 Repository 交流。VirtualWalletService 类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由<strong>领域模型 VirtualWallet 来完成业务逻辑</strong>，最后调用 Repository 类的方法，将数据存回数据库。</p><p>保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。</p></li><li><p>Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。</p></li></ol><p>也就是，按领域划分，虚拟钱包的业务逻辑比如转账、提现、充值、查看余额等和数据不解耦，由VirtualWallet类来包含数据和这些行为逻辑，也就是一个对象有它的数据和行为，这是面向对象编程。而一些流程化的逻辑，结构上的逻辑，比如调用dao层方法进行数据库交互，与 Repository 层打交道，调用其他接口等，那么就可以放在service中，而由领域模型 VirtualWallet 来完成业务逻辑。</p><p>第二个要讨论问题是：在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？</p><p>答案是没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。</p><p>就拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。我们再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。<strong>从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。</strong></p><p>总结：</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。不过，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。</p><p>面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类</p><h2 id="_4-设计原则" tabindex="-1"><a class="header-anchor" href="#_4-设计原则" aria-hidden="true">#</a> 4. 设计原则</h2><h3 id="_4-1-里氏替换原则" tabindex="-1"><a class="header-anchor" href="#_4-1-里氏替换原则" aria-hidden="true">#</a> 4.1 里氏替换原则</h3><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），<strong>那子类可以改变函数的内部实现逻辑</strong>，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h3 id="_4-2-接口隔离原则" tabindex="-1"><a class="header-anchor" href="#_4-2-接口隔离原则" aria-hidden="true">#</a> 4.2 接口隔离原则</h3><p>在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h3 id="_4-3-依赖注入" tabindex="-1"><a class="header-anchor" href="#_4-3-依赖注入" aria-hidden="true">#</a> 4.3 依赖注入</h3><p><strong>依赖注入就是不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</strong></p><p>spring的IOC其实也是这个意思，只不过类对象在外部创建，在spring里，就是将类的对象交给容器创建，通过Java config配置类的方式，或者XML配置文件的方式，或者通过注解的方式进行依赖注入，在类中声明类对象的引用，核心就是对象的创建、实例化交给容器而不由程序员自己控制。</p><div class="language-java ext-java"><pre class="language-java"><code>
<span class="token comment">// 非依赖注入实现方式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Notification</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">MessageSender</span> messageSender<span class="token punctuation">;</span>
  
  <span class="token keyword">public</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>messageSender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处有点像hardcode</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> cellphone<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...省略校验逻辑等...</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>messageSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>cellphone<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageSender</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> cellphone<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//....</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用Notification</span>
<span class="token class-name">Notification</span> notification <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 依赖注入的实现方式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Notification</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">MessageSender</span> messageSender<span class="token punctuation">;</span>
  
  <span class="token comment">// 通过构造函数将messageSender传递进来</span>
  <span class="token keyword">public</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span><span class="token class-name">MessageSender</span> messageSender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>messageSender <span class="token operator">=</span> messageSender<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> cellphone<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//...省略校验逻辑等...</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>messageSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>cellphone<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//使用Notification</span>
<span class="token class-name">MessageSender</span> messageSender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Notification</span> notification <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Notification</span><span class="token punctuation">(</span>messageSender<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>依赖注入框架</p><p>在如上例子的代码中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。</p><p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</p><h3 id="_4-4-依赖反转原则" tabindex="-1"><a class="header-anchor" href="#_4-4-依赖反转原则" aria-hidden="true">#</a> 4.4 依赖反转原则</h3><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><h3 id="_4-5-高内聚低耦合" tabindex="-1"><a class="header-anchor" href="#_4-5-高内聚低耦合" aria-hidden="true">#</a> 4.5 高内聚低耦合</h3><p>高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><p>如何理解迪米特法则？</p><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><p><strong>上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用。</strong></p><p>合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.94a866fe.js" defer></script>
  </body>
</html>
