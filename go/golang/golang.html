<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>go | shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.e0780f3d.js"><link rel="modulepreload" href="/study/assets/golang.html.9671054f.js"><link rel="modulepreload" href="/study/assets/golang.html.92262979.js"><link rel="prefetch" href="/study/assets/index.html.69ad51e5.js"><link rel="prefetch" href="/study/assets/index.html.20aabb79.js"><link rel="prefetch" href="/study/assets/index.html.be1a938a.js"><link rel="prefetch" href="/study/assets/index.html.afd67203.js"><link rel="prefetch" href="/study/assets/index.html.920fae3b.js"><link rel="prefetch" href="/study/assets/index.html.c0e4757d.js"><link rel="prefetch" href="/study/assets/index.html.0d30a00d.js"><link rel="prefetch" href="/study/assets/设计模式1.html.44325d33.js"><link rel="prefetch" href="/study/assets/设计模式2.html.859e3668.js"><link rel="prefetch" href="/study/assets/gin.html.67a1405c.js"><link rel="prefetch" href="/study/assets/gorm.html.93b54a04.js"><link rel="prefetch" href="/study/assets/Javaweb.html.6819b2ab.js"><link rel="prefetch" href="/study/assets/ES.html.97610e05.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.cc7e63e1.js"><link rel="prefetch" href="/study/assets/Java笔记.html.b6e0d4b8.js"><link rel="prefetch" href="/study/assets/dubbo.html.6742c431.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.4e5727ab.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.41a14816.js"><link rel="prefetch" href="/study/assets/zookeeper.html.4d19391f.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.7cef604b.js"><link rel="prefetch" href="/study/assets/并发编程.html.cfe39b9e.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.864dfe99.js"><link rel="prefetch" href="/study/assets/redis.html.63119c02.js"><link rel="prefetch" href="/study/assets/Mybatis.html.eb118073.js"><link rel="prefetch" href="/study/assets/spring.html.623fa92c.js"><link rel="prefetch" href="/study/assets/springboot.html.3dae95ef.js"><link rel="prefetch" href="/study/assets/springboot.html.33de218a.js"><link rel="prefetch" href="/study/assets/springMVC.html.4ce86fc4.js"><link rel="prefetch" href="/study/assets/kafka.html.4c4c13be.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.979c12ba.js"><link rel="prefetch" href="/study/assets/操作系统.html.1b0aa4b3.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.51da1b5a.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.0fea9ef5.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.650a9321.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.82cb05ef.js"><link rel="prefetch" href="/study/assets/index.html.d9c312a2.js"><link rel="prefetch" href="/study/assets/index.html.b3725312.js"><link rel="prefetch" href="/study/assets/index.html.91f27c0a.js"><link rel="prefetch" href="/study/assets/index.html.672f0f4e.js"><link rel="prefetch" href="/study/assets/index.html.a5f5784b.js"><link rel="prefetch" href="/study/assets/index.html.e82824d4.js"><link rel="prefetch" href="/study/assets/设计模式1.html.3c722ae2.js"><link rel="prefetch" href="/study/assets/设计模式2.html.5905c05a.js"><link rel="prefetch" href="/study/assets/gin.html.902bcdbd.js"><link rel="prefetch" href="/study/assets/gorm.html.1345b614.js"><link rel="prefetch" href="/study/assets/Javaweb.html.bb50e624.js"><link rel="prefetch" href="/study/assets/ES.html.35328526.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.89264e0d.js"><link rel="prefetch" href="/study/assets/Java笔记.html.3d0ff3b7.js"><link rel="prefetch" href="/study/assets/dubbo.html.ed229229.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.89074e0f.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.09fdbc9a.js"><link rel="prefetch" href="/study/assets/zookeeper.html.227cfe7e.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.7ceffe8c.js"><link rel="prefetch" href="/study/assets/并发编程.html.08524d70.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.3e79d397.js"><link rel="prefetch" href="/study/assets/redis.html.a3abc909.js"><link rel="prefetch" href="/study/assets/Mybatis.html.157d0445.js"><link rel="prefetch" href="/study/assets/spring.html.8876b608.js"><link rel="prefetch" href="/study/assets/springboot.html.2b28d1d6.js"><link rel="prefetch" href="/study/assets/springboot.html.099b4ae4.js"><link rel="prefetch" href="/study/assets/springMVC.html.f65a7e4a.js"><link rel="prefetch" href="/study/assets/kafka.html.4343c28d.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.972e0dfa.js"><link rel="prefetch" href="/study/assets/操作系统.html.b4ff293c.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.9b3c26d1.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.2141dfbd.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.d480aa8b.js"><link rel="prefetch" href="/study/assets/404.html.2d6c94c6.js"><link rel="prefetch" href="/study/assets/404.52aa4b0c.js"><link rel="prefetch" href="/study/assets/Layout.c0eb6ff3.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="router-link-active" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="router-link-active" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">go <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/go/golang/golang.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#golang语言特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="golang语言特性"><!--[--><!--]--> golang语言特性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#golang语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="golang语法"><!--[--><!--]--> golang语法 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/go/golang/golang.html#基础语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础语法"><!--[--><!--]--> 基础语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#数组及切片" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组及切片"><!--[--><!--]--> 数组及切片 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#map" class="router-link-active router-link-exact-active sidebar-item" aria-label="map"><!--[--><!--]--> map <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#结构体struct" class="router-link-active router-link-exact-active sidebar-item" aria-label="结构体struct"><!--[--><!--]--> 结构体struct <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#反射" class="router-link-active router-link-exact-active sidebar-item" aria-label="反射"><!--[--><!--]--> 反射 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#json和结构体的转换" class="router-link-active router-link-exact-active sidebar-item" aria-label="json和结构体的转换"><!--[--><!--]--> json和结构体的转换 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/go/golang/golang.html#golang高阶" class="router-link-active router-link-exact-active sidebar-item" aria-label="golang高阶"><!--[--><!--]--> golang高阶 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/go/golang/golang.html#goroutine" class="router-link-active router-link-exact-active sidebar-item" aria-label="goroutine"><!--[--><!--]--> goroutine <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/go/golang/golang.html#channel" class="router-link-active router-link-exact-active sidebar-item" aria-label="channel"><!--[--><!--]--> channel <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/study/go/golang/golang.html#go-modules模块管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="go modules模块管理"><!--[--><!--]--> go modules模块管理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/go/golang/golang.html#什么是go-modules" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是go modules"><!--[--><!--]--> 什么是go modules <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="go" tabindex="-1"><a class="header-anchor" href="#go" aria-hidden="true">#</a> go</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><ol><li><p>go能够更好地支持并发编程。</p></li><li><p>go语言<strong>编译快、执行快、易于开发</strong>，具有一部分动态语言的特性，同时是面向对象的语言，很容易上手。</p><p>Java编译快，执行速度一般。</p><p>python这种动态语言虽然快速编译，但是执行速度一般。</p><table><thead><tr><th></th><th>编译速度</th><th>执行速度</th></tr></thead><tbody><tr><td>Java</td><td>一般</td><td>一般</td></tr><tr><td>python</td><td><strong>快</strong></td><td>慢</td></tr><tr><td>c++</td><td>慢</td><td>快</td></tr><tr><td>go</td><td>快</td><td>快</td></tr></tbody></table><p>动态语言编译速度快，正是因为简单，编写简单，编译快，但是执行就慢，因为离底层远，需要翻译成可执行的机器码的时间就长，可以这么理解。</p><p>Java是半编译半解释型语言，为了保证执行效率和响应速度。</p><p>动态语言和脚本语言编译速度快</p></li><li><p>如果main包的源代码没有包含main函数，则会引发构建错误。</p></li></ol><div class="language-java ext-java"><pre class="language-java"><code><span class="token keyword">byte</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token keyword">long</span> <span class="token keyword">float</span> <span class="token keyword">double</span> <span class="token keyword">char</span> <span class="token keyword">boolean</span> <span class="token class-name">String</span>
    
</code></pre></div><p>JVM里，一个栈帧对应着一个方法调用。</p><ol start="4"><li><p><strong>指针 = 引用 = 内存地址</strong></p></li><li><p>想要修改切片或者数组里面的值，要通过下标即索引来修改，通过for range循环。</p><p>不要通过for range循环的第二个值value来进行修改，这个value只是拷贝，是修改不了数组或者切片里的值的。</p></li><li><p><strong>切片是引用类型，切片的底层指向一个数组。</strong></p></li><li><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

	t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token comment">// t 是一个指向T的指针。</span>
	t<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">5</span>
	t<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">8</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	a <span class="token builtin">int</span>
	b <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>内嵌类型是父类型</p><p>外层类型是子类型</p><p>内嵌是父类型，相当于继承了内嵌类型的所有属性和方法，类似于super()</p></li><li><p>在Go中，应用程序并发处理的部分被称作goroutines（协程）</p><p>协程工作在相同的地址空间中，所以共享内存的方式一定是同步的（必须同步，不然会产生并发安全问题，因为协程共享内存）。</p><p>Go使用channels来同步协程。</p></li><li><p>协程粒度更小，更轻量级</p></li></ol><p>可以使用少量的操作系统线程就能拥有任意多个提供服务的协程。</p><ol start="11"><li><p>协程可以运行在多个操作系统之间，也可以运行在线程之内。</p></li><li><p>协程是通过使用关键字<code>go</code>调用执行一个函数或者方法来实现的。</p><p>这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中分配了独立的栈。</p></li><li><p>一个处理器，单核，仍然可以执行多个线程，只不过是通过处理器调度，交替执行，会进行线程上下文的切换，这就叫做并发，多个线程竞争处理器，处理器此时对于这多个线程来说叫做资源，处理器单核交替执行这多个线程，便是并发场景。</p><p>处理器调度有几种方式，短作业优先，优先级别，先来先得等。</p><p>并行是真正的多核处理器，一个核心负责一个线程，多个线程分别执行任务，他们同时执行，这是并行。</p><p>并发，单核处理多个线程，如果调度方式得当，给外界的感觉就好像多个线程在并行执行一样，仍然有很好的并行执行效果。（实际上是交替执行，即并发。）</p></li><li><p>使用GOMAXPROCS</p><p>在gc编译器下，必须设置GOMAXPROCS为一个大于默认值1的数值来允许运行时支持使用多于1个的操作系统线程，所有的协程都会共享同一个线程，除非将GOMAXPROCS设置为1个大于1的数值。</p></li><li><p>当main()函数返回的时候，程序退出：它不会等待任何其他非main协程的结束，这就是为什么在服务器程序中，每一个请求都会启动一个协程来处理，server()函数必须保持运行状态。</p></li><li><p>协程是独立的处理单元，代码逻辑必须独立于协程调用的顺序。</p></li><li><p>协程可以使用共享变量来通信，但是不提倡这样做，因为这种方式给所有的共享内存的多线程都带来了困难。</p><p>GO有一种特殊的类型即通道--channel，这是一个可以发送类型化数据的管道，由其负责协程之间的通信，从而避开所有由共享内存导致的陷阱。</p></li><li><p>如果两个协程需要通信，必须给他们同一个通道作为参数才可以，这个通道必须是已初始化的。</p></li><li><p>对于同一个通道，发送操作，在接收者准备好之前是阻塞的，如果通道中的数据无人接收，就无法再给通道传入其他数据，新的输入无法在通道非空的情况下传入。</p></li><li><p>一个无缓冲通道只能包含1个元素。</p><p>给通道提供缓存，可以在扩展的<code>make</code>命令中设置它的容量。</p><div class="language-go ext-go"><pre class="language-go"><code>buf <span class="token operator">:=</span> <span class="token number">100</span>
ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span>
</code></pre></div><p>buf是通道可以同时容纳的元素个数。</p><p>在缓冲满载之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p></li><li><p>元素会按照发送的顺序被接收。如果缓冲容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功。</p></li><li><p>golang，Exit函数可以让当前程序以给出的状体码code退出，一般来说，状态码0表示成功，非0表示出错，程序会立刻终止，并且defer的函数不会执行。</p></li><li><p>golang遍历list</p><div class="language-golang ext-golang"><pre class="language-golang"><code>for iter := listHaiCoder.Front(); iter != nil; iter = iter.Next() {
		fmt.Println(iter.Value)
	}
</code></pre></div></li><li><p>golang将空接口类型interface{}转换成string类型</p><div class="language-golang ext-golang"><pre class="language-golang"><code>func Strval(value interface{}) string {
	var key string
	if value == nil {
		return key
	}

	switch value.(type) {
	case float64:
		ft := value.(float64)
		key = strconv.FormatFloat(ft, &#39;f&#39;, -1, 64)
	case float32:
		ft := value.(float32)
		key = strconv.FormatFloat(float64(ft), &#39;f&#39;, -1, 64)
	case int:
		it := value.(int)
		key = strconv.Itoa(it)
	case uint:
		it := value.(uint)
		key = strconv.Itoa(int(it))
	case int8:
		it := value.(int8)
		key = strconv.Itoa(int(it))
	case uint8:
		it := value.(uint8)
		key = strconv.Itoa(int(it))
	case int16:
		it := value.(int16)
		key = strconv.Itoa(int(it))
	case uint16:
		it := value.(uint16)
		key = strconv.Itoa(int(it))
	case int32:
		it := value.(int32)
		key = strconv.Itoa(int(it))
	case uint32:
		it := value.(uint32)
		key = strconv.Itoa(int(it))
	case int64:
		it := value.(int64)
		key = strconv.FormatInt(it, 10)
	case uint64:
		it := value.(uint64)
		key = strconv.FormatUint(it, 10)
	case string:
		key = value.(string)
	case []byte:
		key = string(value.([]byte))
	default:
		newValue, _ := json.Marshal(value)
		key = string(newValue)
	}

	return key
}
</code></pre></div></li></ol><h2 id="golang语言特性" tabindex="-1"><a class="header-anchor" href="#golang语言特性" aria-hidden="true">#</a> golang语言特性</h2><ol><li><p>GOROOT表示源码包所在路径，即golang安装路径。</p><p>这个用于配置环境变量。</p></li><li><p>GOPATH，开发者Go项目默认路径，</p><p>但是我们不可能只有一个Go项目，所以不推荐将GOPATH配置到环境变量，而是通过go modules管理项目，或者在控制台终端对每一个go项目进行单独的GOPATH配置。</p></li><li><p>go语言有极简单的部署方式</p><ul><li><p>可以直接编译成机器码</p><p>机器码是能够被CPU识别的二进制指令。</p><p>字节码也是二进制，但是并不是机器码，并不能够被CPU识别，所以在JVM的执行引擎部分，还需要JIT即时编译器进行二次编译。</p></li><li><p>不依赖于其他库</p><p>最终生成的可执行程序，是一个静态的可执行文本文件</p></li><li><p>直接运行</p></li></ul></li><li><p>golang是静态语言，动态语言如JavaScript，python是没有编译器的，是解释器，解释执行，所以效率可能不高。</p><p>Java是半编译半解释型语言。</p></li><li><p>静态语言有编译器，我们通过<code>go build</code>指令进行编译，如果当前代码有问题，编译期间就能够排除很多问题。</p></li><li><p>golang的并发是语言层面的并发。</p><p>很多语言支持并发，但是是通过外层的包装，一层又一层来达到并发，但是golang是原生支持并发，从原始的语法就是天生支持并发的。</p><p>golang能够充分利用多核，切换成本很低（通过协程实现并发，通过channel进行通信），尽量地提高cpu的并发的利用率。</p></li><li><p>golang优势</p><ul><li>runtime系统调度机制</li><li>高效的gc</li><li>丰富的标准库</li></ul></li><li><p>go编译指令</p><div class="language-bash ext-sh"><pre class="language-bash"><code>go build xxx.go
</code></pre></div><p>编译之后的可执行文件执行指令</p><div class="language-bash ext-sh"><pre class="language-bash"><code>//直接通过 ./xxx<span class="token punctuation">(</span>linux<span class="token punctuation">)</span>或者 .<span class="token punctuation">\</span>xxx.exe（windows）
</code></pre></div></li><li><p>golang所有Exception都用Error来处理</p></li><li><div class="language-bash ext-sh"><pre class="language-bash"><code>go run xxx.go //这是既包含了编译，也包含了运行！！
我们也可以分步执行，就是先go build，再通过./xxx执行可执行文件
</code></pre></div></li><li><p>golang中的语句，加分号和不加分号都可以，建议不加，编译器会自动给我们加。</p></li></ol><h2 id="golang语法" tabindex="-1"><a class="header-anchor" href="#golang语法" aria-hidden="true">#</a> golang语法</h2><h3 id="基础语法" tabindex="-1"><a class="header-anchor" href="#基础语法" aria-hidden="true">#</a> 基础语法</h3><ol><li><div class="language-go ext-go"><pre class="language-go"><code><span class="token comment">// 方法一：声明一个变量，默认赋初始值。</span>
<span class="token keyword">var</span> a <span class="token builtin">int</span> 
<span class="token comment">// 方式二：在初始化的时候，可以省去数据类型，通过值自动匹配当前的变量的数据类型</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">100</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;type of c = %T\n&quot;</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
<span class="token comment">// 方式三：省去var关键字，直接自动匹配（常用）</span>
e <span class="token operator">:=</span> <span class="token number">100</span>
<span class="token comment">//这种声明方式，只能用在函数体内来声明。</span>
</code></pre></div></li><li><p>const</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token comment">//const来定义枚举类型</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
	<span class="token comment">// 可以在const中添加关键字 iota，每行的iota都会累加1</span>
	<span class="token comment">// 第一行的iota默认是0</span>
	<span class="token comment">//BEIJING = 0</span>
	<span class="token comment">//SHANGHAI = 1</span>
	<span class="token comment">//SHENZHEN = 2</span>
	BEIJING <span class="token operator">=</span> <span class="token boolean">iota</span>
	SHANGHAI
	SHENZHEN
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>BEIJING<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>SHANGHAI<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>SHENZHEN<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>iota只能配合const()一起使用，iota只有在const进行累加效果</p></li><li><p>在golang中有两种定义变量的方式，分别为“常量赋值”，“自动推导类型常量”</p><ul><li><p>常量赋值语法格式：</p><p>const 常量名称 数据类型 = 值</p></li><li><p>自动推导类型常量：</p><p>const 常量名称 = 值</p></li></ul></li><li><p>golang中使用常量注意事项：</p><ul><li><p>常量一经定义不可修改，比如再次赋值是不允许的</p></li><li><p>不可以获取常量的内存地址</p><p>在go中在变量前使用“&amp;”可以获取变量的内存地址</p></li><li><p>常量和变量在不同的内存存储区域：</p><ul><li>常量存储在数据区下面的常量区</li><li>变量在栈区进行存储，但是在go中将堆和栈进行统一管理，称为虚拟内存区域</li></ul></li><li><p>为了将常量和变量有所区分，一般实际开发中，建议将常量的名称的所有字母大写。</p></li></ul></li><li><p>init函数与import导包</p><p><img src="/study/assets/image-20220727101615334.c1facbc1.png" alt="image-20220727101615334"></p><p>init()函数执行的时机要早于main函数</p><p>做变量的初始化，就可以在init()函数中进行操作</p></li><li><p>golang的每个文件都属于一个包，go是以包的形式管理文件和项目结构的。</p></li><li><p>在导入包的时候，在导的包前面加下划线，表示导入这个包，但是不使用这个包，golang语法比较严格，不这么做的话，编译会报错。</p><p>导入这个包，但是不使用这个包，说明只会执行这个包内部的init()方法。</p><p>比较严格的意思是说，导入的包必须使用，不然会成为多余的代码。</p><p>在导入的包前面可以定义包的别名。</p></li><li><p>值传递就是值的拷贝</p><p>引用传递可以理解为地址的拷贝，传递的引用，参数为地址值，指向同一个内存地址的内容。</p><p>指针和引用传递可以理解为同一个意思。</p><p><img src="/study/assets/image-20220727105416076.3cd6dda2.png" alt="image-20220727105416076"></p><p><code>*p = 10</code>表示改变p这个指针（引用）所指向的地址空间的值（内容）。</p><p><code>changeValue(&amp;a)</code>传的值是指针，为什么说golang只有值传递，其实这里也是值传递，为什么又说传的是指针相当于引用传递，这里&amp;a表示指针即内存地址值，传&amp;a表示指针的拷贝，即内存地址值的拷贝，就是值的拷贝。p就是地址值即&amp;a，*p就表示p这个地址值所指向内存中的内容。</p><p>p的类型是*int，说明存储的是地址值，即指针，这是一个意思。</p><p>p作为changeValue函数的形参，相当于是已经声明了并做了初始化，如下。</p><p><img src="/study/assets/image-20220727110325089.80e1c395.png" alt="image-20220727110325089"></p><p><img src="/study/assets/image-20220727110613817.9a648b3d.png" alt="image-20220727110613817"></p></li><li><p>defer用来表示一个函数在执行最后，在结束之前要执行的语句。</p><p>在同一个函数内，defer可以写多个。</p><p>写在后面的defer先执行。</p><p><img src="/study/assets/image-20220727112542873.cf4f45f9.png" alt="image-20220727112542873"></p><p>return如果和defer出现在同一个函数中，return的语句要比defer的语句先执行。</p></li></ol><h3 id="数组及切片" tabindex="-1"><a class="header-anchor" href="#数组及切片" aria-hidden="true">#</a> 数组及切片</h3><ol><li><p>定义数组的时候一定要指定数组的长度，数组是定长的，在物理内存空间上是连续的，这是数据结构的知识。在其他语言中也都是一样的。</p><p>数组和链表是物理内存空间上真实存在的结构。</p><p>而栈和队列则是受限线性表，是逻辑结构。</p></li><li><p>数组的长度也是数组变量的一部分</p><p>不同长度的数组是不同的数据类型。</p></li><li><p>我们想在调用函数的时候传递数组参数时，应该写动态数组即切片，这和Java中传递数组这个引用类型变量的方式更加贴合，更加接近。</p><p>在golang中，数组是值类型，并不是引用类型，而切片是引用类型，传递切片，能够指向底层的数组，这和Java中的方式更相近。</p></li><li><p>通过切片传递参数，是引用传递，而不是值传递。</p><p>但是golang只有值传递，没有引用传递，所以这里实际上是传递的是地址值的拷贝！！所以可以理解为引用传递，不必过分纠结这点，切片作为数组引用指向底层的数组。</p><p>传递切片的方式，可以修改切片中的内容，这就是因为引用传递。</p><p>切片是动态数组是指可以通过append给切片添加数据，从而实现扩容。</p><p>在golang中用切片更多，list都用得较少。</p></li><li><p>固定长度的数组在传参的时候是严格匹配数组类型的。</p></li><li><p>切片在传参上是引用传递，而且不同长度的动态数组，在传参时形参是一致的。</p></li><li><p>声明slice有多种方式。推荐用make的方式</p><div class="language-go ext-go"><pre class="language-go"><code>slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
</code></pre></div><p>第二个参数表示切片长度，第三个长度表示容量。</p><p><img src="/study/assets/image-20220727125745938.3946e194.png" alt="image-20220727125745938"></p></li><li><p>当切片的长度等于切片的容量了，说明切片已满了。</p><p>此时若追加元素至切片，golang会为切片开辟空间，开辟的空间大小和之前切片的容量一样。</p><p><img src="/study/assets/image-20220727130045041.2b32c0cc.png" alt="image-20220727130045041"></p><p><img src="/study/assets/image-20220727130159380.581d22d6.png" alt="image-20220727130159380"></p></li><li><p>切片的而长度和容量不同，长度表示左指针至右指针之间的距离，容量表示左指针至底层数组末尾的距离。</p><p>切片的扩容机制：append的时候，如果长度增加后超过容量，则将容量扩充一倍（即扩至2倍）</p></li><li><p>切片的截取是左闭右开。</p></li><li><div class="language-go ext-go"><pre class="language-go"><code><span class="token comment">//切片的截取：截取后的切片仍然和截取之前的切片是同一个引用，指向同一个底层数组，是同一个内存地址</span>
s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
s1 <span class="token operator">:=</span> s<span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">]</span>
<span class="token comment">//若此时修改s1，会发现s也被修改了，说明截取前后的两个切片是同一个引用</span>
</code></pre></div><p><img src="/study/assets/image-20220727130805936.d98638cb.png" alt="image-20220727130805936"></p></li><li><p>如果想让切片截取前后的切片分别指向各自的引用，不指向同一个引用，则用copy函数。</p><div class="language-go ext-go"><pre class="language-go"><code>s2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">copy</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span>s<span class="token punctuation">)</span>
</code></pre></div><p>将s中的值，依次拷贝到s2中，但是s2和s是指向不同地址。</p></li></ol><h3 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> map</h3><ol><li><p>key-value键值对形式。</p></li><li><p>声明map也推荐用make的方式</p><p>因为用make的方式能够使声明的map在底层有实际的内存空间，相当于已经初始化，这样增加了程序的健壮性，不容易出错。相当于代码规范。</p><p><code>var myMap map[string]string</code></p><p>这种方式仅仅是声明，并没有实际的内存空间。</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">var</span> myMap <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">if</span> myMap <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;空map&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token comment">// 肯定会打印，因为myMap仅仅是声明，没有在底层分配实际的内存空间。</span>
</code></pre></div></li><li><p>这和声明slice一样，如果直接采用var slice []int的方式声明，slice为nil，为后续出现空指针异常埋下隐患，声明map也不要通过这种方式，都通过make的方式来避免问题。</p></li><li><p>如果给map添加键值对的时候，数量达到了最初声明map时的容量，后续继续添加，会自动扩容，和slice是一样的。</p><p>map里面的内容是无序的。</p><p>推荐的声明map的方式：</p><div class="language-go ext-go"><pre class="language-go"><code>myMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token comment">// 会自动初始化分配容量</span>
</code></pre></div><div class="language-go ext-go"><pre class="language-go"><code>	mymap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> mymap1 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>mymap <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>  <span class="token comment">// false</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>mymap1 <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>自动初始化map，且为map分配空间，避免空指针异常。</p></li><li><p>传递map，是引用传递，map是引用类型。</p></li></ol><h3 id="结构体struct" tabindex="-1"><a class="header-anchor" href="#结构体struct" aria-hidden="true">#</a> 结构体struct</h3><ol><li><p><code>type myint int</code>，这是声明一种新的数据类型myint，是int的一个别名。</p></li><li><p>我们通过type这个关键字来定义结构体。</p><p>把多种基本的数据类型组合在一起，变成一种复合的数据类型。相当于Java的类</p></li><li><p>给结构体定义方法的时候，要用结构体指针。</p><p><img src="/study/assets/image-20220727145125068.3d982f8d.png" alt="image-20220727145125068"></p><p>golang中的结构体是值类型，要用指针，才能修改结构体中的“成员变量”。</p></li><li><p>如果类名首字母大写，表示其他包也能够访问。</p><p>如果说类的属性首字母大写，表示该属性对外是能够访问的，否则只能够包的内部访问呢，相当于是private和public</p></li><li><p>示例</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">type</span> Human <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	name <span class="token builtin">string</span>
	sex  <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Human<span class="token punctuation">)</span> <span class="token function">Eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">&quot;eat&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Human<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">&quot;walk&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//这种方式不能声明全局变量。</span>
	t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Human<span class="token punctuation">)</span>
	t<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;zhangsan&quot;</span>
	t<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">&quot;female&quot;</span>
	t<span class="token punctuation">.</span><span class="token function">Eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	t<span class="token punctuation">.</span><span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>继承示例：</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">type</span> superMan <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Human <span class="token comment">//superMan继承了父类Human的方法和属性</span>
    level <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token comment">// 可以重定义父类的方法，也可以写子类自己的新方法。</span>
</code></pre></div></li><li><p>接口里定义的所有方法必须被某个类全部实现，才能说这个类实现了此接口。</p><p>接口里只有方法的定义，没有方法的具体实现。</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token comment">// 本质是一个指针</span>
<span class="token keyword">type</span> AnimalInterface <span class="token keyword">interface</span> <span class="token punctuation">{</span>
   <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token function">GetColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
   <span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Cat <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   color <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;zzzzzzzzz.....&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">GetColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> this<span class="token punctuation">.</span>color
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Cat<span class="token punctuation">)</span> <span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token string">&quot;Cat&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> animal AnimalInterface
	animal <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>
	animal<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>左边是接口，右边是具体的类的对象，实例化对象。</p><p>左边是抽象，右边是具体。把具体赋值给抽象，之后都通过抽象的接口来调用方法，而方法具体怎么实现，有多种形态，即依据接口指向哪个实例化对象。</p></li><li><p>空接口 interface{}</p><p>int、string、float32、float64、struct....都实现了interface{}</p></li><li><p>interface{}该如何区分此时引用的底层数据类型是什么？</p><p>给interface{}提供类型断言的机制</p><div class="language-go ext-go"><pre class="language-go"><code>value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> arg<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>
</code></pre></div></li></ol><h3 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h3><ol><li><p>reflect包</p><p>ValueOf用来获取输入参数接口中的数据的值，如果接口为空，则返回0</p><p>TypeOf，用来动态获取输入参数接口中的类型，如果接口为空则返回nil</p></li><li><p>反射可以对一个已知变量，<strong>动态</strong>获取变量的value和type</p></li></ol><h3 id="json和结构体的转换" tabindex="-1"><a class="header-anchor" href="#json和结构体的转换" aria-hidden="true">#</a> json和结构体的转换</h3><ol><li><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">type</span> Movie <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Title  <span class="token builtin">string</span>   <span class="token string">`json:&quot;title&quot;`</span>
	Year   <span class="token builtin">int</span>      <span class="token string">`json:&quot;year&quot;`</span>
	Price  <span class="token builtin">int</span>      <span class="token string">`json:&quot;rmb&quot;`</span>
	Actors <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:&quot;actors&quot;`</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	movie <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Movie<span class="token punctuation">)</span>
	movie<span class="token punctuation">.</span>Title <span class="token operator">=</span> <span class="token string">&quot;喜剧之王&quot;</span>
	movie<span class="token punctuation">.</span>Year <span class="token operator">=</span> <span class="token number">2000</span>
	movie<span class="token punctuation">.</span>Price <span class="token operator">=</span> <span class="token number">10</span>
	movie<span class="token punctuation">.</span>Actors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">&quot;xingye&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;zhangbozhi&quot;</span><span class="token punctuation">}</span>
	jsonStr<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token operator">*</span>movie<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;jsonStr = %s\n&quot;</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">)</span>
	myMovie <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Movie<span class="token punctuation">)</span>
	err <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">,</span> myMovie<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>myMovie<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>结构体标签应用：</p><ul><li>json编解码</li><li>orm映射关系</li></ul></li></ol><h2 id="golang高阶" tabindex="-1"><a class="header-anchor" href="#golang高阶" aria-hidden="true">#</a> golang高阶</h2><h3 id="goroutine" tabindex="-1"><a class="header-anchor" href="#goroutine" aria-hidden="true">#</a> goroutine</h3><ol><li><p>多线程/多进程，解决了CPU串行执行线程，而线程阻塞导致的CPU利用率低，吞吐量低的问题。</p><p>单核CPU也能执行多线程，通过cpu的调度机制，时间片，先来先得，短作业优先等等，这在宏观上是并行，微观上是穿行，这就是并发，并没有真正的并行。</p><p>多个核心，每个核心同时执行线程，这才是真正的并行。</p></li><li><p>进程、线程的数量越多，切换成本就越大，也就越浪费。</p></li><li><p>把一个线程切分为用户线程和内核线程，用户线程保护业务层面的并发效果。</p><p>实际上内核线程就是线程，用户线程就是go语言中协程的概念。</p></li><li><p>一个进程是一个运行在自己内存地址空间的独立执行体，一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的。</p><p>多线程，以便让用户或CPU不必等待，增加性能，提高CPU的吞吐量，一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，这就是并发。</p><p>在Go中，应用程序并发处理的部分被称作协程。</p></li><li><p>协程工作在相同的地址空间中，所以共享内存的方式一定是同步的，这个可以通过sync包来实现。</p></li><li><p>协程是根据一个或多个线程的可用性，映射在他们之上的。</p><p><img src="/study/assets/image-20220805114256574.524e93a1.png" alt="image-20220805114256574"></p></li><li><p>协程之间的通信方式通过管道，协程工作在相同的内存中，共享内存，这很危险，对于共享变量会产生并发安全问题，协程通过管道进行通信而不通过共享内存的方式进行通信。</p><p><img src="/study/assets/image-20220805114736596.57e9620e.png" alt="image-20220805114736596"></p></li><li><p>使用协程进行并发，性能高的原因就是避免了经常进行线程之间的切换，降低了线程切换的成本，线程的上下文切换是需要耗费资源的，CPU时间，保存上下文等。所以在并发编程中，并不是说线程越多越好，当CPU为单核，多个线程并发执行时（微观上实际上是串行），线程之间的切换会耗费资源，虽然比进程之间的切换成本低。因为进程之间的切换，涉及到虚拟地址与物理地址之间的映射，涉及到查询cache等。</p></li><li><p><img src="/study/assets/image-20220805115145009.7adfe623.png" alt="image-20220805115145009"></p><p>一个P同一时刻只能去执行一个协程</p><p>所以一个程序在某一时刻能并行执行的协程的最大数量就是GOMAXPROCS的值，就是P的数量。</p><p>P是处理器，M是内核线程，也就是线程，G是协程。</p><p>可以理解为协程映射在内核线程上执行。</p></li><li><p>Go协程的调度器的设计策略</p><ul><li><p>复用线程</p><ul><li><p>work stealing</p><p><img src="/study/assets/image-20220805115739642.ca86a6c3.png" alt="image-20220805115739642"></p><p>当G1正在被执行，而M2空闲，要把M2利用上，而M2的P的本地队列是没有协程的，就会去从M1的队列中去偷取（从队列的尾部偷取）。</p></li><li><p>hand off</p><p>如果阻塞，阻塞的是协程和线程，不是P和CPU！！</p><p>P去执行其他协程。</p></li></ul></li><li><p>利用并行</p><p>GOMAXPROCS限定P的个数，这决定了并行执行的协程的最大数量</p></li><li><p>抢占</p><p>如果有其他协程在等待运行的话，当前协程只能最多执行10ms，就会被其他协程抢占CPU。所有协程平均分配CPU时间片。</p></li><li><p>全局G队列</p></li></ul></li><li><p>main是主goroutine即主协程，其他协程是子协程。</p><p>在Java中，main函数入口是线程，还有异常处理线程、垃圾回收线程。</p><p>主协程也就是main结束之后，其他协程不管有没有执行完都会结束。</p></li><li><p>两个协程之间要进行通信 用channel机制，不要通过全局变量！</p><p>而且协程之间是并行执行的，并行执行的最大协程数量由GOMAXPROCS决定，协程之间并行执行，那么子协程返回值不会被主协程即main拿到，他们之间是并行关系。</p></li></ol><h3 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> channel</h3><ol><li><p>作用：实现协程之间的通信。</p><p><img src="/study/assets/image-20220805154323775.490b1b0c.png" alt="image-20220805154323775"></p></li><li><p>channel是一种数据类型，也是协程之间的通信机制。</p></li><li><p>channel的定义方式</p><ul><li><code>make(chan Type) // 等价于make(chan Type 0)</code></li><li><code>make(chan Type, capacity)</code></li></ul></li><li><p>channel的简单使用</p><div class="language-go ext-go"><pre class="language-go"><code>channel <span class="token operator">&lt;-</span> value <span class="token comment">// 发送value到channel</span>
<span class="token comment">// 从channel读数据有以下三种方式</span>
<span class="token operator">&lt;-</span> channel <span class="token comment">// 接收并将其丢弃</span>
x <span class="token operator">:=</span> <span class="token operator">&lt;-</span> channel <span class="token comment">// 从channel接收数据，并赋值给x</span>
x<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span> channel <span class="token comment">// 功能同上，同时检查channel是否关闭或者是否为空</span>
</code></pre></div></li><li><p>无缓冲channel</p><p>channel阻塞</p><p>默认情况下，通信是同步且无缓冲的。</p><p>在有接收者接收数据之前，向通道发送数据的协程会阻塞。因为一个无缓冲的通道在没有空间来保存数据的时候，必须要有一个接收者准备好接收通道的数据。所以通道的发送/接收操作在<strong>对方</strong>准备好之前是阻塞的。</p><ul><li>对于同一个通道，发送操作，在接收者准备好之前，也就是接收者接收数据之前，是阻塞的。因为如果channel中的数据无人接收，就无法再给通道传入其他数据，所以发送操作会等待通道再次变为可用状态，就是通道的值被接收的时候。</li><li>对于同一个通道，接收操作是阻塞的，直到发送者发送了数据给通道。<strong>因为通道中没有数据，接收操作就会阻塞</strong>，知道通道中有数据，也就是发送者发送了数据。</li></ul></li><li><p>带缓冲channel</p><p>一个无缓冲通道只能包含 <strong>1个元素</strong></p><p>带缓冲通道是可以理解为消息队列，或者说消费者生产者模式。</p><p><strong>在缓冲存满数据之前，给一个带缓冲的通道发送数据是不会阻塞的，数据会存在缓冲区；从通道读数据也不会阻塞，直到缓冲区空。</strong></p><p>如果容量大于0，通道就是异步的了，缓冲满载之前，发送数据不阻塞，缓冲变空之前，接收数据不阻塞，元素会按照发送数据的顺序被接收。</p><p><strong>如果容量是0或者未设置，就是不带缓冲的通道，通信仅在收发双方准备好的情况下才可以成功。</strong></p><p>消息队列本质是个队列，这里的带缓冲通道，也很像队列。</p></li><li><p>关闭channel</p><p>close是内置函数，可以关闭一个channel</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
			c <span class="token operator">&lt;-</span> i
		<span class="token punctuation">}</span>
		<span class="token comment">// close可以关闭一个channel</span>
		<span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// ok如果为true表示channel没有关闭，如果为false，表示channel已经关闭</span>
		<span class="token comment">// 每次在读数据之前会判断ok，也就是通道是否关闭</span>
		<span class="token keyword">if</span> data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;main finished..&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，才去关闭channel</li><li>关闭channel后，无法向channel再发送数据</li><li>关闭channel后，可以继续从channel接收数据</li><li>对于nil channel，无论收发都会阻塞（这就是无缓冲channel，收发都会阻塞，直到对方发送或接收）</li></ul></li><li><p>channel与range</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">for</span> data <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>channel与select</p><p>select可以完成监控多个channel的状态。</p><p>每个case 表示监控每个channel</p><p>如以下代码，select在尝试监控chan1和chan2</p><div class="language-go ext-go"><pre class="language-go"><code><span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>chan1<span class="token punctuation">:</span>
    <span class="token comment">// 如果chan1成功读到数据，则进行该case处理语句</span>
    <span class="token keyword">case</span> chan2 <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token comment">//如果成功向chan2写入数据，则进行该case处理语句</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token comment">// 如果上面都没有成功，则进入default处理流程</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol><h2 id="go-modules模块管理" tabindex="-1"><a class="header-anchor" href="#go-modules模块管理" aria-hidden="true">#</a> go modules模块管理</h2><h3 id="什么是go-modules" tabindex="-1"><a class="header-anchor" href="#什么是go-modules" aria-hidden="true">#</a> 什么是go modules</h3><ol><li><p>go modules是go语言的<strong>依赖解决方案。</strong></p><p>go modules目前集成在go的工具链中，只要安装了go，也就可以使用go modules了，而go modules的出现也解决了在go 1.11之前的几个常见争议问题：</p><ul><li>go语言长久以来的依赖管理问题</li><li><strong>淘汰现有的go path使用模式</strong></li><li>统一社区中的其他依赖管理工具</li></ul></li><li><p>go modules的目的之一就是淘汰gopath，那么gopath是什么？</p><p>gopath是表示<strong>当前golang全部项目所在路径。</strong></p><p>goroot是go语言源码包所在路径，对比JDK。</p></li><li><p>go path路径下有三个文件夹</p><ul><li><p>bin</p><p>包含所有go代码已经编译过的可执行程序</p></li><li><p>pkg</p><p>存放自定义包的目录</p></li><li><p>src</p><p>存放项目源文件的目录</p></li></ul></li><li><p>gopath的弊端</p><p>go get下载第三放库的时候，因为无法指定版本号，无版本控制概念。</p></li><li><p>使用go modules就可以不使用gopath</p><p>用go modules来控制依赖。</p></li><li><p>go mod命令</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>go mod init</td><td>生成go.mod文件</td></tr><tr><td>go mod download</td><td>下载go.mod文件中指明的所有依赖</td></tr><tr><td>go mod tidy</td><td><strong>整理现有的依赖</strong></td></tr><tr><td>go mod graph</td><td>查看现有的依赖结构</td></tr><tr><td>go mod edit</td><td>编辑go.mod文件</td></tr><tr><td>go mod vendor</td><td>导出项目所有的依赖到vendor目录</td></tr><tr><td>go mod verify</td><td>检验一个模块是否被篡改过</td></tr><tr><td>go mod why</td><td>查看为什么需要依赖某模块</td></tr></tbody></table></li><li><p>go mod 环境变量--GO111MODULE</p><p>可以通过 go env命令查看</p><p>go语言提供了GO111MODULE这个环境变量来作为go modules的开关，其允许设置以下参数：</p><ul><li>auto ： 只要项目包含了go.mod文件的话启用go modules</li><li>on：启用go modules，推荐设置，将会是未来版本中的默认值。</li><li>off：禁用go modules，不推荐设置。</li></ul><p>命令：</p><div class="language-bash ext-sh"><pre class="language-bash"><code>$ go <span class="token function">env</span> -w <span class="token assign-left variable">GO111MODULE</span><span class="token operator">=</span>ON
</code></pre></div></li><li><p>GOPROXY</p><p>这个环境变量主要是用于设置Go模块代理，其作用是用于使Go在后续拉取模块版本时直接通过镜像站点来快速拉取。</p><div class="language-bash ext-sh"><pre class="language-bash"><code>$ go <span class="token function">env</span> -w <span class="token assign-left variable">GOPROXY</span><span class="token operator">=</span>https://goproxy.cn,direct
</code></pre></div></li><li><p>GOSUMDB</p><p>用来校验拉取的第三方库是否是完整的，如果设置了GOPROXY，这个就不用设置了。</p></li><li><p>GONOPROXY、GONOSUMDB、GOPRIVATE</p><p>设置GOPRIVATE即可，他们表示一个意思，表示第三方库是私有仓库。</p></li><li><p>初始化项目</p><ul><li><p>任意文件夹创建项目</p></li><li><p>创建go.mod文件 init</p></li><li><p>在该项目编写源代码</p><p>如果源代码中依赖某个库，我们可以手动download即用go get，也可以自动download</p></li></ul></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.e0780f3d.js" defer></script>
  </body>
</html>
