<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.45">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icon/111.ico"><title>shAilene</title><meta name="description" content="just be simple.">
    <link rel="modulepreload" href="/study/assets/app.2f53866d.js"><link rel="modulepreload" href="/study/assets/JavaScript.html.994b6fae.js"><link rel="modulepreload" href="/study/assets/JavaScript.html.435f3e41.js"><link rel="prefetch" href="/study/assets/index.html.f365cd28.js"><link rel="prefetch" href="/study/assets/index.html.b4e8ecc9.js"><link rel="prefetch" href="/study/assets/index.html.044a9fe9.js"><link rel="prefetch" href="/study/assets/index.html.9e63fae0.js"><link rel="prefetch" href="/study/assets/index.html.526de3a9.js"><link rel="prefetch" href="/study/assets/index.html.f58b71e5.js"><link rel="prefetch" href="/study/assets/index.html.6b4de082.js"><link rel="prefetch" href="/study/assets/index.html.bab2f5b4.js"><link rel="prefetch" href="/study/assets/设计模式1.html.481f9140.js"><link rel="prefetch" href="/study/assets/设计模式2.html.edfa1792.js"><link rel="prefetch" href="/study/assets/gin.html.0adc6d43.js"><link rel="prefetch" href="/study/assets/golang.html.88ee6144.js"><link rel="prefetch" href="/study/assets/gorm.html.b956f5a7.js"><link rel="prefetch" href="/study/assets/Javaweb.html.dd5f3d04.js"><link rel="prefetch" href="/study/assets/docker.html.40eb86af.js"><link rel="prefetch" href="/study/assets/ES.html.60202d39.js"><link rel="prefetch" href="/study/assets/kafka.html.cfbad411.js"><link rel="prefetch" href="/study/assets/vue基础.html.e5d46df7.js"><link rel="prefetch" href="/study/assets/vue组件.html.d449cae2.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.8abfa69d.js"><link rel="prefetch" href="/study/assets/Java笔记.html.310e20a9.js"><link rel="prefetch" href="/study/assets/dubbo.html.26a3b4ab.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.c5e74be4.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.24a33741.js"><link rel="prefetch" href="/study/assets/zookeeper.html.0aaeb747.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.dde119a6.js"><link rel="prefetch" href="/study/assets/并发编程.html.8f010d44.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.445fe277.js"><link rel="prefetch" href="/study/assets/redis.html.adaa38b5.js"><link rel="prefetch" href="/study/assets/Mybatis.html.544169aa.js"><link rel="prefetch" href="/study/assets/spring.html.bb77297d.js"><link rel="prefetch" href="/study/assets/springboot.html.90bd589b.js"><link rel="prefetch" href="/study/assets/springboot.html.fd3d54d4.js"><link rel="prefetch" href="/study/assets/springMVC.html.82c39c64.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.d940500c.js"><link rel="prefetch" href="/study/assets/操作系统.html.5537391c.js"><link rel="prefetch" href="/study/assets/flink基本篇1.html.40bdc70b.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.4e52175b.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.6bb0ec0d.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.d3cf2445.js"><link rel="prefetch" href="/study/assets/404.html.93146c89.js"><link rel="prefetch" href="/study/assets/index.html.148cd52e.js"><link rel="prefetch" href="/study/assets/index.html.fae02860.js"><link rel="prefetch" href="/study/assets/index.html.8ca17619.js"><link rel="prefetch" href="/study/assets/index.html.4224d03c.js"><link rel="prefetch" href="/study/assets/index.html.d0736e93.js"><link rel="prefetch" href="/study/assets/index.html.edf0c383.js"><link rel="prefetch" href="/study/assets/index.html.9aee403c.js"><link rel="prefetch" href="/study/assets/index.html.b31a31b6.js"><link rel="prefetch" href="/study/assets/设计模式1.html.8709a15c.js"><link rel="prefetch" href="/study/assets/设计模式2.html.e4768fd2.js"><link rel="prefetch" href="/study/assets/gin.html.5fc48e6f.js"><link rel="prefetch" href="/study/assets/golang.html.79a23ea3.js"><link rel="prefetch" href="/study/assets/gorm.html.e19b7ad1.js"><link rel="prefetch" href="/study/assets/Javaweb.html.3cba3531.js"><link rel="prefetch" href="/study/assets/docker.html.4d6ab9f9.js"><link rel="prefetch" href="/study/assets/ES.html.698e2056.js"><link rel="prefetch" href="/study/assets/kafka.html.ad1c66e1.js"><link rel="prefetch" href="/study/assets/vue基础.html.186f59b4.js"><link rel="prefetch" href="/study/assets/vue组件.html.ddad2aff.js"><link rel="prefetch" href="/study/assets/一些知识点的记录.html.e4061b5c.js"><link rel="prefetch" href="/study/assets/Java笔记.html.6f0e1db4.js"><link rel="prefetch" href="/study/assets/dubbo.html.c05c42b0.js"><link rel="prefetch" href="/study/assets/springcloud（上）.html.23d4f015.js"><link rel="prefetch" href="/study/assets/springcloud（下）.html.52abacf5.js"><link rel="prefetch" href="/study/assets/zookeeper.html.fdca5166.js"><link rel="prefetch" href="/study/assets/《并发编程的艺术》笔记.html.9d6e5b1d.js"><link rel="prefetch" href="/study/assets/并发编程.html.352f7c47.js"><link rel="prefetch" href="/study/assets/尚硅谷_宋红康_JDBC.html.27c2493a.js"><link rel="prefetch" href="/study/assets/redis.html.bc1b2dec.js"><link rel="prefetch" href="/study/assets/Mybatis.html.14c78dda.js"><link rel="prefetch" href="/study/assets/spring.html.435260ef.js"><link rel="prefetch" href="/study/assets/springboot.html.d9edf70b.js"><link rel="prefetch" href="/study/assets/springboot.html.9f79ccdd.js"><link rel="prefetch" href="/study/assets/springMVC.html.1baa7752.js"><link rel="prefetch" href="/study/assets/RabbitMQ.html.a2b0ce7a.js"><link rel="prefetch" href="/study/assets/操作系统.html.51591709.js"><link rel="prefetch" href="/study/assets/flink基本篇1.html.db9bbc52.js"><link rel="prefetch" href="/study/assets/flink基本篇2.html.98504426.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第一部分.html.344add61.js"><link rel="prefetch" href="/study/assets/MySQL数据库笔记-第二部分.html.3be9f15d.js"><link rel="prefetch" href="/study/assets/404.html.611d3c28.js"><link rel="prefetch" href="/study/assets/404.f889b4f7.js"><link rel="prefetch" href="/study/assets/Layout.47ba9cb1.js">
    <link rel="stylesheet" href="/study/assets/style.2bba04cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/study/" class=""><img class="logo" src="/study/images/leo.jpg" alt="shAilene"><span class="site-name can-hide">shAilene</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/study/计算机基础/" class="" aria-label="计算机基础"><!--[--><!--]--> 计算机基础 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/java/" class="" aria-label="Java"><!--[--><!--]--> Java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/go/" class="" aria-label="Go"><!--[--><!--]--> Go <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/mw/" class="" aria-label="中间件"><!--[--><!--]--> 中间件 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/Design-patterns/" class="" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/study/前端/" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#快速入门基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="快速入门基础"><!--[--><!--]--> 快速入门基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#面向对象编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="面向对象编程"><!--[--><!--]--> 面向对象编程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#浏览器" class="router-link-active router-link-exact-active sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#jquery" class="router-link-active router-link-exact-active sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#node-js" class="router-link-active router-link-exact-active sidebar-item" aria-label="node.js"><!--[--><!--]--> node.js <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/study/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript.html#web开发" class="router-link-active router-link-exact-active sidebar-item" aria-label="web开发"><!--[--><!--]--> web开发 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="快速入门基础" tabindex="-1"><a class="header-anchor" href="#快速入门基础" aria-hidden="true">#</a> 快速入门基础</h2><ol><li><p>要让浏览器运行javaScript，必须先有一个HTML页面，在HTML页面中引入JavaScript，然后，让浏览器加载该HTML页面，就可以执行JavaScript代码</p></li><li><p>javaScript的语法和java类似，每个语句以“；”结束，语句块用{...}</p><p>但是JavaScript并不强制要求在每个语句的结尾加；</p><p>python的每个语句结尾则不需要加；</p><p>python也是脚本语言</p><p>浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上；</p></li><li><p>让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。</p></li></ol><p>所以要养成加；的习惯</p><ol start="4"><li><p>javaScript不区分整数和浮点数，统一用Number表示</p></li><li><p>由于JavaScript设计缺陷，不要使用==比较，始终坚持使用===比较</p></li><li><p>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己</p></li><li><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Bob&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
    <span class="token literal-property property">tags</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;js&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;web&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;mobile&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">city</span><span class="token operator">:</span> <span class="token string">&#39;Beijing&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">hasCar</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">zipcode</span><span class="token operator">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。</p></li><li><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言，静态语言在定义变量时必须指定变量类型，如果赋值的时候不匹配，就会报错，例如java是静态语言。</p></li><li><p>如果一个变量没有通过var申明就被使用，那么该变量就自动申明为全局变量。</p></li><li><p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串</p></li><li><p>JavaScript的<code>Array</code>可以包含任意数据类型，并通过索引来访问每个元素。</p></li><li><p>HTML定义了网页的内容</p><p>CSS描述了网页的布局</p><p>JavaScript控制了网页的行为。</p></li><li><p>JavaScript是web的编程语言</p><p>所有现代的HTML页面都是用JavaScript</p></li><li><p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性</p></li><li><p><code>do { ... } while()</code>循环，它和<code>while</code>循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件</p><p>用<code>do { ... } while()</code>循环要小心，循环体会至少执行1次，而<code>for</code>和<code>while</code>循环则可能一次都不执行。</p></li><li><p>作为一个Web开发工程师来说，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。</p></li></ol><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><ol><li><p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。</p></li><li><p>如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响</p></li><li><p>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行，因为此时外部函数定义的变量对于内部函数来说就相当于全局变量。</p></li><li><p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量</p></li><li><p>编写高阶函数，就是让函数的参数能够接收别的函数</p></li><li><p><code>Array</code>的<code>sort()</code>方法默认把所有元素先转换为String再排序</p></li><li><p>默认情况下，对字符串排序，是按照ASCII的大小比较的</p></li><li><p><code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">var</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;B&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;C&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a1<span class="token punctuation">;</span> <span class="token comment">// [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
a2<span class="token punctuation">;</span> <span class="token comment">// [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
a1 <span class="token operator">===</span> a2<span class="token punctuation">;</span> <span class="token comment">// true, a1和a2是同一对象</span>
</code></pre></div></li><li><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回</p></li><li><p>箭头函数的参数如果不是一个，就需要用括号 <code>()</code>括起来</p></li><li><p>箭头函数如果最外层是大括号<code>{}</code>，就不能省略<code>return</code></p></li></ol><h2 id="面向对象编程" tabindex="-1"><a class="header-anchor" href="#面向对象编程" aria-hidden="true">#</a> 面向对象编程</h2><ol><li><p>在JavaScript中，字符串也区分<code>string</code>类型和它的包装类型。包装对象用<code>new</code>创建</p><p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为<code>object</code>了！所以，包装对象和原始值用<code>===</code>比较会返回<code>false</code></p></li><li><p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已</p><p>在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型</p></li><li><p>JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，这个对象的所有属性和方法，都会被构造函数的实例继承。</p><p>也就是说，JavaScript里，继承的对象，可以通过构造函数的实例继承。</p><p>用<code>new</code>来调用构造函数，实际上在这里构造函数就相当于是java里的类，所以在JavaScript里构造函数约定用大写开头。</p><p>用<code>new</code>来调用构造函数，返回的对象就是实例。只不过在java里的实例化对象指的是将抽象类实例化，这里是将构造的抽象的构造函数实例化一个对象出来。</p><p>所以有<strong>构造函数的实例</strong>这种说法。</p></li><li><p>我们可以把那些不变的方法和属性，直接定义在prototype对象上。</p></li><li><p><code>isPrototypeOf()</code>这个方法用来判断某个prototype对象和某个实例之间的关系</p><p><code>prototype</code>是构造函数的属性，指向的是另一个对象，这个对象的所有属性和方法会被构造函数的实例所继承。</p><p>可以理解为构造函数的这个prototype属性是构造函数实例化之后的对象的原型。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>　　<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>cat1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

　　<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>cat2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div></li><li><p><code>hasOwnProperty()</code></p><p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p><blockquote><p>alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</p><p>alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</p></blockquote></li><li><p>构造函数可以看作是java里的类，所以，调用构造函数千万不要忘记写<code>new</code>。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写</p></li><li><div class="language-javascript ext-js"><pre class="language-javascript"><code>　　Cat<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   　　Cat<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat<span class="token punctuation">;</span>
   
   　　<span class="token keyword">var</span> cat1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&quot;大毛&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;黄色&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   　　<span class="token function">alert</span><span class="token punctuation">(</span>cat1<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 动物</span>
</code></pre></div><p>任何一个构造函数的prototype对象都有一个constructor属性，又指向这个构造函数。如果没有&quot;Cat.prototype = new Animal();&quot;这一行，Cat.prototype.constructor是指向Cat的，加了这一行以后，Cat.prototype.constructor指向Animal。<strong>因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</strong></p></li><li><p><strong>如果替换了prototype对象，那么下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</strong></p></li><li><p>以上部分实例是变量，类是函数。</p></li><li><p><code>class</code></p><p>ES6引入的<code>class</code>和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，<code>class</code>的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用<code>class</code>的好处就是极大地简化了原型链代码。</p></li></ol><h2 id="浏览器" tabindex="-1"><a class="header-anchor" href="#浏览器" aria-hidden="true">#</a> 浏览器</h2><ol><li><p><code>cookie</code></p><p>服务器区分是哪个用户发送的请求。</p><p>当一个用户成功登录后，服务器发送一个cookie给浏览器，此后，浏览器访问该网站时，会在请求头（header）上附上这个cookie。服务器根据浏览器附上的cookie即可区分出用户。</p></li><li><p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点</p></li><li><p><code>HTML</code></p><p>HTML是一种标记性语言，超文本标记语言，所谓超文本，顾名思义就是除了文字，还可以包含图形、动画、声音、链接等非文字元素。HTML文档就是一系列的Tag组成，由于HTML是富文档模型，所以，还有一系列的Tag用来表示链接、图片、表格、表单等等。</p></li><li><p>自然语言是人与人之间交流的语言，而HTML是人与浏览器之间交流的语言</p><p>通过HTML命令告诉浏览器，在网页的哪个位置有什么控件，而控件的样式，控件的功能，则分别需要CSS和JavaScript来实现。</p></li><li><p><code>CSS</code></p><p>CSS(英文全称：Cascading Style Sheets)，中文全称：层叠样式表</p><p>是一种用来表现HTML和XML等文件样式的计算机语言</p><p>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p><p>CSS用来控制HTML里的所有元素如何展现，比如，给标题元素<code>&lt;h1&gt;</code>加一个样式，变成48号字体，灰色，带阴影</p><p>也就是说HTML能确定一个页面上大致有些什么内容，CSS决定具体的控件的样式和布局、美化方面。而控件的逻辑，前后端接口调用等逻辑由JavaScript来写。VUE框架里面包含了这些东西。</p></li><li><p><code>javaScript</code></p><p>JavaScript(简称：JS)是一种直译式高级脚本语言，常用来为网页添加各式各样的复杂动态功能，为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。</p></li><li><p><code>markdown</code></p><p>markdown和HTML都是标记性语言，不同点在于，markdown是文本语言，HTML除了文字还有别的图形动画声音等非文字元素。</p></li><li><p><strong>HTML加上CSS、JavaScript呈现出我们最终看到的网页</strong></p></li></ol><h2 id="jquery" tabindex="-1"><a class="header-anchor" href="#jquery" aria-hidden="true">#</a> jQuery</h2><ol><li><p>层级选择器</p><p>如果两个DOM元素具有层级关系，就可以用<code>$(&#39;ancestor descendant&#39;)</code>来选择，层级之间用空格隔开。</p></li><li><p>子选择器</p><p>子选择器<code>$(&#39;parent&gt;child&#39;)</code>类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。</p></li><li><p>选择器是jQuery的核心</p></li><li><p><strong>实际上，jQuery把所有方法也就是功能都封装在一个全局变量中，这个全局变量就是jQuery，而<code>$</code>也是一个合法的变量名，是jQuery的别名</strong></p></li><li><p>通常情况下，选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。</p></li><li><p>jQuery是一个JavaScript库，极大地简化了JavaScript的编程。</p></li><li><p>在jQuery中，$( )是其运行环境；</p></li><li><p>由于不同浏览器绑定事件的代码不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器之间的差异，总是编写相同的代码。</p></li><li><p>on方法用来绑定一个事件，需要传入事件名称和对应的处理函数。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>a<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;Hello!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>用JavaScript实现动画的原理：</p><p>我们只需要以固定的时间间隔（例如 0.1s），每次把DOM元素的CSS样式修改一点，看起来就像动画了。</p></li><li><p><code>animate()</code>可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值</p></li><li><p>jQuery的原理是逐渐改变CSS的值。但是很多不是block性质的DOM元素，对它们设置<code>height</code>根本就不起作用，所以动画也就没有效果。</p></li><li><p>编写jQuery插件的原则：</p><ol><li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑</li><li>插件函数要<code>return this;</code>以支持链式调用</li><li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>上；</li><li>用户在调用时可传入设定值以便覆盖默认值。</li></ol></li><li><p>jQuery对象的有些方法只能作用在特定DOM元素上，比如<code>submit()</code>方法只能针对<code>form</code>。</p></li><li><p>Node.js平台是在后端运行JavaScript代码</p></li></ol><h2 id="node-js" tabindex="-1"><a class="header-anchor" href="#node-js" aria-hidden="true">#</a> node.js</h2><ol><li><p>注意区分命令行模式和交互模式。</p><p>命令行模式就可以理解为安装好jdk之后，从windows命令行进行运行程序的操作。</p><p><code>java xxx.java</code></p><p><code>node xxx.js</code></p><p><code>python xxx.py</code></p><p>交互模式就像python的IDLE那样，写一行会编译一行，也可以说是解释一行，因为python和js都是脚本型语言。</p><p>看到类似<code>C:\&gt;</code>是在Windows提供的命令行模式</p><p>在命令行模式下，可以执行<code>node</code>进入Node交互式环境，也可以执行<code>node hello.js</code>运行一个<code>.js</code>文件。</p><p>看到<code>&gt;</code>是在Node交互式环境下</p><p>在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。</p></li><li><p><strong>在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。</strong></p></li><li><p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。（类似于python解释器，IDLE）</p><p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p></li><li><p>VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个<code>.vscode</code>的配置目录，里面存放里VS Code需要的配置文件。</p></li><li><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。</p></li><li><p>在Node环境中，一个.js文件就称之为一个模块（module）。</p><p>在python环境中，一个.py文件就称之为一个模块，多个模块即多个.py文件组成一个包</p><p>模块即.py文件就是用来导入的，就像在java环境中一个.java文件大多是一个类，用来在别的程序中import。</p><p>import了某个类，那么就可以用那个类中的方法。</p></li><li><p>要在模块中对外输出变量，用：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> variable<span class="token punctuation">;</span>
</code></pre></div><p>输出的变量可以是任意对象、函数、数组等等。</p><p>要引入其他模块输出的对象，用：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;other_module&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p></li><li><p>node.js是运行在服务器端的JavaScript环境</p><p>服务器程序与浏览器程序相比，最大的特点就是没有浏览器的安全限制了。</p><p>在服务端通过node.js运行程序，和通过浏览器来运行程序是不同的，这里的通过浏览器运行程序除了字面意思，也就是通过edge、chrome等，在开发者模式下的控制台直接写JavaScript代码可以运行程序，还是指在vscode中，通过debugger for edge、debugger for chrome来运行程序。</p><p>运行程序的时候，通过node.js还是debugger for edge，这是不同的，运行环境不同，一个是在服务器端运行，一个是在浏览器端运行，比如在浏览器中可以顺利运行，而在服务器端不可以，这是因为node.js环境没有浏览器环境的相关变量之类的东西。（比如说window这个变量，jQuery的$）。</p></li><li><p>JavaScript有且仅有一个全局对象，在浏览器环境，叫<code>window</code>对象</p><p>而在node.js环境中，叫<code>global</code>，这也是为什么在js文件中写window对象不会报错，但是直接通过codeRunner运行这个js文件会报错的原因，因为直接运行js文件，导致根本就不是一个环境，没有这个<code>window</code>对象，通过node.js运行，当然会报错。出现这种错误还是对js运行环境，基础的不了解。</p><p><code>global</code>这个对象的属性和方法也和浏览器环境的<code>window</code>不同</p></li><li><p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&#39;undefined&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;node.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;browser&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li><li><p>同步读文件和异步读文件的区别</p><p>异步读文件</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">&#39;sample.png&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token string">&#39; bytes&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同步读文件</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">&#39;sample.txt&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;utf-8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p><p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p></li><li><p><code>stream</code></p><p>标准输入流，字符从键盘输入到应用程序</p><p>标准输出流，字符从应用程序输出到键盘</p><p>流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。</p><p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：</p><p><code>data</code>事件表示流的数据已经可以读取了，</p><p><code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，</p><p><code>error</code>事件表示出错了。</p></li></ol><h2 id="web开发" tabindex="-1"><a class="header-anchor" href="#web开发" aria-hidden="true">#</a> web开发</h2><ol><li><p>软件主要运行在桌面上，采用的模式是CS架构模式即client/server架构模式。这种模式简称CS架构</p><p>软件是在桌面上作为客户端运行，而数据库这样的软件运行在服务端作为server</p><p>这种CS架构模式并不适合web，因为web应用程序的修改和升级都非常迅速，因为CS架构的方式都是通过客户端升级的方式来升级桌面APP（client），客户端不断升级这种方式显然对于浏览器和web来说不适合。</p><p>因此，Browser/server模式开始流行，简称B/S架构。</p><p><strong>在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。所以当服务端升级后，客户端无需做任何升级就可以使用到新的版本。因为更新的web页面是服务器给客户端（浏览器）的</strong></p></li><li><p>web页面使用HTML写的，HTML具有超强的表现力，是超文本语言，也就是说HTML不只是文字，还有图片、声音、超链接等等。和MARKDOWN一样都是标记性语言。</p></li><li><p>Web应用特点是修改频繁</p></li><li><p>在web应用中，服务器把网页传给客户端即浏览器，实际上是把网页的HTML代码发送给浏览器，让浏览器显示出来，而浏览器和服务器之间的传输协议是HTTP。</p><blockquote><p>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</p><p>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。</p></blockquote></li><li><p>当浏览器读取到HTML源码后，也就是浏览器发送请求（request）给服务器之后，服务器会发送对应的响应给浏览器，在F12控制台页面，可以查看到浏览器会有相应的响应。</p><p>request是客户端发送给浏览器的请求，包含header、Content-Type等等，在代码里也经常会写给服务器发送请求，所以这里的客户端除了指浏览器，还有我们编写的代码。对于浏览器来说，服务器就是字面意思的服务器，对于我们有时候一个程序需要调用另一个程序的接口，用到请求httpRequest，这时候服务器就相当于另一个程序。根据Code来判断请求是否成功以及是客户端还是服务端出了问题。</p><p>比如说前端网页发送请求给后端，这显然说的就是浏览器发送请求request给服务器，服务器给出对应的响应，浏览器接收到响应，响应可以在开发者界面查看到。</p><p><strong>核心就是A发送请求给B，那么A就是作为客户端，B就是作为服务端，根据错误码可以判断是哪一端出了问题。</strong></p><p>这里一直在说浏览器和服务器，实际也就是客户端和服务器，HTTP就是他们双方之间通信的协议。</p></li><li><p>浏览器获得响应后，得到HTML源码后，会解析HTML并显示页面，然后根据HTML页面里面的各种链接，再发送HTTP请求给服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在<code>Network</code>下面能看到很多额外的HTTP请求。</p></li><li><p>开发者界面的Network这个选项就是查看浏览器（客户端）和服务端之间的通信的。</p><p>客户端&lt;-&gt;服务端</p><p>前端&lt;-&gt;后端</p><p>可以把服务器理解为后端，仍然需要程序代码支撑，这就是后端开发。</p></li><li><p><code>Elements</code>显示网页的结构，<code>Network</code>显示浏览器和服务器的通信。</p></li><li><p>总结HTTP Request的流程</p><blockquote><ol><li><p>浏览器首先向服务器发送http request，request包括</p><ul><li>方法：<code>GET</code>还是<code>POST</code>，<code>GET</code>仅请求资源，<code>POST</code>会附带用户数据</li><li>路径</li><li>域名：由Host头指定：<code>Host: www.sina.com.cn</code></li><li>如果是<code>POST</code>，那么请求还包括一个Body，包含用户数据。</li></ul></li><li><p>服务器（后端，前端后端都涉及到代码开发。服务器怎么返回，根据前端的request返回什么内容、什么格式、怎么处理前端的请求，这些都是后端开发需要考虑的内容。这些就相当于是后端考虑，前端就不需要考虑了，只管发送请求，相当于是服务器为浏览器的请求提供了接口，也就是API）</p><p>服务器向浏览器返回HTTP响应，响应包括：</p><ul><li>响应代码 <code>200</code>表示成功，<code>3xx</code>表示重定向，<code>4xx</code>表示客户端发送的请求有错误，<code>5xx</code>表示服务器端处理时发生了错误；（<code>4xx</code>也是开发的时候最经常遇到的错误，说明客户端的请求有错误，但是这里不是说一定是客户端发送的请求内容错了，而是客户端相对于服务器来说，请求有错误，比如说服务端的程序提供的接口内部有bug，正确的请求内容发送过去肯定也是返回<code>4xx</code>错误，因为客户端的请求让服务端返回了错误响应，所以是<code>4xx</code>错误。<code>5xx</code>错误一般是我们在开发过程中管不了的）</li><li>响应类型，由<code>Content-Type</code>指定，例如：<code>Content-Type: text/html;charset=utf-8</code>表示响应类型是HTML文本，并且编码是<code>UTF-8</code>，<code>Content-Type: image/jpeg</code>表示响应类型是JPEG格式的图片；</li><li>以及其他相关的Header；</li><li>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</li></ul></li><li><p>如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p></li></ol></blockquote></li><li><p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。</p></li><li><p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是<code>http://www.sina.com.cn/</code>的首页，但是新浪在HTML中可以链入其他服务器的资源，比如<code>&lt;img src=&quot;http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png&quot;&gt;</code>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称“三达不溜”（WWW）。</p></li><li><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分</p></li><li><p>服务器返回的响应的body类型由<code>Content-Type</code>指定</p></li><li><p>HTML文档就是一系列的Tag组成</p></li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 64005626+shaileneF@users.noreply.github.com">shailene</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/study/assets/app.2f53866d.js" defer></script>
  </body>
</html>
